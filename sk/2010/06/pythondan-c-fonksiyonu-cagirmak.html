<h1>Python'dan C Fonksiyonu Cagirmak</h1>
<p>Python script icinden C fonksiyonu cagirmak icin sunlar gerekli. Kodun
testmod.c dosyasinda oldugunu farzedelim; once bir shared library
olusturmamiz lazim. make.sh adinda bir derleme script'i soyle
olabilir:</p>
<pre><code>#!/bin/sh
gcc -shared -o testmod.so -I/usr/include/python2.5 -lpython2.5  testmod.c
</code></pre>

<p>C fonksiyonu soyle bir dosyada:</p>
<h1>include "Python.h"</h1>
<pre><code>static PyObject* py_myFunction(PyObject* self, PyObject* args)
{
 char *s = &quot;Hello from C!&quot;;
 return Py_BuildValue(&quot;s&quot;, s);
}

static PyObject* py_myOtherFunction(PyObject* self, PyObject* args)
{
 double x, y;
 PyArg_ParseTuple(args, &quot;dd&quot;, &amp;x, &amp;y);
 return Py_BuildValue(&quot;d&quot;, x*y);
}

static PyMethodDef myModule_methods[] = {
 {&quot;myFunction&quot;, py_myFunction, METH_VARARGS},
 {&quot;myOtherFunction&quot;, py_myOtherFunction, METH_VARARGS},
 {NULL, NULL}
};

void inittestmod()
{
 (void) Py_InitModule(&quot;testmod&quot;, myModule_methods);
}
</code></pre>

<p>Usttekileri make.sh ile derledikten sonra, bir Python script icinden
sunlar isletilebilir:</p>
<pre><code>from testmod import *

print &quot;Result from myFunction:&quot;, myFunction()
print &quot;Result from myOtherFunction(4.0, 5.0):&quot;, myOtherFunction(4.0, 5.0)
</code></pre>

<p>Kodlarin tamami altta</p>
<p>Not: Eger gcc yerine g++ kullanirsaniz, o zaman tum fonksiyonlarin
extern "C" { } ile sarilmasi gerekli, cunku g++ derleyicileri
derlerken fonksiyon isimlerini degisime ugratiyorlar (mangling), ve
Python yorumlayicisi bekledigi cagri isimlerini bulamayinca hata
veriyor. Surada.</p>
<p>Not: Bir .so dosyasi, shared library icindeki sembolleri, fonksiyon
cagrilarini listelemek icin "nm dosya.so" komutu kullanilabilir.</p>
<p>Kaynak</p>
<p>make.sh</p>
<pre><code>#!/bin/sh
gcc -shared -o testmod.so -g `pkg-config opencv --cflags --libs glib-2.0` -I/usr/include/python2.5 -lpython2.5  testmod.c
</code></pre>

<p>testmod.c</p>
<pre><code>#include &quot;Python.h&quot;

/*

 * Function to be called from Python

 */

static PyObject* py_myFunction(PyObject* self, PyObject* args)

{

 char *s = &quot;Hello from C!&quot;;

 return Py_BuildValue(&quot;s&quot;, s);

}



/*

 * Another function to be called from Python

 */

static PyObject* py_myOtherFunction(PyObject* self, PyObject* args)

{

 double x, y;

 PyArg_ParseTuple(args, &quot;dd&quot;, &amp;x, &amp;y);

 return Py_BuildValue(&quot;d&quot;, x*y);

}



/*

 * Bind Python function names to our C functions

 */

static PyMethodDef myModule_methods[] = {

 {&quot;myFunction&quot;, py_myFunction, METH_VARARGS},

 {&quot;myOtherFunction&quot;, py_myOtherFunction, METH_VARARGS},

 {NULL, NULL}

};



/*

 * Python calls this to let us initialize our module

 */

void inittestmod()

{

 (void) Py_InitModule(&quot;testmod&quot;, myModule_methods);

}
</code></pre>

<p>testmod.py</p>
<pre><code>from testmod import *

print &quot;Result from myFunction:&quot;, myFunction()

print &quot;Result from myOtherFunction(4.0, 5.0):&quot;, myOtherFunction(4.0, 5.0)
</code></pre>