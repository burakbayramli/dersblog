
<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
   <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
   </script>
   <link rel="stylesheet" type="text/css" media="screen" href="https://burakbayramli.github.io/css/style.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1548953794786292"
          crossorigin="anonymous"></script>  
  </head>
    <body>
      <div id="header_wrap" class="outer">
        <header class="inner">
          <h1 id="project_title">
            <a href="https://burakbayramli.github.io" style="text-decoration:none; color:inherit;">dersblog</a>
          </h1>
          <h2 id="project_tagline"></h2>          
        </header>
      </div>
      <div id="main_content_wrap" class="outer">        
        <section id="main_content" class="inner">
        <h1></h1>
<h1>Python Sözlük (Dictionary) Veri Yapısı</h1>

<p>Python sözlük yapısı hafızada anahtar bazlı veriye direk erişim (dizin
erişimi kadar hızlı) sağlar.  Basit anahtar - değer ikilisini
depolayabiliriz, fakat değer olarak depolanan şey herhangi bir obje
olabilir. Bu özellik sözlüklere geniş kullanım alanı sağlar.</p>

<p>En basit kullanım,</p>

<div class="codehilite">
<pre><span></span><code><span class="c1"># bos sozluk yarat</span>
<span class="n">dict1</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># depola</span>
<span class="n">dict1</span><span class="p">[</span><span class="s1">&#39;anahtar1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;deger1&quot;</span>

<span class="c1"># erisim yap</span>
<span class="n">dict1</span><span class="p">[</span><span class="s1">&#39;anahtar1&#39;</span><span class="p">]</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: &#39;deger1&#39;
</code></pre>
</div>

<p>Herhangi bir obje depolanır demiştik,</p>

<div class="codehilite">
<pre><span></span><code><span class="n">dict1</span><span class="p">[</span><span class="s1">&#39;anahtar2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">dict1</span><span class="p">[</span><span class="s1">&#39;anahtar2&#39;</span><span class="p">]</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: array([1, 2, 3])
</code></pre>
</div>

<p>Tüm anahtarları göstermek için</p>

<div class="codehilite">
<pre><span></span><code><span class="n">dict1</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: dict_keys([&#39;anahtar1&#39;, &#39;anahtar2&#39;])
</code></pre>
</div>

<p>Bu liste gezilebilir, ve bu sırada anahtar kullanılıp değer ekrana basılabilir,</p>

<div class="codehilite">
<pre><span></span><code><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dict1</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="n">dict1</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>deger1
[1 2 3]
</code></pre>
</div>

<p>Eğer olmayan değere erişirsek hata gelir,</p>

<div class="codehilite">
<pre><span></span><code><span class="n">dict1</span><span class="p">[</span><span class="s1">&#39;olmayan anahtar&#39;</span><span class="p">]</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>KeyErrorTraceback (most recent call last)
&lt;ipython-input-1-90fef2a85d10&gt; in &lt;module&gt;
      1 plt.figure();
      2 
----&gt; 3 dict1[&#39;olmayan anahtar&#39;]

KeyError: &#39;olmayan anahtar&#39;
</code></pre>
</div>

<p>Hata oluşturmadan eğer anahtar varsa değer yoksa <code>None</code> gelsin istersek <code>.get</code>
çağrısı var,</p>

<div class="codehilite">
<pre><span></span><code><span class="nb">print</span> <span class="p">(</span><span class="n">dict1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;olmayan anahtar&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>None
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code><span class="nb">print</span> <span class="p">(</span><span class="n">dict1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;anahtar1&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>deger1
</code></pre>
</div>

<p>Kavrama (comprehension) yani [1] tek satırda hem başka bir listeyi gezip aynı
anda başka bir liste / sözlük yaratma kabiliyeti sözlükler için de geçerli,</p>

<div class="codehilite">
<pre><span></span><code><span class="n">dict2</span> <span class="o">=</span> <span class="p">{</span> <span class="n">i</span><span class="p">:</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;ali&#39;</span><span class="p">,</span><span class="s1">&#39;veli&#39;</span><span class="p">,</span><span class="s1">&#39;ahmet&#39;</span><span class="p">])</span> <span class="p">}</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">dict2</span><span class="p">)</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>{0: &#39;ali&#39;, 1: &#39;veli&#39;, 2: &#39;ahmet&#39;}
</code></pre>
</div>

<p><code>i:x</code> ile anahtar/değer ikilisini başka bir listeyi gezerken tanımladık, ve
bu tanımlar toparlanıp bir yeni sözlük yaratımı için kullanıldı.</p>

<h3>Sözlük İç Yapısı</h3>

<p>Sözlüklerin iç kodlanması nasıl yapılmıştır acaba? Bundan da
bahsedelim, mülakat sorusu olabilir, zaten görünmese de bu tür
detayları bilmek faydalıdır. Bir sözlük paketini kodlamak için en baz
depolama veri yapısı olarak bir dizin (array) kullanabiliriz. Ama
dizin erişimi tam sayı bazlıdır, üstelik baştan kaç öğe olduğu
bellidir, anahtarı herhangi bir şey olabilecek sözlükleri bunun üstüne
nasıl monte edeceğiz?</p>

<p>Böleç (hash) kavramı burada yardıma yetişir. Harfler, alfanumerik
herhangi bir veriyi <code>hash</code> ile sayısal forma çevirebileceğimizi
biliyoruz,</p>

<div class="codehilite">
<pre><span></span><code><span class="nb">hash</span><span class="p">(</span><span class="s2">&quot;anahtar1&quot;</span><span class="p">)</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: 6762465535002540417
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code><span class="nb">hash</span><span class="p">(</span><span class="s2">&quot;anahtar2&quot;</span><span class="p">)</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: 1439585439643666777
</code></pre>
</div>

<p>Eğer sözlüğün deposu olarak 10 büyüklüğünde bir listeyi depolama için
kullanmak istiyorsak üstteki sayıların 10 üzerinden modülüs hesabını
yaparız,</p>

<div class="codehilite">
<pre><span></span><code><span class="nb">hash</span><span class="p">(</span><span class="s2">&quot;anahtar1&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: 7
</code></pre>
</div>

<p>İşte bu sayı dizinde erişim için kullanılır.</p>

<p>Eğer dizin büyüklüğüne kıyasla çok fazla anahtar değeri var ise birden
fazla anahtar aynı dizin öğesine düşebilir, bu "çakışma (collision)"
durumu yaratır, bu durumda çakışma olan öğede bir liste yaratırız
(dizin içinde liste), ve erişim için arama önce anahtar bazlı direk
sonra liste bazlı teker teker gider.</p>

<h3>DiskDict</h3>

<p>Paketten çıkan hali ile Python sözlükleri hafıza bazlıdır. Fakat eğer anahtar
erişimi bizi bir disk deposuna götürsün istersek? Dikkat tüm işlemler hafızada
yapıldıktan sonra işi bitmiş sözlüğü diske yazmaktan bahsetmiyorum, her anahtar
erişimi, her depolama işleme tekil bazlı olarak diske gitmeli diyorum. </p>

<p>Bu ihtiyaç için bazı paketler var. Çoğu dış arayüzünü Python basit
sözlük ile benzer tutmuş böylece kodlayan yeni bir erişim stili
öğrenmeye mecbur değil, tüm bildik sözlük işlemleri geçerli.</p>

<p>Böyle bir paket <code>diskdict</code> [3]. Kurmak için kaynaklar kullanılırsa iyi
olur, önce alttakiler,</p>

<pre><code>sudo apt install python3-leveldb libleveldb-dev

pip install repoze.lru
</code></pre>

<p>Ardından <code>setup.py</code> ile kurulum yapılır. Örnek,</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span> <span class="nn">diskdict</span> <span class="kn">import</span> <span class="n">DiskDict</span>

<span class="n">dict3</span> <span class="o">=</span> <span class="n">DiskDict</span><span class="p">(</span><span class="s1">&#39;/tmp/diskdict&#39;</span><span class="p">)</span>

<span class="n">dict3</span><span class="p">[</span><span class="s1">&#39;anahtar3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;deger3&#39;</span>
</code></pre>
</div>

<p>Bu işlemler sonrası <code>/tmp/diskdict</code> dizini altında bazı dosyaların
yaratılmış olduğunu göreceğiz. Sözlüğün disksel erişim işlemleri bu
dosyalar üzerinden yapılıyor, her erişim her depolama direk bu
dosyalara gidiyor (dosyaların ikisel formatı muhakkak hızlı erişim
için ayarlanmış halde).</p>

<h3>Olagan Degerler, Siralanma</h3>

<p>Pek çok ihtiyaca yardım etmeye uğraşan ek sözlük tipleri de
vardır. Bunlardan biri olmayan bir değere erişildiğinde o anahtar için
olağan (default) bir değeri otomatik yaratan bir sözlük tipidir,
<code>defaultdict</code></p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">dict4</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">dict4</span><span class="p">[</span><span class="s1">&#39;anahtar4&#39;</span><span class="p">]</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: 0
</code></pre>
</div>

<p>Olağan değer sözlüklerinin en kullanışlı olduğu yer belli anahtar değerlerine
tekabül eden listelere öğe eklemek istediğimiz zamandır. Pek çok problemde
belli anahtarlara tekabül eden liste değerleri gezeriz, onları bir listeye
döngü içinde eklemek isteriz fakat her anahtar için "eğer bu anahtar varsa
listeye ekle, yoksa boş liste yarat, ondan sonra ekle" mantığı kod fazlalığı
oluşturabilir, <code>defaultdıçt(list)</code> kullanırsak her anahtarın olağan değeri
boş liste olacağı için bir anahtar var mı yok mu bakmadan direk o anahtarın
listesine ekleme yapabiliriz çünkü o anahtarın listesi yoksa nasıl olsa
yaratılacaktır. Örnek,</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">city_list</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;TX&#39;</span><span class="p">,</span><span class="s1">&#39;Austin&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;TX&#39;</span><span class="p">,</span><span class="s1">&#39;Houston&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;NY&#39;</span><span class="p">,</span><span class="s1">&#39;Albany&#39;</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;NY&#39;</span><span class="p">,</span> <span class="s1">&#39;Syracuse&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;NY&#39;</span><span class="p">,</span> <span class="s1">&#39;Buffalo&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;NY&#39;</span><span class="p">,</span> <span class="s1">&#39;Rochester&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;TX&#39;</span><span class="p">,</span>
<span class="s1">&#39;Dallas&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;CA&#39;</span><span class="p">,</span><span class="s1">&#39;Sacramento&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;CA&#39;</span><span class="p">,</span> <span class="s1">&#39;Palo Alto&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;GA&#39;</span><span class="p">,</span>
<span class="s1">&#39;Atlanta&#39;</span><span class="p">)]</span>

<span class="n">cities_by_state</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">city</span> <span class="ow">in</span> <span class="n">city_list</span><span class="p">:</span>
    <span class="n">cities_by_state</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">city</span><span class="p">)</span>

<span class="n">cities_by_state</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: 
defaultdict(list,
            {&#39;TX&#39;: [&#39;Austin&#39;, &#39;Houston&#39;, &#39;Dallas&#39;],
             &#39;NY&#39;: [&#39;Albany&#39;, &#39;Syracuse&#39;, &#39;Buffalo&#39;, &#39;Rochester&#39;],
             &#39;CA&#39;: [&#39;Sacramento&#39;, &#39;Palo Alto&#39;],
             &#39;GA&#39;: [&#39;Atlanta&#39;]})
</code></pre>
</div>

<p>Gördüğümüz gibi <code>cities_by_state[state]</code> üzerinde direk <code>.append</code>
yapabildik çünkü listenin orada olacağını varsayabiliyoruz.</p>

<p>Kaynaklar</p>

<p>[1] <a name="../../2021/12/python-list-comprehension.html">Python Liste Kavraması (List Comprehension)</a></p>

<p>[2] <a name="../../2022/11/nosql-diy-python.html">NoSQL</a></p>

<p>[3] https://github.com/deep-compute/diskdict</p>

          <br/><a href="../index.html">Yukarı</a>
        </section>          
      </div>
    </body>
</html>
