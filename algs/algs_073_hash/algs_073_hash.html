<p><a href="..">Yukarı</a></p>
<h1>Geometrik Anahtarlama ile En Yakın Noktaları Bulmak</h1>
<!DOCTYPE html>
<html>
  <head>
    <title>Geometrik Anahtarlama ile En Yakın Noktaları Bulmak
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
<script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
</script>
</head>

<p>Yerelliğe Hassas Bölec (Locality Sensitive Hashing, -LSH-)</p>
<pre><code class="python">vec1 = np.array([[-0.99137472, 0.61572851, -0.37733555, 0.0363575, -0.71647706]])
vec2 = np.array([[-0.16737788, 0.83147812, -2.06947369, -0.48174425, -1.60276846]])
vec3 = np.array([[-0.9074722, 0.75953396, 1.10696926, -0.8773451, -1.11589595]])

projections = np.array([[0.58834302, 0.24020825, 2.21323827, -0.21147486, 1.18477223],\
                        [-0.31146359, -1.88214137, -0.37489443, -0.58475914, -1.57121651]])
print (projections)
</code></pre>

<pre><code>[[ 0.58834302  0.24020825  2.21323827 -0.21147486  1.18477223]
 [-0.31146359 -1.88214137 -0.37489443 -0.58475914 -1.57121651]]
</code></pre>

<pre><code class="python">print (vec1.shape)
print (np.dot(vec1, projections.T))
</code></pre>

<pre><code>(1, 5)
[[-2.12704963  0.39583023]]
</code></pre>

<pre><code class="python">print (np.dot(vec1, projections.T) &gt; 0)
print (  &quot;.join(((np.dot(vec1, projections.T) &gt; 0)[0]).astype(int).astype(str))  )
</code></pre>

<pre><code>[[False  True]]
01
</code></pre>

<pre><code class="python">print (  &quot;.join(((np.dot(vec2, projections.T) &gt; 0)[0]).astype(int).astype(str))  )
print (  &quot;.join(((np.dot(vec3, projections.T) &gt; 0)[0]).astype(int).astype(str))  )
</code></pre>

<pre><code>01
11
</code></pre>

<pre><code class="python">def cosine_sim(vec1, vec2):
   return np.dot(vec1, vec2) / (np.linalg.norm(vec1)*np.linalg.norm(vec2))

print (cosine_sim(vec1[0], vec2[0]))   
print (cosine_sim(vec1[0], vec3[0]))   
print (cosine_sim(vec2[0], vec3[0]))   
</code></pre>

<pre><code>0.6524342023889728
0.5610062492540248
0.1169500241078299
</code></pre>

<p>Asal Sayılar ile Böleç (Hash) Tekniği</p>
<p>Grafik, fiziksel simülasyonlarda pek çok sayıda obje 3 boyutlu ortamda dünyaya
salınıp, ayrı ayrı onlara fiziksel kurallar uygulanır ve nereye geldiklerine
bakılır. Bu hesap sırasında objelerin birbirine çarpıp çarpmadığını hesaplamak
gerekir fakat böyle bir hesap, eğer mesela $n$ tane obje var ise, her görüntü
karesinde her $n$ tane objenin her $n-1$ diğer objenin yakınında olup olmadığı
kontrolü anlamına gelir, ki hesapsal yük $O(n^2)$ olurdu. Eğer $n$ milyonlar ise
bu ağır bir yük oluştururdu.</p>
<p>Böleç tekniğini burada da kullanabiliriz. Öyle bir sihirli böleç fonksiyonumuz
olsun ki her kordinat için bir böleç değeri üretsin ve birbirine yakın
kordinatlar için bu değer aynı olsun. Böylece basit eşitlik kontrolü ile iki
kordinatın birbirine yakın olup olmadığını hemen anlayabilirdik. Tabii daha
detaylı kontrol için böleçleri aynı olan kordinatları daha detaylı teste tabi
tutardık, ama detaylı kontrolün yapılacağı obje sayısını çok daha azaltmış
olurduk.</p>
<p>Böyle bir tekniği [1]'de görüyoruz. Teknik ile kordinat sistemini $l$
büyüklüğünde kutulara bölüyor, her eksen değerini bu büyüklük ile bölüyoruz,
bölüm sonrası elde edilen sayıyı taban (floor) tamsayıya indirgiyoruz, ardından
her eksen için farklı bir asal sayıyla çarpıp sonuçları XOR ile birleştiriyoruz
(ki XOR yaygın kullanılan bir böleç birleştirme yaklaşımı).</p>
<pre><code class="python">l = 5
n = 5
p1,p2,p3 = 73856093, 19349663, 83492791

x1 = [33,4,11]
x2 = [31,1,14]
x3 = [10,44,19]

def spatial_hash(x):
    ix,iy,iz = np.floor(x[0]/l), np.floor(x[1]/l), np.floor(x[2]/l)
    return (int(ix*p1) ^ int(iy*p2) ^ int(iz*p3)) % n

print (spatial_hash(x1))
print (spatial_hash(x2))
print (spatial_hash(x3))
</code></pre>

<pre><code>1
1
3
</code></pre>

<p>Görüldüğü gibi ilk iki kordinat aynı böleç anahtarına düştü, ki bu iki kordinat
birbirine yakın.</p>
<p>Genel algoritma şöyle olabilir. Her görüntü karesi için iki faz düşünebiliriz,
ilk fazda tüm objelerin kordinat böleci hesaplanır, her böleç değeri altında bir
liste vardır, ve her obje anahtarının değerine tekabül eden o listeye
eklenir. İkinci fazda bir objeye bakarken onun üzerinde daha detaylı çarpışma
hesabı gerekip gerekmediğini anlamak için böleç anahtarındaki listeye bakarız,
listede sadece bir öğe var ise çarpışma yok, birden fazla ise o listedeki her
diğer obje için detaylı çarpışma hesabına devam edilebilir.</p>
<p>Bazi istatistikleri toplayalim. Acaba yaklasim ne kadar basarili?</p>
<pre><code class="python">from collections import defaultdict 
import numpy as np, datetime
import numpy.linalg as lin

mmin,mmax=0,400
p1,p2,p3 = 73856093, 19349663, 83492791
B = 500; L = 50; n = int(B/3)

def spatial_hash(x):
    ix,iy,iz = int(x[0]/L), int(x[1]/L), int(x[2]/L)
    tmp = (ix*p1) ^ (iy*p2) ^ (iz*p3)
    return tmp % n

balls = []
geo_hash_list = defaultdict(list)

for b in range(B):
    p = np.array([np.random.uniform(mmin,mmax,1)[0],
                  np.random.uniform(mmin,mmax,1)[0],
                  np.random.uniform(mmin,mmax,1)[0] ])
    balls.append({'pos':p, 'i': b})

for j,b in enumerate(balls):
    geo_hash_list[spatial_hash(b['pos'])].append(b)

tp = 0; tn = 0; fp = 0; fn = 0
for i,b1 in enumerate(balls):
    for j,b2 in enumerate(balls):
        if i==j: continue
        d = lin.norm(b1['pos']-b2['pos'])
        h1 = spatial_hash(b1['pos'])
        h2 = spatial_hash(b2['pos'])

        if d &lt;= L and h1 == h2: tp += 1        
        elif d &gt; L and h1 != h2: tn+=1
        elif d &gt; L and h1 == h2: fp+=1
        elif d &lt;= L and h1 != h2: fn+=1

print ('dogru pozitif', tp)
print ('dogru negatif', tn)

print ('yanlis pozitif', fp)
print ('yanlis negatif', fn)

print (tp+tn+fp+fn)
print (&quot;Yanlis Negatif Yuzde %0.2f&quot; % (fn / (tp+tn+fp+fn) * 100.0))
</code></pre>

<pre><code>dogru pozitif 456
dogru negatif 246340
yanlis pozitif 1340
yanlis negatif 1364
249500
Yanlis Negatif Yuzde 0.55
</code></pre>

<p>500 tane topu rasgele bir şekilde her ekseni 0 ve 500 arasında olan bir uzaya
dağıttık. Topların bazıları yakın düştü tabii, bazılar düşmedi. Önce tüm topları
bölecledik ve sözlüğe koyduk. Sonra tüm topların birbiri ile olan mesafesini
ayrı ayrı teker teker külfetli yoldan yaptık, ve bölecin bu durum hakkında ne
söylediğine baktık. Pozitif bölec yakın diyor, negatif bölec uzak diyor
anlamında, tabii yakınlık ve uzaklık bölec anahtar değerinin aynı olup olmadığı
ile ölçülüyor.</p>
<p>Kontrolün doğru pozitif bulması mesela bölecin yakın dediğinin gerçekten de
yakın olması. Yanlış negatif tam tersi, bölec uzak diyor ama aslında toplar
yakın.</p>
<p>Tabii ki istediğimiz doğru hesapların değerlerin yüksek olması. Ayrıca
tekrarlayalım, bir simülasyonda işletirken yanlış pozitifin hala çaresi var,
bölecin yakın dediklerini bir kontrolden daha geçirirsek (problem değil o
noktada bakılan toplar azalmış oluyor, performans kaybı olmaz), bu kontrol
yanlış pozitifleri eleyecektir. Tek problem yanlış negatif, topların çoğu
birbirinden uzakta olduğu için bu yanlıştan dönmek zor, fakat bu tür toplar
yüzde 1'in altında.</p>
<p>Kaynaklar</p>
<p>[1] <em>Optimized Spatial Hashing for Collision Detection of Deformable Objects</em>
    <a href="https://matthias-research.github.io/pages/publications/tetraederCollision.pdf">https://matthias-research.github.io/pages/publications/tetraederCollision.pdf</a></p>
<p>[2] <em>Locality Sensitive Hashing for Similar Item Search</em>,
    <a href="https://towardsdatascience.com/locality-sensitive-hashing-for-music-search-f2f1940ace23">https://towardsdatascience.com/locality-sensitive-hashing-for-music-search-f2f1940ace23</a></p>