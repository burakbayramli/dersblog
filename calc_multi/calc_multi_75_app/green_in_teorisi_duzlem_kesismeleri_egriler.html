<!DOCTYPE html>
<html>
  <head>
    <title>Green'in Teorisi, Düzlem Kesişmeleri, Eğriler
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
   <script type="text/javascript"
       src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
   </script>
   <script async="async" data-cfasync="false" src="//pl22489825.profitablegatecpm.com/d84f574876e65b2d8f0c7bae784c22b3/invoke.js"></script>

<p><link rel="stylesheet" type="text/css" media="screen" href="https://burakbayramli.github.io/css/style.css">
  </head>
    <body>
      <div id="header_wrap" class="outer">
        <header class="inner">
          <h1 id="project_title">
            <a href="https://burakbayramli.github.io" style="text-decoration:none; color:inherit;">dersblog</a>
          </h1>
          <h2 id="project_tagline"></h2>        <br />
        </header>
      </div>
      <div id="main_content_wrap" class="outer">      <br />
        <section id="main_content" class="inner">
        <h1>Green'in Teorisi, Düzlem Kesişmeleri, Eğriler
</h1></p>
<p>Çizgi Parçası ve bir 3D Üçgenin Kesişmesi</p>
<p>Bir çizgi parçasını temsil etmek için $s$ başlangıç noktasından $t$ varış
noktasına giden bir ışın (ray) hayal edelim, bu çizgi parçası üzerindeki
herhangi bir $x$ noktası [9, sf. 84]</p>
<p>$$
x = s + \lambda (t-s) \quad 0 \le \lambda \le 1
\qquad (1)
$$</p>
<p>ile temsil edilebilir, ki $x,s,t$ üç boyutlu vektörler olmak üzere, yani
$\vec{x},\vec{s},\vec{t}$.</p>
<p>Bir üçgenin tüm yüzeyini, yani üç noktası arasında kalan tüm alanı üç boyutta
temsil etmek gerekli, çünkü kesişim bu alanda bir yerde olacak, bunun için
ağırlık merkezli (barycentric) kordinat sistemi kullanabiliriz, üçgen içindeki
herhangi bir $x$ noktasını üç köşe noktasının farklı ağırlıklarla çarpılıp
toplanmış hali olarak görebiliriz, yani üç köşe $p_0,p_1,p_2$ için</p>
<p>$$
x = \mu_0 p_0 + \mu_1 p_1 + \mu_2 p_2,
\quad \mu_0 + \mu_1 + \mu_2 = 1, \mu_i \ge 0
$$</p>
<p>Formülden $\mu_0$'i atmak mümkün, onu diğerleri bazında gösterebiliriz,
$mu_0 = 1-\mu_1-\mu_2$, üstteki formülü tekrar düzenleyince,</p>
<p>$$
x = p_0 + \mu_1 (p_1 - p_0) + \mu_2 (p_2 - p_0)
\qquad (2)
$$</p>
<p>Böylece, (1),(2) ile, bizi çizgi parçası biri üçgen sathi ile ilgili iki
formül elde ettik. Kesişme noktası bu iki formülün $x$'leri aynı olduğu
yerdedir değil mi? $r=t-s$, $d_1=p_1-p_0$, $d_2 = p_2-p_0$ diyelim,
ve (1) ile (2)'yi $x$ üzerinden birbirine eşitleyelim,</p>
<p>$$
s + r\lambda = p_0 + \mu_1 d_1 + \mu_2 d_2
$$</p>
<p>formülü bulunabilir. Üstteki formülü matris notasyonunda tekrar düzenlemek
mümkündür,</p>
<p>$$
[\begin{array}{ccc} -r &amp; d_1 &amp; d_2 \end{array}]
\left[\begin{array}{ccc}
\lambda \\ \mu_1 \\ \mu_2 
\end{array}\right] = s - p_0
$$</p>
<p>Dikkat, $-r,d_1,d_2$ vektör oluşturmuş gibi gözüküyor ama böyle değil, bu
değişkenlerin her birinin kendisi vektör, onların değerlerinin asağı doğru
açılmış hali solda bir matris yaratıyor, o matrise $A$ diyelim, yani</p>
<p>$$
\left[\begin{array}{ccc}
\uparrow &amp; \uparrow &amp; \uparrow  \\
 -r &amp; d_1 &amp; d_2 \\
\downarrow &amp; \downarrow &amp; \downarrow 
\end{array}\right]
\left[\begin{array}{ccc}
\lambda \\ \mu_1 \\ \mu_2 
\end{array}\right] = s - p_0
$$</p>
<p>$$
A
\left[\begin{array}{ccc}
\lambda \\ \mu_1 \\ \mu_2 
\end{array}\right] = s - p_0
$$</p>
<p>$$
\left[\begin{array}{ccc}
\lambda \\ \mu_1 \\ \mu_2 
\end{array}\right] = A^{-1} (s - p_0)
$$</p>
<p>Yani $A$'nin tersini alıp eşitliğin sağ tarafını soldan çarpınca kesişme
noktasındaki $\lambda,\mu_1,\mu_2$ elde ediliyor. Bu değerleri kullanarak
kesişme noktasının kordinat yerini artık bulabiliriz, mesela çizgi parçası
formülünden yola çıkarsak $x = s + \lambda (t-s)$ formülüne bulunan $\lambda$
değerini sokunca, ki $t,s$ zaten biliniyor, kesişim noktası $x$ elde edilebilir.</p>
<p>Önemli bir nokta eğer kesişme <em>yoksa</em> üstteki çözümün ne vereceği. Bu
durumda $A$ matrisi özgün olur, yani tersi alınamaz. Bu durumda eğer bir lineer
cebir paketi kullanıyorsak bir hata mesajı alırız. Tabii özgünlüğün basit bir
kontrol yöntemi var, $A$'nin determinantini alırız, eğer sıfır ise matris
özgündür, çözüm / kesişme yoktur.</p>
<p>Örnek</p>
<p>Gerekli grafik rutinleri,</p>
<pre><code class="python">import mpl_toolkits.mplot3d as a3
import matplotlib.colors as colors
import pylab as pl
import numpy as np

def plot_tri3d(corners, axx):
   tri = a3.art3d.Poly3DCollection([corners])   
   tri.set_edgecolor('k')
   tri.set_color('red')
   tri.set_alpha(0.2)
   axx.add_collection3d(tri)
   axx.view_init(elev=20, azim=250)
   axx.set_xlim(-5,8)
   axx.set_ylim(-5,8)
   axx.set_zlim(-5,8)

def plot_line(p0,p1,axx):
   axx.plot([p0[0],p1[0]],[p0[1],p1[1]],[p0[2],p1[2]])

</code></pre>

<p>Bir çizgi parçası ve bir üçgen yaratalım,</p>
<pre><code class="python">vtx1 = np.array([[0,5,0],[8,4,0 ],[0,0,0]])

ax = a3.Axes3D(pl.figure())
plot_tri3d(vtx1,ax)
s = np.array([2,3,-2])
t = np.array([5,3,2])
plot_line(s,t,ax)
plt.savefig('calc_multi_75_app_14.jpg')
</code></pre>

<p><img alt="" src="calc_multi_75_app_14.jpg" /></p>
<p>Kesişmeyi bulmak için,</p>
<pre><code class="python">import numpy.linalg as lin
r = t - s
d1 = vtx1[1,:]-vtx1[0,:]
d2 = vtx1[2,:]-vtx1[0,:]
A = np.zeros((3,3))
A[:,0] = -r
A[:,1] = d1
A[:,2] = d2
print ('A',A)
print (u'A determinantı', lin.det(A))
res = np.dot(lin.inv(A),(s-vtx1[0,:]))
lam,mu1,mu2 = list(res)
</code></pre>

<pre><code>A [[-3.  8.  0.]
 [ 0. -1. -5.]
 [-4.  0.  0.]]
A determinantı 159.99999999999994
</code></pre>

<pre><code class="python">print (mu1,mu2,mu1+mu2)
xintersect = s + lam * (t-s)
print (u'kesişme noktası',xintersect)
</code></pre>

<pre><code>0.4375 0.3125 0.75
kesişme noktası [3.5 3.  0. ]
</code></pre>

<pre><code class="python">ax = a3.Axes3D(pl.figure())
plot_tri3d(vtx1,ax)
plot_line(s,t,ax)
ax.plot(xintersect[0],xintersect[1],xintersect[2],'rd')
plt.savefig('calc_multi_75_app_15.jpg')
</code></pre>

<p><img alt="" src="calc_multi_75_app_15.jpg" /></p>
<p>Örnek</p>
<p>Kesişmenin olmadığı bir örneğe bakalım,</p>
<pre><code class="python">ax = a3.Axes3D(pl.figure())
plot_tri3d(vtx1,ax)
s = np.array([-3,4,3])
t = np.array([0,0,3])
r = t - s
A = np.zeros((3,3))
A[:,0] = -r
A[:,1] = d1
A[:,2] = d2
print ('A',A)
print ('A determinant', lin.det(A))
plot_line(s,t,ax)
plt.savefig('calc_multi_75_app_16.jpg')
</code></pre>

<pre><code>A [[-3.  8.  0.]
 [ 4. -1. -5.]
 [ 0.  0.  0.]]
A determinant 0.0
</code></pre>

<p><img alt="" src="calc_multi_75_app_16.jpg" /></p>
<p>İki 3D Üçgenin Kesişme Kontrolü</p>
<pre><code class="python">vtx1 = np.array([[0,5,0],[8,0,0 ],[0,0,0]])

vtx2 = np.array([[6,8,3],[6,8,-2],[6,-4,-2]])

ax = a3.Axes3D(pl.figure())
plot_tri3d(vtx1,ax)
plot_tri3d(vtx2,ax)
plt.savefig('calc_multi_75_app_12.jpg')
</code></pre>

<p><img alt="" src="calc_multi_75_app_12.jpg" /></p>
<pre><code class="python">ax = a3.Axes3D(pl.figure())
vtx3 = vtx2 + 3
plot_tri3d(vtx1,ax)
plot_tri3d(vtx3,ax)
plt.savefig('calc_multi_75_app_13.jpg')
</code></pre>

<p><img alt="" src="calc_multi_75_app_13.jpg" /></p>
<pre><code class="python"># ikinci ucgen ile duzlem yarat
n2 = np.cross( vtx2[1,:]-vtx2[0,:], vtx2[2,:]-vtx2[0,:]  )
d2 = -np.dot(n2,vtx2[0,:])
print (n2,d2)
</code></pre>

<pre><code>[-60   0   0] 360
</code></pre>

<pre><code class="python">for i in range(3):
    sdi = np.dot(n2,vtx1[i,:])+d2
    print ('%d. noktaya uzaklik = %d' % (i,sdi))
</code></pre>

<pre><code>0. noktaya uzaklik = 360
1. noktaya uzaklik = -120
2. noktaya uzaklik = 360
</code></pre>

<pre><code class="python"># ucuncu ucgen ile duzlem yarat
n3 = np.cross( vtx3[1,:]-vtx3[0,:], vtx3[2,:]-vtx3[0,:]  )
d3 = -np.dot(n3,vtx3[0,:])
print (n3,d3)
</code></pre>

<pre><code>[-60   0   0] 540
</code></pre>

<pre><code class="python">for i in range(3):
    sdi = np.dot(n2,vtx1[i,:])+d3
    print ('%d. noktaya uzaklik = %d' % (i,sdi))
</code></pre>

<pre><code>0. noktaya uzaklik = 540
1. noktaya uzaklik = 60
2. noktaya uzaklik = 540
</code></pre>

<p>[devam edecek]</p>
<p>Çizgi Düzlem Kesişmesini Vektörler ile Hesaplamak</p>
<p>Üstteki yöntem cebirsel manipülasyon gerektiriyor, fakat sayısal hesap için
sembolik cebir işlemlerine girmeden vektör matematiği ile direk bir sonuç
bulamaz mıyız? [3,4]'ü temel alalım: alttaki durumu düşünelim, </p>
<p><img alt="" src="calc_multi_75_app_06.jpg" /></p>
<p>Grafiğe göre $P(s)$ $P_1$ ve $P_0$ arasındaki birim vektörün $s$ kadar
uzatılmış hali olsun, o aralığı $u$ kabul edersek $P(s)-V_0 = w + su$
olur. Düzlem ile kesişmenin olduğu noktayı $P(s_I)$ diye tanımlayalım,
aradığımız nokta burası. O noktada $n$ ile $P(s_I)$ dikgen olacaktır, yani
$P(s) - V_0 = w + su$ vektörü $n$'e dikgen olacaktır, ki $w=P_0-V_0$. Bu
durumda $n \cdot (w+su) = 0$ olur. Bunu kullanarak,</p>
<p>$$ s_I = \frac{-n \cdot w}{n \cdot u} = 
\frac{n \cdot (V_0 - P_0)}{n \cdot (P_1-P_0)} = 
\frac{-(ax_0 + by_0 + cz_0 + d)}{n \cdot u}
$$</p>
<pre><code class="python">n = np.array([1., 1., 1.])
V0 = np.array([1., 1., -5.])
P0 = np.array([-5., 1., -1.])
P1 = np.array([1., 2., 3.])

w = P0 - V0;
u = P1-P0;
N = -np.dot(n,w);
D = np.dot(n,u)
sI = N / D
I = P0+ sI*u
print I
</code></pre>

<pre><code>[-3.90909091  1.18181818 -0.27272727]
</code></pre>

<p>Grafiklersek</p>
<pre><code class="python">import sys; sys.path.append('../../vision/vision_02')
import plot3d

f = plt.figure()
ax = f.gca(projection='3d')
w = 10
ax.set_xlim(-w,w);ax.set_ylim(-w,w);ax.set_zlim(-w,w)
ax.set_xlabel(&quot;X&quot;)
ax.set_ylabel(&quot;Y&quot;)
ax.set_zlabel(&quot;Z&quot;)
v = P1-P0
ax.quiver(P0[0], P0[1], P0[2], v[0], v[1], v[2], color='red')
ax.scatter(V0[0], V0[1], V0[2], color='black')
ax.scatter(V0[0]+n[0], V0[1]+n[1], V0[2]+n[2], color='black')
ax.scatter(I[0], I[1], I[2], color='black')
ax.quiver(V0[0], V0[1], V0[2], n[0], n[1], n[2], color='blue')
plot3d.plot_plane(ax, list(V0), list(n), color='y')
plt.savefig('calc_multi_75_app_07.jpg')
</code></pre>

<p><img alt="" src="calc_multi_75_app_07.jpg" /></p>
<p>Green'in Teorisi, Uzaklaşım, Stokes, Yol ve Çizgi Entegralleri</p>
<p>Yüzeyler (Surfaces)</p>
<p>Üç boyut içindeki iki boyut yüzeyler parametrize edilerek gösterilir,
tek boyutlu eğri bir parametre $t$ ile parametrize ediliyordu, alan için
iki değişken $u,v$ gerekir. Notasyonel olarak $r$'nin taradığı bir yüzey</p>
<p>$$
r(u,v) = &lt; x(u,v), y(u,v), z(u,v) &gt;
$$</p>
<p>Mesela $r(u,v) = &lt; u, u^2, v &gt;$ bir yüzey olabilir.</p>
<p>Yüzey alan hesabı için tüm yüzeyi kenarları $\Delta u$, $\Delta v$ olan hücreler
yaratabiliriz. Her noktada iki tane teğet vektör bulunabilir, bunlar $t_u$ ve
$t_v$ olsun,</p>
<p>$$
t_u = &lt; \frac{\partial x}{\partial u},
        \frac{\partial y}{\partial u},
        \frac{\partial z}{\partial u} &gt;, \quad
t_v = &lt; \frac{\partial x}{\partial v},
        \frac{\partial y}{\partial v},
        \frac{\partial z}{\partial v} &gt;      <br />
$$</p>
<p>Yaklaşık olarak her hücrenin alanı $\Delta S_{ij}$ her hücredeki $t_u$ ve $t_v$
(ya da yeni notasyonla onlara $t_u^{ij}$ ve $t_v^{ij}$ diyelim) yönündeki
$\Delta u$ ve $\Delta v$'nin oluşturduğu paralelogram alanıdır, bu paralelogram
bildiğimiz gibi iki vektörün çapraz çarpımından gelen üçüncü vektörün
büyüklüğüdür, o zaman </p>
<p>$$
\Delta S_{ij} \approx || \Delta u t_u^{ij} \times \Delta v t_v^{ij} ||
$$</p>
<p>$$
= ||  t_u^{ij} \times t_v^{ij} || \Delta u \Delta v
$$</p>
<p><img alt="" src="calc_multi_75_app_01.jpg" /></p>
<p><img alt="" src="calc_multi_75_app_02.jpg" /></p>
<p>Tüm ufak hücre alanlarını toplarız, ve hücre sayısı sonsuza yaklaşırken toplam
alan limitine bakabiliriz,</p>
<p>$$
\lim_{m,n \to \infty} \sum_{i=1}^{m} \sum_{j=1}^{n} || t_u^{ij} \times t_v^{ij} || \Delta u \Delta v
$$</p>
<p>Bu limit yüzey alan çift entegral hesabına yaklaşır / onu tanımlar, [2, sf. 769],</p>
<p>$$
= \iint_D || t_u \times t_v || \mathrm{d} u \mathrm{d} v = \iint_D || t_u \times t_v || \mathrm{d} A
$$</p>
<p>Yüzey Entegrali (Surface Integral)</p>
<p>Yukarıda gördüklerimiz parametrize edilmiş yüzeyin alanını hesaplamak içindir.
Yüzey entegrali bir yüzey <em>üzerinden</em> alınan entegrallere verilen isimdir,
mesela tek sayı / skalar değerli bir fonksiyon $f$'nin pürüzsüz bir yüzey $S$
üzerinden alınan yüzey entegrali, o fonksiyonun her noktadaki alan büyüklüğü ile
çarpılıp sonuçların toplanmasıdır, cebirsel olarak yine $t_u,t_v$ kavramlarını
kullanırsak,</p>
<p>$$
\iint_S f(x,y,z) \mathrm{d} S 
= \lim_{m,n \to \infty} \sum_{i=1}^{m} \sum_{j=1}^{n} f(P_{ij}) || t_u^{ij} \times t_v^{ij} || \Delta u \Delta v
$$</p>
<p>$$
= \lim_{m,n \to \infty} \sum_{i=1}^{m} \sum_{j=1}^{n} f(P_{ij}) \Delta S_{ij} 
$$</p>
<p>O zaman yüzey entegralleri alttaki şekilde hesaplanabilir,</p>
<p>$$
\iint_S f(x,y,z) \mathrm{d} S =
\iint_D f(r(u,v)) || t_u \times t_v || \mathrm{d} A
$$</p>
<p>Çizgi entegrali (line integrals) daha düşük boyuttaki benzer bir kavram idi.</p>
<p>Vektör Alanları Üzerinden Yüzey Entegrali</p>
<p>Skalar fonksiyona benzer şekilde bir vektör alanı $F$ ve yüzey $S$ üzerinden de
entegral hesaplanabilir. Yine bir ufak çarpımlar toplamından bahsediyoruz, bu
tür bir hesap pek çok uygulama için faydalı olabilir. Mesela bir su akışı
içindeki geçirgen bir yüzeyi düşünürsek, kütle akışını (mass flux) nasıl
hesaplarız? </p>
<p><img alt="" src="calc_multi_75_app_04.jpg" /></p>
<p>Her noktada yüzey $S$'ye dik olan alan $N$ olsun, her noktadaki akış hızı $v$
diyelim, o zaman bir noktadaki birim zaman ve birim alandaki kütle akışı $\rho v
\cdot N$. Ölçüm birimlerini kontrol edelim, hız $m/s$, yoğunluk $\rho$ 
$g/m^3$, çarparsak $g/s \cdot m^2$ elde ederiz, yani birim alan ve zamandaki
kütle akışı.</p>
<p>Şimdi $\rho v \cdot N$ değerini $\Delta S_{ij}$ ile çarparsak $S$ üzerindeki
hayali ufak hücreden birim zamanda akan kütleyi buluruz, tüm bu akışları
toplarız,</p>
<p>$$
\sum_{i=1}^{m} \sum_{j=1}^{n} (\rho v \cdot N) \Delta S_{ij}
$$</p>
<p>Tüm akışı elde etmiş oluruz. Izgara hücreleri $S_{ij}$ ufaldıkça üstteki toplam
gerçek kütle akışına yaklaşır, yani</p>
<p>$$
\iint_S \rho v \cdot N \mathrm{d} S = \lim_{m,n \to \infty}
\sum_{i=1}^{m} \sum_{j=1}^{n} (\rho v \cdot N) \Delta S_{ij}
$$</p>
<p>Devam edelim $\rho v$ yerine herhangi bir vektör alanı $F$ kullanalım, o zaman
şu genel tanımı artık yapabiliriz, $F$'nin $S$ yüzeyi üzerinden entegrali</p>
<p>$$
\iint_S \vec{F} \cdot \mathrm{d} \vec{S} = \iint_S \vec{F} \cdot \vec{N} \mathrm{d} S
$$</p>
<p>olarak gösterilir.</p>
<p><img alt="" src="calc_multi_75_app_05.jpg" /></p>
<p>Dikkat her yerde vektör notasyonu kullanmıyoruz, olmadığı yerde formül
çerçevesine göre anlaşılabilir.</p>
<p>$N$ yüzey normalı, öne dik olan birim vektör, hesabı için önceden gördüğümüz
$t_u,t_v$ vektörlerini kullanabiliriz,</p>
<p>$$
N = \frac{t_u \times t_v}{ || t_u \times t_v || }
$$</p>
<p>Üstteki ifadeyi yüzey entegralinde kullanırsak [2, sf. 778],</p>
<p>$$
\iint_S \vec{F} \cdot \vec{N} \mathrm{d} S =
\iint_S \vec{F} \cdot \frac{t_u \times t_v}{ || t_u \times t_v || } \mathrm{d} S
$$</p>
<p>Daha önce gördük</p>
<p>$$
\mathrm{d} S = || t_u \times t_v || \mathrm{d} u \mathrm{d} v = || t_u \times t_v || \mathrm{d} A
$$</p>
<p>İki üste geçirince</p>
<p>$$
= \iint_D \vec{F}(r(u,v)) \cdot \frac{t_u \times t_v}{ || t_u \times t_v || }
|| t_u \times t_v || \mathrm{d} A
$$</p>
<p>Basitleştirme sonrası,</p>
<p>$$
= \iint_D \vec{F}(r(u,v)) \cdot (t_u \times t_v) || t_u \times t_v || \mathrm{d} A
$$</p>
<p>Soru</p>
<p>$F = &lt; -y, x, 0 &gt;$ olarak veriliyor, $S$ yüzeyi $r(u,v) = &lt; u, v^2 - u, u+v &gt;$.</p>
<p>$\iint_S F \cdot N \mathrm{d} S$ yüzey entegralini hesaplayın.</p>
<p>Cevap</p>
<p>Teğet vektörler $t_u = &lt; 1, -1, 1 &gt;$, ve $t_v = &lt; 0, 2v, 1 &gt;$.</p>
<p>$t_u \times t_v$ çapraz çarpımı</p>
<pre><code class="python">import sympy

u,v = sympy.symbols('u v')
t_u = sympy.Matrix([[1,-1,1]])
t_v = sympy.Matrix([[0,2*v,1]])
print (t_u.cross(t_v))
</code></pre>

<pre><code>Matrix([[-2*v - 1, -1, 2*v]])
</code></pre>

<p>Yüzey entegral hesabı şöyle hesaplanabilir,</p>
<p>$$
\int _{0}^{4} \int _{0}^{3} F(r(u,v)) \cdot (t_u \times t_v) \mathrm{d} u \mathrm{d} v
$$</p>
<p>Verili $F = &lt; -y, x, 0 &gt;$, ve yüzey $r(u,v) = &lt; u, v^2 - u, u+v &gt;$ demiştik,
o zaman </p>
<p>$$
F(r(u,v)) = &lt; u-v^2, u, 0 &gt; 
$$</p>
<p>olur. Tüm entegral</p>
<p>$$
= \int _{0}^{4} \int _{0}^{3} &lt; u-v^2, u, 0 &gt;  \cdot &lt; -1-2v, -1, 2v &gt;
\mathrm{d} u \mathrm{d} v
$$</p>
<p>$$
= \int_{0}^{4} \int_{0}^{3} (2v^3 + v^2 -2uv -2u )
\mathrm{d} u \mathrm{d} v
$$</p>
<p>$$
= \int_{0}^{4} [ 2v^3u + v^2u - vu^2 - u^2 ]_{0}^{3} \mathrm{d} v
$$</p>
<p>$$
= \int_{0}^{4} (6v^3 + 3v^2 - 9v -9 ) \mathrm{d} v
$$</p>
<p>$$
= \left[ \frac{3v^4}{2} + v^3 - \frac{9v^2}{2} - 9v \right]_{0}^{4}
$$</p>
<p>$$
= 340
$$</p>
<pre><code class="python">from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
import numpy as np
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
u = np.linspace(0, 3, 100)
v = np.linspace(0, 4, 100)
u,v = np.meshgrid(u,v)

x = u; y = v**2 - u; z = u + v

ax.plot_surface(x, y, z, rstride=4, cstride=4, cmap = cm.copper)
x = np.linspace(0, 3, 5)
y = np.linspace(0, 10, 5)
z = np.linspace(0, 6, 5)

fu = -y; fv = x; fw = z*0

xx,yy,zz = np.meshgrid(x,y,z)
ax.quiver(xx, yy, zz, fu, fv, fw, length=0.2, color = 'red')
ax.view_init(elev=18, azim=-46)
plt.savefig('calc_multi_75_app_03.jpg',quality=30)
</code></pre>

<p><img alt="" src="calc_multi_75_app_03.jpg" /></p>
<p>Çizgi Düzlem Kesişmesi</p>
<p>Elimizde $P = 2x + y - 4z = 4$ düzlemi var. Bu düzlemin </p>
<p>$$ x = t \quad y = 2 + 3t \quad z = t$$</p>
<p>çizgisi ile kesiştiği yer neresidir? </p>
<p>Cevap kolay; çizgi denkleminde $t$ bazlı tanımlı $x,y,z$ değerleri $P$'ye
sokarsak, tek bilinmeyeni $t$ olan bir denklem çıkar, </p>
<p>$$ 2(t) + (2+3t)-4(t) = 4 \Rightarrow t = 2$$</p>
<p>İki Nokta Arasında Parametrize Edilmiş Eğri</p>
<p>Diyelim ki $(1,1)$ ve $(4,4)$ noktalarından geçen ve dışarıdan tanımlı
parametrelerle yeterince eğilip, bükülebilecek bir eğri tanımlamamız
lazım. Polinomlar üzerinden tanımlanan bir eğri ile bunu başarabiliriz, </p>
<p>$$
x(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3
$$</p>
<p>$$
y(t) = b_0 + b_1 t + b_2 t^2 + b_3 t^3
$$</p>
<p>Bu şekilde bir eğri yeterince eğilip bükülebilir, ve istenen şekle
sokulabilir. Fakat baş ve sonun verili noktalardan geçmesini nasıl garanti
ederiz? Bunun için bu noktaları üstteki denkleme sokalim, ve $0 \le t \le
1$ olacak sekilde kısıtlama yapalim, $t=0$'da</p>
<p>$$
1 = a_0 + a_1 (0) + a_2 (0)^2 + a_3 (0)^3
$$</p>
<p>$$
1 = b_0 + b_1 (0) + b_2 (0)^2 + b_3 (0)^3
$$</p>
<p>Yani  $a_0=1$ ve $b_0=1$. Peki $t=1$ icin?</p>
<p>$$
4 = 1 + a_1 (1) + a_2 (1)^2 + a_3 (1)^3 
$$</p>
<p>$$
4 = 1 + b_1 (1) + b_2 (1)^2 + b_3 (1)^3 
$$</p>
<p>$$
3 = a_1 + a_2 + a_3, \quad 3 = b_1 + b_2 + b_3
$$</p>
<p>Demek ki üstteki iki formüle mutabık kaldığımız sürece
$a_1,a_2,a_3,b_1,b_2,b_3$ ie istediğimiz şekilde oynayarak istediğimiz
eğriyi ortaya çıkartabiliriz. </p>
<pre><code class="python">t = np.linspace(0,1.0,100)

a1,a2 = -1.1, 1.9
b1,b2 = 1.1, 1.4

sx,sy=(1.0,1.0)
ex,ey=(4.0,4.0)

a3 = ex - sx - (a1+a2)
b3 = ey - sy - (b1+b2)

x = 1.0 + a1*t + a2*t**2 + a3*t**3
y = 1.0 + b1*t + b2*t**2 + b3*t**3

plt.xlim(0,5.0)
plt.ylim(0,5.0)
plt.plot(x,y)
plt.savefig('calc_multi_75_app_08.jpg')
</code></pre>

<p><img alt="" src="calc_multi_75_app_08.jpg" /></p>
<p>Max ve Sigmoid Bazlı Yaklaşım</p>
<p>Daha önce [6]'da görülen spline tekniğinin parametrik hali de
olabilir. Mesela </p>
<pre><code class="python">a1,b1,c1,d1 = (1, -1.4, 2, 2.5)
a2,b2,c2,d2 = (1, 1.4, 1, 2.5)
def f(t):
    x = ax + \
        bx*np.max([0,t-2]) + \
        cx*np.max([0,t-3]) + \
        dx*np.max([0,t-4])

    y = ay + \
        by*np.max([0,t-2]) + \
        cy*np.max([0,t-3]) + \
        dy*np.max([0,t-4])
    return x,y     

tmp = np.linspace(0,5,100)
res = np.array([f(tt) for tt in tmp])
plt.plot(res[:,0],res[:,1])
plt.savefig('calc_multi_75_app_09.jpg')
</code></pre>

<p><img alt="" src="calc_multi_75_app_09.jpg" /></p>
<p>Başlangıcı $a_x,a_y$ olan kesik bir eğriyi görüyoruz. Bu tür eğrileri aynen
[6]'da olduğu gibi sigmoid bazlı yapabiliriz,</p>
<pre><code class="python">rho = 7.0
def sig(x,a):
   return (x-a)*1/(1+np.exp(-rho*(x-a)))

def maxk(x,a):
   return np.max([0,x-a])

ax,bx,cx,dx,ex = (1, 2.4, 1, -3.5, -2.1)
ay,by,cy,dy,ey = (1, 0.4, -0.1, 0.5, -3)
def f(t):
    x = ax + \
        bx*maxk(t,2) + \
        cx*maxk(t,3) + \
        dx*maxk(t,3.5) + \
        ex*maxk(t,4.0)

    y = ay + \
        by*maxk(t,2) + \
        cy*maxk(t,3) + \
        dy*maxk(t,3.5) + \
        ey*maxk(t,4.0)
    return x,y     

def g(t):
    x = ax + \
        bx*sig(t,2) + \
        cx*sig(t,3) + \
        dx*sig(t,3.5) + \
        ex*sig(t,4.0)

    y = ay + \
        by*sig(t,2) + \
        cy*sig(t,3) + \
        dy*sig(t,3.5) + \
        ey*sig(t,4.0)
    return x,y     

tmp = np.linspace(0,5,100)
</code></pre>

<pre><code class="python">res = np.array([f(tt) for tt in tmp])
plt.plot(res[:,0],res[:,1])
plt.savefig('calc_multi_75_app_10.jpg')
</code></pre>

<pre><code class="python">res = np.array([g(tt) for tt in tmp])
plt.plot(res[:,0],res[:,1])
plt.savefig('calc_multi_75_app_11.jpg')
</code></pre>

<p><img alt="" src="calc_multi_75_app_10.jpg" />
<img alt="" src="calc_multi_75_app_11.jpg" /></p>
<p>Herhangi bir şekli katsayılarla yaratmak mümkün. </p>
<p>Bitiş noktalasını nasıl ayarlarız? Burada yine polinom örnekteki gibi
cebirsel bir yöntem seçebilirdik, fakat çoğunlukla başlangıç ve bitiş
arasındaki eğriler bir optimizasyon bağlamında kullanılır. Bu durumda
bitiş noktaları ile katsayılar arasında bir optimizasyon kısıtlaması
yaratmak ve bitiş noktalarını böyle ayarlamak daha iyidir. </p>
<p>Çünkü biliyoruz parametrize ortamda mesela önceki örnekte $0 \ge t \ge
5$. O zaman egrinin bitisinde $t=5$ olacağını biliyoruz. Bu durumda mesela </p>
<p>$$
    x = a_x + \
        b_x \sigma(t,2) + \
        c_x \sigma(t,3) + \
        d_x \sigma(t,3.5) +
        e_x \sigma(t,4.0)
$$</p>
<p>ifadesine $t$ tüm ilmik noktalarının ötesinde olduğu için artık tüm
$\sigma$ ifadeleri 1 veriyor. Eğer 1 veriyorsa, yani tüm sigmoid'ler aktif
ise, eğri bitişinde bilinen $t$ üzerinden elimizdeki $x$ 
$x = a_x + b_x(5-2) + c_x(5-3) + d_x(5-3.5) + e_x(5-4.0)$
olmalı. Optimizasyonda bu eşitliğin belli bir değer (istediğimiz bitiş
noktası kordinatı) olmasını şart tutarak amacımız erişebiliriz.</p>
<p>Kaynaklar</p>
<p>[1] Marsden, <em>Vector Calculus</em></p>
<p>[2] Strang, <em>Calculus Volume 3, OpenStaxa</em></p>
<p>[3] Sunday, <em>Intersection of Lines and Planes</em>, 
<a href="http://geomalgorithms.com/a05-_intersect-1.html">http://geomalgorithms.com/a05-_intersect-1.html</a></p>
<p>[4] Khaled, <em>Straight Line and Plane Intersection Matlab Code</em>, 
<a href="https://uk.mathworks.com/matlabcentral/fileexchange/17751-straight-line-and-plane-intersection">https://uk.mathworks.com/matlabcentral/fileexchange/17751-straight-line-and-plane-intersection</a></p>
<p>[5] <em>Distance between Point and Line</em>, 
<a href="https://brilliant.org/wiki/distance-between-point-and-line/">https://brilliant.org/wiki/distance-between-point-and-line/</a></p>
<p>[6] Bayramlı, <em>Hesapsal Bilim, Spline Eğrileri ve Baz Fonksiyonlar</em></p>
<p>[7] Rotenberg, <em>CSE169: Computer Animation</em>,
    <a href="https://cseweb.ucsd.edu/classes/wi19/cse169-a/slides/">https://cseweb.ucsd.edu/classes/wi19/cse169-a/slides/</a></p>
<p>[8] Bayramlı, <em>Cok Degiskenli Calculus - Ders 4</em></p>
<p>[9] Bergen, <em>Collision Detection</em></p>
          <div id="container-d84f574876e65b2d8f0c7bae784c22b3"></div>

          <br/><a href="../index.html">Yukarı</a>
        </section>          
      </div>
    </body>
</html>
