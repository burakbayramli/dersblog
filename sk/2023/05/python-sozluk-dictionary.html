
<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
   <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
   </script>
   <link rel="stylesheet" type="text/css" media="screen" href="https://burakbayramli.github.io/css/style.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1548953794786292"
          crossorigin="anonymous"></script>  
  </head>
    <body>
      <div id="header_wrap" class="outer">
        <header class="inner">
          <h1 id="project_title">
            <a href="https://burakbayramli.github.io" style="text-decoration:none; color:inherit;">dersblog</a>
          </h1>
          <h2 id="project_tagline"></h2>          
        </header>
      </div>
      <div id="main_content_wrap" class="outer">        
        <section id="main_content" class="inner">
        <h1></h1>
<h1>Python Sözlük (Dictionary) Veri Yapısı</h1>

<p>Python sözlük yapısı hafızada anahtar bazlı veriye direk erişim (dizi
/ vektör / sayı indisli liste erişimi kadar hızlı) sağlar.  Basit
anahtar - değer ikilisini depolayabiliriz, fakat değer olarak
depolanan şey herhangi bir obje olabilir. Bu özellik sözlüklere geniş
kullanım alanı sağlar.</p>

<p>En basit kullanım,</p>

<div class="codehilite">
<pre><span></span><code><span class="c1"># bos sozluk yarat</span>
<span class="n">dict1</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># depola</span>
<span class="n">dict1</span><span class="p">[</span><span class="s1">&#39;anahtar1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;deger1&quot;</span>

<span class="c1"># erisim yap</span>
<span class="n">dict1</span><span class="p">[</span><span class="s1">&#39;anahtar1&#39;</span><span class="p">]</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: &#39;deger1&#39;
</code></pre>
</div>

<p>Herhangi bir obje depolanır demiştik,</p>

<div class="codehilite">
<pre><span></span><code><span class="n">dict1</span><span class="p">[</span><span class="s1">&#39;anahtar2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">dict1</span><span class="p">[</span><span class="s1">&#39;anahtar2&#39;</span><span class="p">]</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: array([1, 2, 3])
</code></pre>
</div>

<p>Tüm anahtarları göstermek için</p>

<div class="codehilite">
<pre><span></span><code><span class="n">dict1</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: dict_keys([&#39;anahtar1&#39;, &#39;anahtar2&#39;])
</code></pre>
</div>

<p>Bu liste gezilebilir, ve bu sırada anahtar kullanılıp değer ekrana basılabilir,</p>

<div class="codehilite">
<pre><span></span><code><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dict1</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="n">dict1</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>deger1
[1 2 3]
</code></pre>
</div>

<p>Eğer olmayan değere erişirsek hata gelir,</p>

<div class="codehilite">
<pre><span></span><code><span class="n">dict1</span><span class="p">[</span><span class="s1">&#39;olmayan anahtar&#39;</span><span class="p">]</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>KeyErrorTraceback (most recent call last)
&lt;ipython-input-1-90fef2a85d10&gt; in &lt;module&gt;
      1 plt.figure();
      2 
----&gt; 3 dict1[&#39;olmayan anahtar&#39;]

KeyError: &#39;olmayan anahtar&#39;
</code></pre>
</div>

<p>Hata oluşturmadan eğer anahtar varsa değer yoksa <code>None</code> gelsin istersek <code>.get</code>
çağrısı var,</p>

<div class="codehilite">
<pre><span></span><code><span class="nb">print</span> <span class="p">(</span><span class="n">dict1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;olmayan anahtar&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>None
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code><span class="nb">print</span> <span class="p">(</span><span class="n">dict1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;anahtar1&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>deger1
</code></pre>
</div>

<p>Kavrama (comprehension) yani [1] tek satırda hem başka bir listeyi gezip aynı
anda başka bir liste / sözlük yaratma kabiliyeti sözlükler için de geçerli,</p>

<div class="codehilite">
<pre><span></span><code><span class="n">dict2</span> <span class="o">=</span> <span class="p">{</span> <span class="n">i</span><span class="p">:</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;ali&#39;</span><span class="p">,</span><span class="s1">&#39;veli&#39;</span><span class="p">,</span><span class="s1">&#39;ahmet&#39;</span><span class="p">])</span> <span class="p">}</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">dict2</span><span class="p">)</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>{0: &#39;ali&#39;, 1: &#39;veli&#39;, 2: &#39;ahmet&#39;}
</code></pre>
</div>

<p><code>i:x</code> ile anahtar/değer ikilisini başka bir listeyi gezerken tanımladık, ve
bu tanımlar toparlanıp bir yeni sözlük yaratımı için kullanıldı.</p>

<h3>Sözlük İç Yapısı</h3>

<p>Sözlüklerin iç kodlanması nasıl yapılmıştır acaba? Bundan da
bahsedelim, mülakat sorusu olabilir, zaten görünmese de bu tür
detayları bilmek faydalıdır. Bir sözlük paketini kodlamak için en baz
depolama veri yapısı olarak bir dizi (array) kullanabiliriz. Ama dizi
erişimi tam sayı bazlıdır, üstelik baştan kaç öğe olduğu bellidir,
anahtarı herhangi bir şey olabilecek sözlükleri bunun üstüne nasıl
monte edeceğiz?</p>

<p>Böleç (hash) kavramı burada yardıma yetişir. Harfler, alfanumerik
herhangi bir veriyi <code>hash</code> ile sayısal forma çevirebileceğimizi
biliyoruz,</p>

<div class="codehilite">
<pre><span></span><code><span class="nb">hash</span><span class="p">(</span><span class="s2">&quot;anahtar1&quot;</span><span class="p">)</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: 6762465535002540417
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code><span class="nb">hash</span><span class="p">(</span><span class="s2">&quot;anahtar2&quot;</span><span class="p">)</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: 1439585439643666777
</code></pre>
</div>

<p>Eğer sözlüğün deposu olarak 10 büyüklüğünde bir listeyi depolama için
kullanmak istiyorsak üstteki sayıların 10 üzerinden modülüs hesabını
yaparız,</p>

<div class="codehilite">
<pre><span></span><code><span class="nb">hash</span><span class="p">(</span><span class="s2">&quot;anahtar1&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: 7
</code></pre>
</div>

<p>İşte bu sayı dizide erişim için kullanılır.</p>

<p>Eğer dizi büyüklüğüne kıyasla çok fazla anahtar değeri var ise birden
fazla anahtar aynı dizi öğesine düşebilir, bu "çakışma (collision)"
durumu yaratır, bu durumda çakışma olan öğede bir liste yaratırız
(dizi içinde liste), ve erişim için arama önce anahtar bazlı direk
sonra liste bazlı teker teker gider.</p>

<h3>DiskDict</h3>

<p>Paketten çıkan hali ile Python sözlükleri hafıza bazlıdır. Fakat eğer anahtar
erişimi bizi bir disk deposuna götürsün istersek? Dikkat tüm işlemler hafızada
yapıldıktan sonra işi bitmiş sözlüğü diske yazmaktan bahsetmiyorum, her anahtar
erişimi, her depolama işleme tekil bazlı olarak diske gitmeli diyorum. </p>

<p>Bu ihtiyaç için bazı paketler var. Çoğu dış arayüzünü Python basit
sözlük ile benzer tutmuş böylece kodlayan yeni bir erişim stili
öğrenmeye mecbur değil, tüm bildik sözlük işlemleri geçerli.</p>

<p>Böyle bir paket <code>diskdict</code> [3]. Kurmak için kaynaklar kullanılırsa iyi
olur, önce alttakiler,</p>

<pre><code>sudo apt install python3-leveldb libleveldb-dev libffi-dev

pip install repoze.lru structlog pycparser
</code></pre>

<p>Ardından <code>setup.py</code> ile kurulum yapılır. Örnek,</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span> <span class="nn">diskdict</span> <span class="kn">import</span> <span class="n">DiskDict</span>

<span class="n">dict3</span> <span class="o">=</span> <span class="n">DiskDict</span><span class="p">(</span><span class="s1">&#39;/tmp/diskdict&#39;</span><span class="p">)</span>

<span class="n">dict3</span><span class="p">[</span><span class="s1">&#39;anahtar3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;deger3&#39;</span>
</code></pre>
</div>

<p>Bu işlemler sonrası <code>/tmp/diskdict</code> dizi altında bazı dosyaların
yaratılmış olduğunu göreceğiz. Sözlüğün disksel erişim işlemleri bu
dosyalar üzerinden yapılıyor, her erişim her depolama direk bu
dosyalara gidiyor (dosyaların ikisel formatı muhakkak hızlı erişim
için ayarlanmış halde).</p>

<p>Diğer Disk Bazlı Seçenekler</p>

<p>Eğer disk bazlı sözlük erişimini ayrı bir servise ayırıp ona REST APİ
bazlı erişim sağlasak bir nevi anahtar/değer veri tabanı (key-value
store) kavramına erişmiş olurduk. MongoDB gibi yazılımlar bir bakıma
bu servisi sağlıyorlar, daha yüksek ölçekte ek bazı servislerle beraber
fakat sonuçta yaptıkları disk bazlı bir sözlük servisi sağlamaktır.</p>

<p>Konu hakkında önceki bir yazı şurada [2].</p>

<h3>SQliteDict</h3>

<p>Ustteki <code>diskdict</code> kurulumu problem cikartirsa erisimi bir o kadar hizli
<code>sqlitedict</code> paketi olabilir. Bu paket ile</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span> <span class="nn">sqlitedict</span> <span class="kn">import</span> <span class="n">SqliteDict</span>

<span class="n">dd</span> <span class="o">=</span> <span class="n">SqliteDict</span><span class="p">(</span><span class="s1">&#39;walkdict.sqlite&#39;</span><span class="p">,</span> <span class="n">autocommit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre>
</div>

<p>ile bir disk bazlı, daha doğrusu sqlite taban bazlı bir sözlük
yaratıyoruz, ardından <code>dd['anahtar'] = 'değer'</code> ve <code>dd.commit()</code>
türündeki çağrılar diskteki sözlüğü güncelliyor. Erişim için
<code>SqliteDict</code> objesi aynı dosya ismi için tekrar oluşturuluyor ve
<code>dd[anahtar']</code> bize gerekli değeri geri veriyor. Arka planda paket
anahtarları muhakkak SQL tablosunda bir ana anahtar olarak kullammış,
erişimim hızlı indisler üzerinden ve her şeyi bellege taşımadan yapacaktır.</p>

<h3>Olağan Değerler, Sıralanma</h3>

<p>Olağan Değerler</p>

<p>Pek çok ihtiyaca yardım etmeye uğraşan ek sözlük tipleri de
vardır. Bunlardan biri olmayan bir değere erişildiğinde o anahtar için
olağan (default) bir değeri otomatik yaratan bir sözlük tipidir,
<code>defaultdict</code></p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">dict4</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">dict4</span><span class="p">[</span><span class="s1">&#39;anahtar4&#39;</span><span class="p">]</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: 0
</code></pre>
</div>

<p>Olağan değer sözlüklerinin en kullanışlı olduğu yer belli anahtar değerlerine
tekabül eden listelere öğe eklemek istediğimiz zamandır. Pek çok problemde
belli anahtarlara tekabül eden liste değerleri gezeriz, onları bir listeye
döngü içinde eklemek isteriz fakat her anahtar için "eğer bu anahtar varsa
listeye ekle, yoksa boş liste yarat, ondan sonra ekle" mantığı kod fazlalığı
oluşturabilir, <code>defaultdict(list)</code> kullanırsak her anahtarın olağan değeri
boş liste olacağı için bir anahtar var mı yok mu bakmadan direk o anahtarın
listesine ekleme yapabiliriz çünkü o anahtarın listesi yoksa nasıl olsa
yaratılacaktır. Örnek,</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">city_list</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;TX&#39;</span><span class="p">,</span><span class="s1">&#39;Austin&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;TX&#39;</span><span class="p">,</span><span class="s1">&#39;Houston&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;NY&#39;</span><span class="p">,</span><span class="s1">&#39;Albany&#39;</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;NY&#39;</span><span class="p">,</span> <span class="s1">&#39;Syracuse&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;NY&#39;</span><span class="p">,</span> <span class="s1">&#39;Buffalo&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;NY&#39;</span><span class="p">,</span> <span class="s1">&#39;Rochester&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;TX&#39;</span><span class="p">,</span>
<span class="s1">&#39;Dallas&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;CA&#39;</span><span class="p">,</span><span class="s1">&#39;Sacramento&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;CA&#39;</span><span class="p">,</span> <span class="s1">&#39;Palo Alto&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;GA&#39;</span><span class="p">,</span>
<span class="s1">&#39;Atlanta&#39;</span><span class="p">)]</span>

<span class="n">cities_by_state</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">city</span> <span class="ow">in</span> <span class="n">city_list</span><span class="p">:</span>
    <span class="n">cities_by_state</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">city</span><span class="p">)</span>

<span class="n">cities_by_state</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Out[1]: 
defaultdict(list,
            {&#39;TX&#39;: [&#39;Austin&#39;, &#39;Houston&#39;, &#39;Dallas&#39;],
             &#39;NY&#39;: [&#39;Albany&#39;, &#39;Syracuse&#39;, &#39;Buffalo&#39;, &#39;Rochester&#39;],
             &#39;CA&#39;: [&#39;Sacramento&#39;, &#39;Palo Alto&#39;],
             &#39;GA&#39;: [&#39;Atlanta&#39;]})
</code></pre>
</div>

<p>Gördüğümüz gibi <code>cities_by_state[state]</code> üzerinde direk <code>.append</code>
yapabildik çünkü listenin orada olacağını varsayabiliyoruz.</p>

<p>Eklenme Sırasını Hatırlayan Sözlük</p>

<p>Anahtarın eklenme sırasını hatırlayıp değerler istendiğinde ona göre
listeyi döndüren bir diğer sözlük tipi <code>collections.OrderedDict</code>.</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">import</span> <span class="nn">collections</span>

<span class="n">dict5</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
<span class="n">dict5</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">dict5</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">2</span>
<span class="n">dict5</span><span class="p">[</span><span class="s2">&quot;D&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">4</span>
<span class="n">dict5</span><span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">3</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dict5</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>(&#39;A&#39;, 1)
(&#39;B&#39;, 2)
(&#39;D&#39;, 4)
(&#39;C&#39;, 3)
</code></pre>
</div>

<p>Sonuca bakıyoruz, liste aynen eklenme sırasını yansıtıyor. Normal bir
sözlük bu sonucu garantilemez, sıralama rasgele olabilirdi.</p>

<h1>Anahtar Çeşitleri</h1>

<p>"Depolanan şey herhangi bir obje olabilir" dedik, buna ek olarak,
belli şartlara uymak kaydıyla anahtar çoğu baz Python objeleri bile
olabilir. Mesela tüpler (tuples),</p>

<div class="codehilite">
<pre><span></span><code><span class="n">tuple1</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">tuple2</span> <span class="o">=</span> <span class="p">((</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
<span class="n">dict6</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">dict6</span><span class="p">[</span><span class="n">tuple1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bazi degerler burada&quot;</span>
<span class="n">dict6</span><span class="p">[</span><span class="n">tuple2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;baska degerler&quot;</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">dict6</span><span class="p">[</span><span class="n">tuple1</span><span class="p">])</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">dict6</span><span class="p">[</span><span class="n">tuple2</span><span class="p">])</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>bazi degerler burada
baska degerler
</code></pre>
</div>

<p>Anahtar olabilecek temel tipler değiştirilemeyen (immutable)
nesnelerdir, bunlar String, int, tuple tipleri. Fakat daha önce
bahsettiğimiz gibi bir anahtar sonuçta böleçlenen bir şey, o zaman bir
böleç fonksiyonu sağlayan her nesne, kullanıcı tanımlı bile olsa
anahtar olabilir.</p>

<div class="codehilite">
<pre><span></span><code><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a2</span> <span class="o">=</span> <span class="n">a2</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">a1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">a1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">a2</span><span class="p">)</span>

<span class="n">object_a</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">object_b</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">object_c</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">a_dictionary</span> <span class="o">=</span> <span class="p">{</span><span class="n">object_a</span> <span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">object_b</span> <span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">object_c</span> <span class="p">:</span> <span class="mi">5</span><span class="p">}</span>

<span class="nb">print</span><span class="p">(</span><span class="n">a_dictionary</span><span class="p">[</span><span class="n">object_a</span><span class="p">])</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>4
</code></pre>
</div>

<p>Görüldüğü gibi <code>object_a</code> objesinin tamamını bir anahtar olarak kullandık
ve doğru değere erisebildik çünkü sınıf üzerinde <code>__hash__</code> tanımlandı
perde arkasında Python sözlük kodu bu fonksiyonu çağırarak gerekli değeri
oradan alabiliyor.</p>

<p>Dikkat edersek <code>object_b</code> aynı değerleri taşıdığı için aynı böleci
üretir, o zaman sözlük açısından aynı anahtar değeridir. <code>object_c</code>
farklı değerleri olduğu için farklı bir anahtardır.</p>

<div class="codehilite">
<pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="n">a_dictionary</span><span class="p">[</span><span class="n">object_b</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a_dictionary</span><span class="p">[</span><span class="n">object_c</span><span class="p">])</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>4
5
</code></pre>
</div>

<p>Değer <code>4</code> iki üstteki ile aynı, ama <code>5</code> farklı.</p>

<p>Kaynaklar</p>

<p>[1] <a href="../../2021/12/python-list-comprehension.html">Python Liste Kavraması (List Comprehension)</a></p>

<p>[2] <a href="../../2022/11/nosql-diy-python.html">NoSQL</a></p>

<p>[3] https://github.com/deep-compute/diskdict</p>

          <br/><a href="../index.html">Yukarı</a>
        </section>          
      </div>
    </body>
</html>
