<h1>Python Liste Kavraması (List Comprehension)</h1>
<p>Python'un en geç anlaşılan, öğrenilen özelliklerinden biri belki de
budur. Kitap yazarlarının bile hala eski usül liste oluşturmayı
kullanması bunun işareti. Eski usül nasıldır? Mesela 1 ila 10
arasındaki sayıların karesini alacağım, ve bununla yeni bir liste
oluşturacağım. Ana liste,</p>
<pre><code class="python">data = list(range(1,11))
print (data)
</code></pre>

<pre><code class="text">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>

<pre><code class="python">kareler = []
for x in range(1,11):
   kareler.append(x**2)
print (kareler)
</code></pre>

<pre><code class="text">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>

<p>Bir boş liste tanımlandı, ona ekler yapıldı, bir <code>for</code> döngüsü var,
vs. Fakat liste oluşturması liste kavrama ile tek bir satırda
yapılabilirdi,</p>
<pre><code class="python">kareler = [x**2 for x in range(1,11)]
print (kareler)
</code></pre>

<pre><code class="text">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>

<p>Yani liste içeriğinin nasıl oluşturulacağını bir nevi liste tanımının
parçası haline getirmiş oluyoruz. </p>
<p>Kavrama operasyonları çok daha kapsamlı olabiliyor, <code>if</code>, <code>else</code>,
kullanmak mümkün mesela, hatta içiçe (nested) döngüler bile
kullanılabiliyor.</p>
<p>Sadece çift sayıların karesini alalım, diğerleri olduğu gibi kalsın,</p>
<pre><code class="python">kareler2 = [x**2 if x%2==0 else x for x in range(1,11)]
print (kareler2)
</code></pre>

<pre><code class="text">[1, 4, 3, 16, 5, 36, 7, 64, 9, 100]
</code></pre>

<p>Liste kavrama ifadeleri biraz dil sözdizimini tersine çeviriyor sanki,
mesela <code>for</code> döngü içine gidecek olan <code>if</code> ifadesi şimdi en başta.</p>
<p>İçiçe döngü örneği; 100 ila 105 arasındaki sayılar dış döngü, 1 ile 3
arasındakiler iç döngü olsun, ve içteki listeyi gezerken dıştakine
ekleyelim. Eski usulle bunu</p>
<pre><code class="python">toplamlar = []
for x in range(100,106):
   for y in range(1,4):
      toplamlar.append(x+y)
print (toplamlar)      
</code></pre>

<pre><code class="text">[101, 102, 103, 102, 103, 104, 103, 104, 105, 104, 105, 106, 105, 106, 107, 106, 107, 108]
</code></pre>

<p>diye yapardık. Uzun iş.. Her şeyi tek satırda yapabilirdik,</p>
<pre><code class="python">toplamlar = [x+y for x in range(100,106) for y in range(1,4)]
print (toplamlar)
</code></pre>

<pre><code class="text">[101, 102, 103, 102, 103, 104, 103, 104, 105, 104, 105, 106, 105, 106, 107, 106, 107, 108]
</code></pre>

<p>Bu temel ile pek çok yöne gidilebilir. Unutmayalım, <code>enumerate</code> ile herhangi
bir liste gezimi sırasında üzerinde olunan indis üretilebilir,</p>
<pre><code class="python">for i,x in enumerate(['ali','veli','ahmet']):
   print (i,x)
</code></pre>

<pre><code class="text">0 ali
1 veli
2 ahmet
</code></pre>

<p>Ve bu tür bir kullanım liste kavraması için de aynen geçerlidir,</p>
<pre><code class="python">isimler_indisler = [(i,x) for i,x in enumerate(['ali','veli','ahmet'])]
print (isimler_indisler)
</code></pre>

<pre><code class="text">[(0, 'ali'), (1, 'veli'), (2, 'ahmet')]
</code></pre>

<p>Böylece bir değişken grubu (tuple) listesi oluşturduk, ve tüm bunları
tek bir satırda yaptık.</p>
<p>Şimdi sıkı durun, benzer bir sözdizim ile Python sözlüğü de
(dictionary) yaratmak mümkün, </p>
<pre><code class="python">isimler_indis_dict = { i:x for i,x in enumerate(['ali','veli','ahmet']) }
print (isimler_indis_dict)
</code></pre>

<pre><code class="text">{0: 'ali', 1: 'veli', 2: 'ahmet'}
</code></pre>

<p>Aslında bu kullanıma sözlük kavraması (dictionary comprehension)
deniyor, her neyse, benzer kullanım alanı.</p>
<p>Uygulama</p>
<p>Bu konuya nereden girdik? Veri bilimiyle alakalı bir kitap okuyordum,
<em>Introduction to Time Series Modeling with Python</em> adında, yazar
regresyon yapıyor, veriye eğri uyduruyor, ve katsayılar elde
ediyor. Temel x kordinat değerleri <code>X</code> içinde, katsayılar <code>coef</code>
içinde, sonra modeli tekrar oluşturmak için</p>
<pre><code class="python">X = [1,2,3,4]
coef = [10,5,-3,6]
degree = 3
curve = list()
for i in range(len(X)):
   value = coef[-1]
   for d in range(degree):
      value += X[i]**(degree-d) * coef[d]
   curve.append(value)
print (curve)   
</code></pre>

<pre><code class="text">[18, 100, 312, 714]
</code></pre>

<p>kullanıyor. Fakat bu kod çok karışık... Yapılmaya uğraşılan basit bir
şey aslında, <code>X</code> içindeki her değer için <code>coef</code> içindeki katsayılar
alınıp ona tekabül eden polinom dereceleri <code>x</code> ile çapılacak ve
sonuçlar toplanacak, yani her <code>x</code> için 10 + 5<em>x -3</em>x^2 + 6*x^3 hesabı
yapılacak. Bir dış döngü var, <code>X</code> için, bir de iç döngü var <code>coef</code>
için.</p>
<p>Arkadaş <code>coef</code> gezmek için <code>range</code> ile indis yaratıyor, 1'inci ofsayt
(çünkü o indise <code>degree-d</code> yapmak için ihtiyacı var). Diğer yandan
<code>range(len(X))</code> ile bir diğer indis yaratıyor, ona hiç gerek yok,
ikinci ofsayt. İndis gerektiginde <code>enumerate</code> ile erişilebilirdi, geri
kalan durumlarda <code>for</code> ile öğeleri gezmek yeterlidir. Tabii gereksiz
boş liste yaratmayı bir tarafa bırakalım, o herşeyi daha da uzatmış.</p>
<p>Tüm bunlar çok kısa bir kodla yapılabilirdi,</p>
<pre><code class="python">curve = [np.sum([coef[-1]] + [x**(degree-d)*c for d,c \
        in enumerate(coef[:-1])]) for x in X]

print (curve)
</code></pre>

<pre><code class="text">[18, 100, 312, 714]
</code></pre>

<p>Toplamı nasıl yaptığımıza dikkat, liste içinde liste var, ama içeride
listeyi dışarı vermeden önce <code>numpy.sum(..)</code> ile topluyoruz. </p>