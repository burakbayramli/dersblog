<p><a href="..">Yukarı</a></p>
<h1>Pürüzleştirilmiş Parcaçık Hidrodinamiği (Smoothed Particle Hydrodynamics -SPH-)</h1>
<!DOCTYPE html>
<html>
  <head>
    <title>Pürüzleştirilmiş Parcaçık Hidrodinamiği (Smoothed Particle Hydrodynamics -SPH-)
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
<script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
</script>
</head>

<p>SPH sıvıların dinamik hareketini görmemizi sağlayan bir simulasyon
tekniğidir. Lagrangian bakış açısını temel alır, yani Euler aksine, bir sıvı
paketini takip edip nereye gittiğine, hangi değişimlere uğradığına
bakarız.</p>
<p>Akış dinamiğini anlatan [5]'te</p>
<p>$$
\rho \frac{D \bar{u}}{D t} = F^{toplam} 
$$</p>
<p>denklemini gördük. Bu Newton'un $F=ma$ formülasyonun bir karşılığı. Bu denklemde
basınç, ağdalık gibi kuvvetler için terimler vardı. Toplam kuvvetleri açarsak,</p>
<p>$$
F^{toplam}  = F^{\textrm{basınç}} + F^{\textrm{ağdalık}} + F^{\textrm{yerçekim}} 
$$</p>
<p>Daha detaylı hali,</p>
<p>$$
\rho \frac{D \bar{u}}{D t} = 
- \nabla p + \mu \nabla \cdot \nabla \bar{u} + \rho \bar{g}
\qquad (1)
$$</p>
<p>Simulasyon için bize ivme gerekli. Kütle ve kuvvetten ivme, oradan sayısal
entegrasyon ile yer değişimi elde edilebilir, katı-gövde simulasyonunu kodlarken
[6]'da bu anlatılmıştı. O zaman eldeki $i$'inci parçacık için toplam kuvvet
$F_i$ hesaplarsak</p>
<p>$$
a_i = \frac{\mathrm{d} u_i}{\mathrm{d} t} = \frac{F_i}{\rho_i}
$$</p>
<p>ile ivmeyi buluruz, ve oradan devam ederiz.</p>
<p>Şimdi bize gereken $\nabla p(r_i)$ ve $\nabla^2 u(r_i)$ hesaplarını yaklaşık
yapabilmemizi sağlayacak bir metot kullanmak. SPH tekniği bunu sağlıyor.</p>
<p>Bir fonksiyon $A$ aradeğerleme (interpolation) / yaklaşıklama üzerinden temsil
edilebilir [1],</p>
<p>$$
A_I(r) = \int A(r') W(r-r',h) \mathrm{d} r'
$$</p>
<p>Belirtilmediği yerlerde $r = \bar{r}$, $u = \bar{u}$ kabul edilebilir, bunlar
vektör, $\mathrm{d} r'$ diferansiyel hacim öğesi. $A_I$ aradeğerlenmiş fonksiyon, $A$
yaklaşık göstermeye uğraştığımız fonksiyon. $A$ simulasyon ortamında hesaplanan
herhangi bir ölçüt olabilir, mesela herhangi bir $r=(x,y,z)$ noktasındaki
basınç, sıcaklık, yoğunluk, vs.</p>
<p>$W$ ağırlık fonksiyonudur, ya da çekirdek (kernel) fonksiyonu, sahip olması
gereken bir şart,</p>
<p>$$
\int_\Omega  W(r-r',h) \mathrm{d} r' = 1
$$</p>
<p>ve</p>
<p>$$
\lim_{h \to 0} W(r,h) = \delta(r)
$$</p>
<p>[4, sf. 11]. [4]'te bu tekniğin Dirac fonksiyonu ile bağlantıları
anlatıldı. Eğer $W = \delta$ dersek, yani çekirdek için Dirac fonksiyonu
kullanırsak, orijinal fonksiyonun kendisini elde ederiz.</p>
<p>SPH'in temel fikri entegral aradeğerlemeden geliyor, hatta ona bir tür Çekirdek
Yoğunluk Kestirme (Kernel Density Estimation) yöntemi de denebilir. Sıvıyı
ayrıksal parçalara bölüyoruz, ve takip edilen ölçüt ne ise çekirdek fonksiyonu
üzerinden bu ölçüt pürüzsüzleştiriliyor / etrafa yayılıyor / yumuşatılıyor. Yani
çekirdek yarıçapı içindeki diğer parçacıklar o an üzerinde olduğumuz parçacığın
neyini ölçüyorsak onu etkiliyor, mesela yakındaki parçacıkların basıncı ya da
yoğunluğu bizim basıncı, yoğunluğu etkiliyor. Kabaca düşünülünce aslında bu
bakış açısının sıvıların tabiatına son derece uygun olduğu anlaşılacaktır.</p>
<p>Ortalamanın alınma şekli RBF tekniği [11] ile ya da olasılıktaki beklenti
hesabına benziyor, RBF ile üzerinde olduğumuz veriyi etraftaki verilere Gaussian
uydurarak temsil etmeye uğraşırız, SPH ile üzerinde olduğumüz parçacık ölçümünü
etraftaki ölçütlerin (çoğunlukla Gaussian-ımsı) bir çekirdek üzerinden
ortalamasıyla temsil ederiz. Ortalama bir entegraldir, Olasılık Teorisi'nde
beklentinin alınması gibi, $x$ değerlerinin $f(x)$ üzerinden ağırlıklı
ortalaması $\int_{-infty}^{\infty} x f(x) \mathrm{d} x$.</p>
<p>Yaklaşıklamayı sıvıya uygulamak için onu kütle öğelerine bölmemiz gerekli,
$i$'inci öğe $m_i$ kütlesine, $\rho_i$ yoğunluğuna, ve $r_i$ pozisyonuna sahip
olacak. $A$ ölçütü / hesabının $i$ parçacığındaki değeri $A_i$ ile
gösterilsin. Her parçacık için,</p>
<p>$$
A(r) = \int A(r') W(r-r',h) \mathrm{d} r'
$$</p>
<p>Yaklaşıklık için $A_I(r)$ da diyebilirdik, ya da $\approx$
kullanabilirdik. Şimdi,</p>
<p>$$
 = \int \frac{A(r')}{\rho(r')} W(r-r',h) \rho(r') \mathrm{d} r'
$$</p>
<p>$\rho(r')$'i hem bölen hem bölünene eklediğimiz için hiçbir değişim yaratmamış
olduk, ama böylece $\rho(r') \mathrm{d} r'$ ifadesi elde ettik ki ona parçacık kütlesi
diyebiliriz. Böylece parçacıkların kütleleri üzerinden bir toplam alabiliriz,</p>
<p>$$
A_s(r) = \sum_b m_b \frac{A_b}{\rho_b} W(r-r_b, h)
$$</p>
<p>Formülde kütle kullanımı daha faydalı çünkü kütle simülasyona başlamadan önce
bilinir, hatta çoğu parçacık için birbirinin aynısıdır. </p>
<p>Üstteki toplamın teoride tüm parçacıklar üzerinden alındığı gösterildi, fakat
pratikte $r$'ye yakın olan diğer parçacıklar üzerinden alınır, çoğunlukla
çekirdek $2h$ gibi bir uzaklıkta zaten hızla sıfıra düştüğü için, ayrıca
performans açısından, çok uzaktaki parçacıkları göz önüne almaya gerek yoktur.</p>
<p>Bu formül bana herhangi bir $r$ noktasında hesaplayabileceğim bir $A$ kestirme
hesabı (estimation) vermiş oldu. Parcaçık bazlı simulasyon yaptığımız için her
$i$ parçacığı çevresindeki $j$ parçacıkları üzerinden bu kestirme hesabı
yapabileceğiz.</p>
<p>Bazı hesaplar formülün basit yan ürünü, mesela yoğunluk</p>
<p>$$
\rho_i = \rho(r_i) = \sum_j m_j \frac{\rho_j}{\rho_j} W(r_i-r_j, h) =
\sum_j m_j  W(r_i-r_j, h)
$$</p>
<p>Yani etraftaki parçacıkların kütlesi üzerinden alınan bir ağırlıklı ortalama
bana parçacığın yoğunluğunu veriyor.</p>
<p>Aradeğerlemenin bize sağladığı güzel bir özellik onun üzerinden mesela kolayca
gradyan alabilmem. Diyelim ki $A$ ölçümü basınç, yani $p$. O zaman (1)'de
görülen $-\nabla p$ formülünü üstteki entegral üzerinden açabilmem gerekir ($p$
ölçümünün ya da hesabının nereden geldiği ileride anlatılacak). $r$'de olan her
$i$ parçacığı için $p(r_i)$ diyelim,</p>
<p>$$
p(r_i) = \sum_j \frac{m_j p_j}{\rho_j} W(r_i-r_j,h)
$$</p>
<p>Bu denklemin gradyanını alabiliriz şimdi,</p>
<p>$$
\nabla p(r_i) = \sum \frac{m_j p_j}{\rho_j} \nabla W(r_i-r_j,h)
$$</p>
<p>Gradyan direk $W$ üzerinde uygulanmış oldu. Burada modellemeyi yapan kişi tabii
ki $W$'yi "gradyanı rahat alınan" fonksiyonlar arasından da seçecektir,
böylece işi daha kolaylaşacaktır.</p>
<p>O zaman üstteki sonuç ile $-\nabla p$ yazarsak,</p>
<p>$$
F_i^{\textrm{basınç}} = - \sum_j \frac{m_j p_j}{\rho_j} \nabla W(r_i-r_j,h)
$$</p>
<p>elde ederiz.</p>
<p>Yanlız burada bir problem var, $j$ bölgesindeki basıncı kullanarak o fark
üzerinden $i$ üzerindeki kuvveti hesapladık, fakat basınç farkı dolayısıyla
$i$'nin $j$ üzerinde uyguladığı kuvvet aynı olmayabilir. Yani kuvvet simetrik
olmaz, fakat fizik kanunlarına göre etki-tepki aynı olmalıdır. Simulasyon
amacıyla çoğunlukla yapılan dışarıdan müdahele ile kuvveti simetrik hale
getirmektir, mesela bir yöntem basit aritmetik ortalama almak,</p>
<p>$$
F_i^{\textrm{basınç}} = - \nabla p(r_i) =
- \sum_j m_j \frac{p_i + p_j}{2 \rho_j} \nabla W(r_i-r_j,h)
$$</p>
<p>Ağdalık kuvvetine gelelim. İlk başta (1) bazlı olarak bu formül</p>
<p>$$
F_i^{\textrm{ağdalık}} = \mu \sum_j m_j \frac{u_j}{\rho_j} \nabla^2 W (r_i-r_j, h)
$$</p>
<p>olarak yazılabilirdi. Fakat simetriklik problemi burada da var, bu problem de
hıza olan bağlantıyı izafi hıza çevirerek çözülebilir, çünkü fiziksel olarak
düşünülürse esas önemli olan mutlak hızlar değil iki parçacığın hızlarının
farkı, ya da bir parçacığın diğerine baktığında gördüğü hız (ki bu izafi demek)
o zaman</p>
<p>$$
F_i^{\textrm{ağdalık}} = \mu \sum_j m_j \frac{u_j-u_i}{\rho_j} \nabla^2 W (r_i-r_j, h)
$$</p>
<p>daha uygun olur.</p>
<p>Çekirdek Fonksiyon Seçimi</p>
<p>SPH'in stabilitesi, doğruluğu ve hesap hızı pürüzleştirme çekirdeğinin doğru
seçilmiş olmasına bağlı [2]. Çekirdek fonksiyonlarını hangisinin, hangi
durumlarda iyi olacağı aktif bir araştırma alanıdır. Yaygın kullanılan bir
çekirdek <code>poly6</code> ismiyle bilinen 6. derece polinom çekirdeği. Bu fonksiyon,</p>
<p>$$
W_{poly6} (r, h) = \frac{315}{64 \pi h^9}
\left\{ \begin{array}{ll}
(h^2 - ||r||^2)^3 &amp; 0 \le ||r|| \le h \\
0 &amp; ||r|| &gt; h
\end{array} \right.
$$</p>
<p>Gradyanı,</p>
<p>$$
\nabla W (r, h) =
- \frac{945}{32 \pi h^9} r ( h^2 - ||r||^2)^2
$$</p>
<p>Laplasyanı ise,</p>
<p>$$
\nabla^2 W (r, h) =
- \frac{945}{32\pi h^9} (h^2 - ||r||^2)(3 h^2 - 7||r||^2)
$$</p>
<p>Tek boyutta ve $h=1$ üzerinden her üç fonksiyonu grafikleyebiliriz,</p>
<pre><code class="python">r = np.linspace(-1,1,100)
h = 1
import pandas as pd
df = pd.DataFrame(r)
df.columns = ['r']
df['W'] = (315./(64*np.pi*h**9)) * (h**2 - np.abs(r)**2)**3
df = df.set_index('r')
df.plot()
plt.savefig('compscieng_app40sph_01.png')
</code></pre>

<p><img alt="" src="compscieng_app40sph_01.png" /></p>
<pre><code class="python">df = pd.DataFrame(r)
df.columns = ['r']
df['W'] = (315./(64*np.pi*h**9)) * (h**2 - np.abs(r)**2)**3
df['Gradyan W'] = -945./(32*np.pi*h**9) * r * (h**2 - np.abs(r)**2)**2
df = df.set_index('r')
df.plot()
plt.savefig('compscieng_app40sph_02.png')
</code></pre>

<p><img alt="" src="compscieng_app40sph_02.png" /></p>
<pre><code class="python">df = pd.DataFrame(r)
df.columns = ['r']
df['W'] = (315./(64*np.pi*h**9)) * (h**2 - np.abs(r)**2)**3
df['Gradyan W'] = -945./(32*np.pi*h**9) * r * (h**2 - np.abs(r)**2)**2
df['Laplasyan W'] = -945./(32*np.pi*h**9) * \
                   (h**2-np.abs(r)**2) * \
                   (3*h**2 - 7**np.abs(r)**2)
df = df.set_index('r')
df.plot()
plt.savefig('compscieng_app40sph_03.png')
</code></pre>

<p><img alt="" src="compscieng_app40sph_03.png" /></p>
<p>Basınç</p>
<p>Basınç kuvveti eğer basınç biliniyorsa hesaplanabilir, basıncın kendisini
hesaplamak için İdeal Gaz Kanunu gerekli [9], bu kanun</p>
<p>$$
p V = n R T
$$</p>
<p>ki $V = 1 / \rho$, yani birim kütleye düşen hacim, $n$ mol üzerinden kaç tane
gaz parçacığı olduğu, $R$ evrensel gaz sabiti, $T$ ise sıcaklık. SPH için sıvıda
eşsıcaklık (isothermal), ve parçacıkların sayısı simulasyon sırasında değişmez
kabul edilir, o zaman üstteki formülün sağ tarafında bir gaz sertlik (stiffness)
sabiti $k$ kullanılabilir [4, sf. 18], </p>
<p>$$
p V = k
$$</p>
<p>$$
p \frac{1}{\rho} = k
$$</p>
<p>$$
p  = k \rho
$$</p>
<p>Sayısal kodlamalarda stabilite amaçlı olarak ayrıca bir de $\rho_0$ kullanılır,
ki her basınç hesabı için yoğunluğun bu baz $\rho_0$ ile olan farkı bazlı
alınır, nihai formül,</p>
<p>$$
p  = k (\rho - \rho_0)
$$</p>
<p>Simülasyon kodu alttadır. Simüle edilen bir blok sıvıyı havada asılı bir
durumdan bırakmak. Ne olacak? Yerçekim etkisiyle tabii ki sıvı parçacıkları
düşmeye başlayacaklar, ama normal sadece elastik çarpışma içeren simülasyondan
farklı olarak şimdi sıvı parçacıkları arasında ağdalık var, yani birbirlerine
yakın durmaya meyilliler. Ayrıca basınç var, tüm bunların etkisini simüle eden
program acaba sıvısal bir davranış gösterecek mi? Simülasyon animasyon / video
olarak [10]'da bulunabilir.</p>
<pre><code class="python">from random import random
from collections import defaultdict 
import numpy as np, datetime
import sys, numpy.linalg as lin
from mayavi import mlab
import itertools

m = 0.1
R = 0.1
EPS = 0.1
BOUND_DAMPING = -0.6
mmin,mmax=0.0,2.0
BN = int(np.abs(mmax-mmin) / R) + 1
bins = np.linspace(mmin, mmax, BN)
G = np.array([0.0, 0.0, -9.8*2])

REST_DENS = 10.0
GAS_CONST = 0.5
MASS = 100.0
VISC = 20.0
DT = 0.1
H = 0.1 # kernel radius
PI = 3.14159
HSQ = H*H # radius^2 for optimization
POLY6 = 315.0/(65.0*PI*np.power(H, 9.));
SPIKY_GRAD = -45.0/(PI*np.power(H, 6.));
VISC_LAP = 45.0/(PI*np.power(H, 6.));
EPS = 0.05
BOUND_DAMPING = -0.5


idx27 = list(itertools.product( [-1,0,1], repeat=3  ))

class Simulation:
    def __init__(self):
        self.r   = R
        self.balls = []

    def init(self):
        i = 0
        for xs in np.linspace(0, 0.4, 10):
            for ys in np.linspace(0, 0.4, 10):
                for zs in np.linspace(0, 0.4, 10):
                    v = np.array([0.0, 0.0, 0.0])
                    f = np.array([0,0,0])
                    x = np.array([xs, ys, zs])
                    xi = np.digitize(xs, bins)
                    yi = np.digitize(ys, bins)
                    zi = np.digitize(zs, bins)                    
                    d = {'x': x, 'f':f, 'v': v, 'i': i, 'rho': 0.0, 'p': 0.0, 'grid': (xi,yi,zi)}
                    self.balls.append(d)
                    i += 1
        self.rvec   = np.ones(i) * self.r

    def get_neighbors(self, ball):
        neighbors = {}
        cx,cy,cz = ball['grid']
        for (xa,ya,za) in idx27:
            nx,ny,nz = cx+xa,cy+ya,cz+za
            if (nx,ny,nz) in self.grid_hash:
                tn = self.grid_hash[(nx,ny,nz)]
                for n in tn: neighbors[ n['i'] ] = n
        return neighbors

    def hash_balls(self):
        self.grid_hash = defaultdict(list)
        for i,b in enumerate(self.balls):
            xi = np.digitize(b['x'][0], bins)
            yi = np.digitize(b['x'][1], bins)
            zi = np.digitize(b['x'][2], bins)
            b['grid'] = (xi,yi,zi)
            self.grid_hash[(xi,yi,zi)].append(b)

    def computeDensityPressure(self):
        for i,pi in enumerate(self.balls):            
            pi['rho'] = 0.0                
            otherList = self.get_neighbors(pi)
            for (k,pj) in otherList.items():
                r2 = lin.norm(pj['x']-pi['x'])**2
                if  r2 &lt; HSQ:
                    pi['rho'] += MASS*POLY6*np.power(HSQ-r2, 3.0)
            pi['p'] = GAS_CONST*(pi['rho'] - REST_DENS)


    def computeForces(self):
        for i,pi in enumerate(self.balls):
            fpress = np.array([0.0, 0.0, 0.0])
            fvisc = np.array([0.0, 0.0, 0.0])                
            otherList = self.get_neighbors(pi)
            for k,pj in otherList.items():
                if pj['i'] == pi['i']: continue
                rij = pi['x']-pj['x']
                r = lin.norm(rij)
                if r &lt; H:
                    if np.sum(rij)&gt;0.0: rij = rij / r
                    tmp1 = -rij*MASS*(pi['p'] + pj['p']) / (2.0 * pj['rho'])
                    tmp2 = SPIKY_GRAD*np.power(H-r,2.0)
                    fpress += (tmp1 * tmp2)
                    tmp1 = VISC*MASS*(pj['v'] - pi['v'])
                    tmp2 = pj['rho'] * VISC_LAP*(H-r)
                    fvisc += (tmp1 / tmp2)
            fgrav = G * pi['rho']
            pi['f'] = fpress + fvisc + fgrav

    def integrate(self):
        for j,p in enumerate(self.balls):
            if p['rho'] &gt; 0.0: 
                p['v'] += DT*p['f']/p['rho']
            p['x'] += DT*p['v']

            if p['x'][0]-EPS &lt; 0.0:
                p['v'][0] *= BOUND_DAMPING
                p['x'][0] = 0.0
            if p['x'][0]+EPS &gt; 2.0:
                p['v'][0] *= BOUND_DAMPING
                p['x'][0] = 2.0-EPS

            if p['x'][1]-EPS &lt; 0.0:
                p['v'][1] *= BOUND_DAMPING
                p['x'][1] = 0.0
            if p['x'][1]+EPS &gt; 2.0:
                p['v'][1] *= BOUND_DAMPING
                p['x'][1] = 2.0-EPS

            if p['x'][2]-EPS &lt; 0.0:
                p['v'][2] *= BOUND_DAMPING
                p['x'][2] = 0.0
            if p['x'][2]+EPS &gt; 2.0:
                p['v'][2] *= BOUND_DAMPING
                p['x'][2] = 2.0-EPS


        self.hash_balls()


    def update(self):
        self.hash_balls()
        self.computeDensityPressure()
        self.computeForces()
        self.integrate()                    

    def display(self, i):
        mlab.options.offscreen = True
        ball_vect = [[b['x'][0],b['x'][1],b['x'][2]] for b in self.balls]
        ball_vect = np.array(ball_vect)

        fig = mlab.figure(figure=None, fgcolor=(0., 0., 0.), bgcolor=(1, 1, 1), engine=None)
        color=(0.2, 0.4, 0.5)
        mlab.points3d(ball_vect[:,0], ball_vect[:,1], ball_vect[:,2], self.rvec, color=color, colormap = 'gnuplot', scale_factor=1, figure=fig)
        mlab.points3d(0, 0, 0, 0.1, color=(1,0,0), scale_factor=1.0)

        BS = 2.0
        mlab.plot3d([0.0,0.0],[0.0, 0.0],[0.0, BS], color=(0,0,0), tube_radius=None, figure=fig)
        mlab.plot3d([0.0,BS],[0.0, 0.0],[0.0, 0.0], color=(1,0,0), tube_radius=None, figure=fig)
        mlab.plot3d([0.0,0.0],[0.0, BS],[0.0, 0.0], color=(0,1,0), tube_radius=None, figure=fig)
        mlab.plot3d([0.0,0.0],[0.0, BS],[BS, BS], color=(0,0,0), tube_radius=None, figure=fig)
        mlab.plot3d([0.0,BS],[0.0,0.0],[BS,BS], color=(0,0,0), tube_radius=None, figure=fig)
        mlab.plot3d([BS,BS],[0.0,BS],[BS,BS], color=(0,0,0), tube_radius=None, figure=fig)
        mlab.plot3d([BS,0],[BS,BS],[BS,BS], color=(0,0,0), tube_radius=None, figure=fig)
        mlab.plot3d([0,0],[BS,BS],[BS,0], color=(0,0,0), tube_radius=None, figure=fig)
        mlab.plot3d([BS,BS],[0.0,0.0],[0.0,BS], color=(0,0,0), tube_radius=None, figure=fig)
        mlab.plot3d([BS,BS],[0.0,BS],[0.0,0.0], color=(0,0,0), tube_radius=None, figure=fig)
        mlab.plot3d([BS,0.0],[BS,BS],[0.0,0.0], color=(0,0,0), tube_radius=None, figure=fig)
        mlab.plot3d([BS,BS],[BS,BS],[0.0,BS], color=(0,0,0), tube_radius=None, figure=fig)

        mlab.view(azimuth=50, elevation=80, focalpoint=[1, 1, 1], distance=8.0, figure=fig)

        mlab.savefig(filename='/tmp/sim/out-%02d.png' % i)

if __name__ == '__main__':
    s = Simulation()
    s.init()
    for i in range(20):
        print (i)
        s.update()
        s.display(i)
        #exit()
</code></pre>

<p><img alt="" src="glutout-002.png" />
<img alt="" src="glutout-004.png" /></p>
<p><img alt="" src="glutout-006.png" />
<img alt="" src="glutout-008.png" /></p>
<p>Komşuları bulmak için [12]'deki ızgara bazlı yöntem kullanıldı. Bu yöntem, biraz
ek yapılarak mükkemmel sonuç verebilir, ve bu önemli çünkü SPH'in doğru
çalışabilmesi için <em>tüm</em> komşuların bulunabilmesi gerekir.</p>
<p>Benzer hesapları yapan C++ kodu alttadır. </p>
<pre><code class="python">// How to compile, and other info
// https://burakbayramli.github.io/dersblog/sk/2020/08/sph.html
// g++ simsph2.cpp -std=c++1z  -g -O2 -o /tmp/a.exe; /tmp/a.exe
// https://github.com/cerrno/mueller-sph
#include &lt;map&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt; 
#include &lt;vector&gt;
#include &lt;eigen3/Eigen/Dense&gt;

using namespace std;
using namespace Eigen;

const static Vector3d G(0.f, 0.f, 12000*-9.8f); 
const static float REST_DENS = 100.f; // rest density
const static float GAS_CONST = 200.f; // const for equation of state
const static float H = 16.f; 
const static float DIST = 10.f;
const static float HSQ = H*H; 
const static float MASS = 100.f;
const static float VISC = 200.f; 
const static float DT = 0.01f; 
static int LOOP = 40;
static int BIN_WIDTH = 5.f;
static int BIN_NUM = 100;
static float MAX_COORD = 500;
ofstream foutx;
ofstream fouty;
ofstream foutz;

// puruzsuzlestirici cekirdek ve turevleri
const static float POLY6 = 315.f/(65.f*M_PI*pow(H, 9.f));
const static float SPIKY_GRAD = -45.f/(M_PI*pow(H, 6.f));
const static float VISC_LAP = 45.f/(M_PI*pow(H, 6.f));

const static float EPS = H;
const static float BOUND_DAMPING = -0.5f;

struct int3 {

    int i, j, k;
    int3(){}
    int3(int _i, int _j, int _k)
    {
    i=_i; j=_j; k=_k;
    }    
    bool operator==(const int3 &amp;rhs) const
    {
        return i == rhs.i &amp;&amp; j == rhs.j &amp;&amp; k == rhs.k;
    }        
    bool operator&lt;(int3 const&amp; rhs) const
    {   
    return i &lt; rhs.i || ( i == rhs.i &amp;&amp; j &lt; rhs.j ) 
        || ( i == rhs.i &amp;&amp; j == rhs.j  &amp;&amp; k &lt; rhs.k ) ;
    }    
};

static int calcBin(float x) {
    int res = (int)(x / BIN_WIDTH) + 1;
    if (res &gt;= BIN_NUM) return BIN_NUM;
    return res;
}

struct Particle {
    Particle() {
    //std::cout &lt;&lt; &quot;empty&quot; &lt;&lt; std::endl;
    //exit(0);
    }
    Particle(float _x, float _y, float _z, int _i) : x(_x, _y, _z),
                   v(0.f, 0.f, 0.f),
                   f(0.f, 0.f, 0.f),
                   rho(0.f),
                   p(0.f) {
    bin.i = calcBin(x[0]);
    bin.j = calcBin(x[1]);
    bin.k = calcBin(x[2]);
    i = _i;
    }
    Vector3d x, v, f;
    int3 bin;
    int i;
    float rho, p;
};


static vector&lt;Particle&gt; particles;

std::map&lt;int3,  std::vector&lt;Particle&gt;&gt; grid_hash; 

std::map&lt;int,  Particle&gt;
getNeighbors(Particle particle){

    std::map&lt;int,  Particle&gt; result;

    // 3d izgara hucresinin etrafindaki tum hucrelere bak, bunlar
    // icinde oldugumuz dahil 27 tane, sag, sol, alt, ust, vs, tum
    // yonlere bakiyoruz
    for (auto &amp; i : {-1,0,1}) {
    for (auto &amp; j : {-1,0,1}) {
        for (auto &amp; k : {-1,0,1}) {
        int ni = particle.bin.i + i;
        int nj = particle.bin.j + j;
        int nk = particle.bin.k + k;
        int3 newk(ni,nj,nk);
        // bulduklarini sonuca ekle
        for (Particle &amp; pn : grid_hash[newk]) {
            result[pn.i] = pn;
        }
        }
    }
    }

    return result;
}

void initGridHash(void)
{
    // sozlugu sil parcacik uzerindeki hucre indislerinin onceden
    // guncellenmis oldugunu farzet, o degerleri kullanip izgara
    // sozlugune her seyi tekrar ekle
    for(auto const&amp; [key, value]: grid_hash)
    {
    grid_hash[key].clear();
    }
    for(auto &amp;p : particles)
    {
    int3 k(p.bin.i, p.bin.j, p.bin.k);
    grid_hash[k].push_back(p);
    }

}

void InitSPH(void)
{

    foutx.open (&quot;/tmp/simsph-x.csv&quot;);
    fouty.open (&quot;/tmp/simsph-y.csv&quot;);
    foutz.open (&quot;/tmp/simsph-z.csv&quot;);

    int balls = 0;
    for(float x = 0.f; x &lt; 100.f; x += 5.f) { 
    for(float y = 400.f; y &lt; 500.f; y += 5.f) { 
        for(float z = 0.f; z &lt; 100.f; z += 5.f) {
        Particle p(x,y,z,balls);
        p.bin.i = calcBin(p.x[0]);
        p.bin.j = calcBin(p.x[1]);
        p.bin.k = calcBin(p.x[2]);  
        particles.push_back(p);
        balls ++;
        }
    }
    }

    initGridHash();

    std::cout &lt;&lt; &quot;balls:&quot; &lt;&lt; balls &lt;&lt; std::endl;
}


void Integrate(void)
{
    for(auto &amp;p : particles)
    {
    // ileri Euler entegrasyonu
    if (p.rho &gt; 0.0f) p.v += DT*p.f/p.rho;
    p.x += DT*p.v;

    // sinir sartlarini kontrol et
    if(p.x(0)-EPS &lt; 0.0f)
        {
        p.v(0) *= BOUND_DAMPING;
        p.x(0) = 0.0f;
        }
    if(p.x(0)+EPS &gt; 500.0f) 
        {
        p.v(0) *= BOUND_DAMPING;
        p.x(0) = 500.0f-EPS;
        }

    if(p.x(1)-EPS &lt; 0.0f)
        {
        p.v(1) *= BOUND_DAMPING;
        p.x(1) = 0.0f;
        }
    if(p.x(1)+EPS &gt; 500.0f)
        {
        p.v(1) *= BOUND_DAMPING;
        p.x(1) = 500.0f-EPS;
        }

    if(p.x(2)-EPS &lt; 0.0f)
        {
        p.v(2) *= BOUND_DAMPING;
        p.x(2) = 0.0f;
        }
    if(p.x(2)+EPS &gt; 500.0f)
        {
        p.v(2) *= BOUND_DAMPING;
        p.x(2) = 500.0f-EPS;
        }

    p.bin.i = calcBin(p.x[0]);
    p.bin.j = calcBin(p.x[1]);
    p.bin.k = calcBin(p.x[2]);          
    }
}

void ComputeDensityPressure(void)
{
    for(auto &amp;pi : particles)
    {
    pi.rho = 0.f;
    for(auto &amp;pj : particles)
        {
        Vector3d rij = pj.x - pi.x;
        float r2 = rij.squaredNorm();

        if(r2 &lt; HSQ)
            {
        pi.rho += MASS*POLY6*pow(HSQ-r2, 3.f);
            }
        }
    pi.p = GAS_CONST*(pi.rho - REST_DENS);
    }
}

void ComputeForces(void)
{
    for(auto &amp;pi : particles)
    {
    Vector3d fpress(0.f, 0.f, 0.f);
    Vector3d fvisc(0.f, 0.f, 0.f);
    for(auto &amp;pj : particles)
        {
        if(&amp;pi == &amp;pj)
        continue;

        Vector3d rij = pj.x - pi.x;
        float r = rij.norm();

        if(r &lt; DIST)
            {
        fpress += -rij.normalized()*MASS*(pi.p + pj.p)/(2.f * pj.rho)
            * SPIKY_GRAD*pow(H-r,2.f);
        fvisc += VISC*MASS*(pj.v - pi.v)/pj.rho * VISC_LAP*(H-r);
            }
        }
    Vector3d fgrav = G * pi.rho;
    pi.f = fpress + fvisc + fgrav;
    }
}

void Update(void)
{
    std::cout &lt;&lt; &quot;---&quot; &lt;&lt; std::endl;
    ComputeDensityPressure();
    ComputeForces();
    Integrate();

    for(auto &amp;pi : particles)
    {
    foutx &lt;&lt; pi.x[0] &lt;&lt; &quot;;&quot;;
    fouty &lt;&lt; pi.x[1] &lt;&lt; &quot;;&quot;;
    foutz &lt;&lt; pi.x[2] &lt;&lt; &quot;;&quot;;
    }
    foutx &lt;&lt; '\n';
    fouty &lt;&lt; '\n';
    foutz &lt;&lt; '\n';
}


int main(int argc, char** argv)
{
    InitSPH();

    for (int i=0;i&lt;LOOP;i++) {
    Update();   
    }

    return 0;
}
</code></pre>

<p>Kod çıktıyı CSV dosyalarına yazıyor, oradan grafikleme rutini ile kare kare tüm
grafikleri basıyoruz, </p>
<pre><code class="python">import csv, numpy as np, re
from mayavi import mlab
mlab.options.offscreen = True

BS = 500.0

csvx = open('/tmp/simsph-x.csv')
rdx = csv.reader(csvx,delimiter=';')
itx = iter(rdx)

csvy = open('/tmp/simsph-y.csv')
rdy = csv.reader(csvy,delimiter=';')
ity = iter(rdy)

csvz = open('/tmp/simsph-z.csv')
rdz = csv.reader(csvz,delimiter=';')
itz = iter(rdz)

for i in range(40):
    print (i)

    rowx = next(itx)
    rowx = [float(x) if re.search('[0-9]*\.?[0-9]', x) else 0 for x in rowx]
    x = np.array(rowx)

    rowy = next(ity)
    rowy = [float(x) if re.search('[0-9]*\.?[0-9]', x) else 0 for x in rowy]
    y = np.array(rowy)

    rowz = next(itz)
    rowz = [float(x) if re.search('[0-9]*\.?[0-9]', x) else 0 for x in rowz]
    z = np.array(rowz)

    r = np.ones(len(rowx))*10.0

    fig = mlab.figure(figure=None, fgcolor=(0., 0., 0.), bgcolor=(1, 1, 1), engine=None)
    color=(0.2, 0.4, 0.5)
    mlab.points3d(x, y, z, r, color=color, colormap = 'gnuplot', scale_factor=1, figure=fig)

    mlab.plot3d([0.0,0.0],[0.0, 0.0],[0.0, BS], color=(0,0,0), tube_radius=None, figure=fig)
    mlab.plot3d([0.0,BS],[0.0, 0.0],[0.0, 0.0], color=(1,0,0), tube_radius=None, figure=fig)
    mlab.plot3d([0.0,0.0],[0.0, BS],[0.0, 0.0], color=(0,1,0), tube_radius=None, figure=fig)
    mlab.plot3d([0.0,0.0],[0.0, BS],[BS, BS], color=(0,0,0), tube_radius=None, figure=fig)
    mlab.plot3d([0.0,BS],[0.0,0.0],[BS,BS], color=(0,0,0), tube_radius=None, figure=fig)
    mlab.plot3d([BS,BS],[0.0,BS],[BS,BS], color=(0,0,0), tube_radius=None, figure=fig)
    mlab.plot3d([BS,0],[BS,BS],[BS,BS], color=(0,0,0), tube_radius=None, figure=fig)
    mlab.plot3d([0,0],[BS,BS],[BS,0], color=(0,0,0), tube_radius=None, figure=fig)
    mlab.plot3d([BS,BS],[0.0,0.0],[0.0,BS], color=(0,0,0), tube_radius=None, figure=fig)
    mlab.plot3d([BS,BS],[0.0,BS],[0.0,0.0], color=(0,0,0), tube_radius=None, figure=fig)
    mlab.plot3d([BS,0.0],[BS,BS],[0.0,0.0], color=(0,0,0), tube_radius=None, figure=fig)
    mlab.plot3d([BS,BS],[BS,BS],[0.0,BS], color=(0,0,0), tube_radius=None, figure=fig)

    mlab.view(azimuth=50, elevation=80, focalpoint=[200, 200, 200], distance=1600.0, figure=fig)
    mlab.savefig(filename='/tmp/simsph/out-%02d.png' % i)

</code></pre>

<p>ve animasyonu üretiyoruz.</p>
<p><code>convert -scale 70% -delay 30 /tmp/simsph/*.png /tmp/simsph.gif</code></p>
<p>Kaynaklar</p>
<p>[1] Monaghan, <em>Smoothed particle hydrodynamics, 2005</em></p>
<p>[2] Schuermann, <em>Particle-Based Fluid Simulation with SPH</em>,
    <a href="https://lucasschuermann.com/writing/particle-based-fluid-simulation">https://lucasschuermann.com/writing/particle-based-fluid-simulation</a></p>
<p>[3] Bayramlı, <em>Hesapsal Bilim, Ders 4</em></p>
<p>[4] Kelager, <em>Lagrangian Fluid Dynamics Using Smoothed Particle Hydrodynamics</em></p>
<p>[5] Bayramlı, <em>Fizik, Akış Dinamiği</em></p>
<p>[6] Bayramlı, <em>Fizik, Simulasyon</em></p>
<p>[7] Monaghan, <em>Introduction to SPH Part I</em>,
    <a href="https://www.youtu.be/tAXHCAEgSuE">https://www.youtu.be/tAXHCAEgSuE</a></p>
<p>[8] Müller, <em>Particle-Based Fluid Simulation for Interactive Applications</em></p>
<p>[9] Bayramlı, <em>Fizik, Temel Fizik 3, Basınç, Çarpışma</em></p>
<p>[10] Bayramlı, <em>Simulasyon Animasyonu</em>,
    <a href="https://github.com/burakbayramli/classnotes/blob/master/compscieng/compscieng_app40sph/balls4.gif?raw=true">https://github.com/burakbayramli/classnotes/blob/master/compscieng/compscieng_app40sph/balls4.gif?raw=true</a></p>
<p>[11] Bayramlı, <em>Istatistik, Dairesel Baz Fonksiyonları (Radial Basis Functions -RBF-)</em></p>
<p>[12] Bayramlı, <em>Bilgisayar Bilim, Geometrik Anahtarlama (Spatial Hashing) ve Izgara (Grid) ile En Yakın Noktaları Bulmak</em></p>