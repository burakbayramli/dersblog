\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Sinyaller, Geriye Dönük Analiz, Performans

Elimizde bir zaman serisi var, bu seri bir finansal varlığın fiyat seviyesi
olabilir, belki Apple senedidir, ilk gün 100 ikinci gün 102 olmuş, böyle
gidiyor.

\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd
d = np.array([100,102,104.04,106.12,108.24,110.41])
\end{minted}

Peki bu fiyat seviyeleri günlük hangi yüzde değişimlerine tekabül ediyor?
Bunun hesabın bir yolu var, 

\begin{minted}[fontsize=\footnotesize]{python}
p = pd.Series(d)
print (list(p))
print (list(np.round(p.pct_change(),2)))
\end{minted}

\begin{verbatim}
[100.0, 102.0, 104.04, 106.12, 108.24, 110.41]
[nan, 0.02, 0.02, 0.02, 0.02, 0.02]
\end{verbatim}

Her gün yüzde 2'lik bir değişim varmış (öyle çıktı çünkü bu yazı için veri
uydururken sayıları ona göre ayarladık).

Şimdi sadece yüzde değişimleri ve başlangıç fiyat seviyesini kullanarak seriyi
tekrar üretebilir miydik? Yüzde değişimle sonraki sayıyı nasıl elde ederiz?
Mesela 100'den yüzde 2 değişimle sonraki değere geçmek için ne gerekir?  Kolay,
1 artı 0.02 yani 1.02 değerini 100 ile çarparız, sonraki sayı çıkar, 102.

O zaman tüm fiyat seviyeleri için eldeki yüzde değişim listesine 1 sayısını
eklersek, 1.02, 1.02, .. elde edilir, ve bu rakamları başta 100 ile, sonra
birbirleri ile çarparsak tüm fiyat listesini tekrar elde ederiz. Bir dizinin tüm
öğelerinin birer birer çarpılıp bunun kümülatif olarak gösterilmesini
\verb!cumprod!  halleder,

\begin{minted}[fontsize=\footnotesize]{python}
ret = p.pct_change()
100*np.cumprod(1+ret)
\end{minted}

\begin{verbatim}
Out[1]: 
0       NaN
1    102.00
2    104.04
3    106.12
4    108.24
5    110.41
dtype: float64
\end{verbatim}

Üstteki hesabı bir al-tut stratejisinin performansı olarak ta görebiliriz. İlla
baştaki 100 değerini kullanmaya gerek yok, 100 yerine 1 dersek o zaman bu
stratejiye koyulmuş 1 liranın, 1 doların ne kadar büyüyeceğini görmüş oluruz.  1
lira 2 lira olduysa bu ikiye katlama demektir, performans iyi sonucuna
varabiliriz.

\begin{minted}[fontsize=\footnotesize]{python}
1*np.cumprod(1+ret)
\end{minted}

\begin{verbatim}
Out[1]: 
0       NaN
1    1.0200
2    1.0404
3    1.0612
4    1.0824
5    1.1041
dtype: float64
\end{verbatim}

Yüzde değişimler, kümülatif çarpımlar ile uğraşmamızın bir sebebi var, işin
içine alım / satım ``sinyallerini'' kolayca dahil edebiliyoruz, ve her
stratejide bir zaman serisi elde edebiliyoruz. Bu serinin istatistiki,
matematiksel özellikleri vardır, ve bu özellikleri özet hesapları için çok
faydalı olur, mesela Sharpe oranı gibi.

\begin{minted}[fontsize=\footnotesize]{python}
signal = pd.Series(np.array([1,1,1,1,0,1]))
ret*signal
\end{minted}

\begin{verbatim}
Out[1]: 
0         NaN
1    0.020000
2    0.020000
3    0.019992
4    0.000000
5    0.020048
dtype: float64
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
signal = pd.Series(np.array([1,1,1,1,0,1]))
1*np.cumprod(1+(ret*signal))
\end{minted}

\begin{verbatim}
Out[1]: 
0         NaN
1    1.020000
2    1.040400
3    1.061200
4    1.061200
5    1.082475
dtype: float64
\end{verbatim}

















\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd
df = pd.read_csv('../tser_008_data/AAPL.csv',index_col='Date',parse_dates=True)
df.plot()
plt.savefig('tser_011_sign_01.jpg')
\end{minted}




[devam edecek]
  
\end{document}
