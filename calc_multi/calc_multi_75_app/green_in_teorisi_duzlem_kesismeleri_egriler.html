<!DOCTYPE html>
<html>
  <head>
    <title>Green'in Teorisi, Düzlem Kesişmeleri, Eğriler
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
   <script type="text/javascript"
       src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
   </script>
   <script async="async" data-cfasync="false" src="//pl22489825.profitablegatecpm.com/d84f574876e65b2d8f0c7bae784c22b3/invoke.js"></script>

<p><link rel="stylesheet" type="text/css" media="screen" href="https://burakbayramli.github.io/css/style.css">
  </head>
    <body>
      <div id="header_wrap" class="outer">
        <header class="inner">
          <h1 id="project_title">
            <a href="https://burakbayramli.github.io" style="text-decoration:none; color:inherit;">dersblog</a>
          </h1>
          <h2 id="project_tagline"></h2>        <br />
        </header>
      </div>
      <div id="main_content_wrap" class="outer">      <br />
        <section id="main_content" class="inner">
        <h1>Green'in Teorisi, Düzlem Kesişmeleri, Eğriler
</h1></p>
<p>Çizgi Düzlem Kesişmesini Vektörler ile Hesaplamak</p>
<p>Üstteki yöntem cebirsel manipülasyon gerektiriyor, fakat sayısal hesap için
sembolik cebir işlemlerine girmeden vektör matematiği ile direk bir sonuç
bulamaz mıyız? [3,4]'ü temel alalım: alttaki durumu düşünelim, </p>
<p><img alt="" src="calc_multi_75_app_06.jpg" /></p>
<p>Grafiğe göre $P(s)$ $P_1$ ve $P_0$ arasındaki birim vektörün $s$ kadar
uzatılmış hali olsun, o aralığı $u$ kabul edersek $P(s)-V_0 = w + su$
olur. Düzlem ile kesişmenin olduğu noktayı $P(s_I)$ diye tanımlayalım,
aradığımız nokta burası. O noktada $n$ ile $P(s_I)$ dikgen olacaktır, yani
$P(s) - V_0 = w + su$ vektörü $n$'e dikgen olacaktır, ki $w=P_0-V_0$. Bu
durumda $n \cdot (w+su) = 0$ olur. Bunu kullanarak,</p>
<p>$$ s_I = \frac{-n \cdot w}{n \cdot u} = 
\frac{n \cdot (V_0 - P_0)}{n \cdot (P_1-P_0)} = 
\frac{-(ax_0 + by_0 + cz_0 + d)}{n \cdot u}
$$</p>
<pre><code class="python">n = np.array([1., 1., 1.])
V0 = np.array([1., 1., -5.])
P0 = np.array([-5., 1., -1.])
P1 = np.array([1., 2., 3.])

w = P0 - V0;
u = P1-P0;
N = -np.dot(n,w);
D = np.dot(n,u)
sI = N / D
I = P0+ sI*u
print I
</code></pre>

<pre><code>[-3.90909091  1.18181818 -0.27272727]
</code></pre>

<p>Grafiklersek</p>
<pre><code class="python">import sys; sys.path.append('../../vision/vision_02')
import plot3d

f = plt.figure()
ax = f.gca(projection='3d')
w = 10
ax.set_xlim(-w,w);ax.set_ylim(-w,w);ax.set_zlim(-w,w)
ax.set_xlabel(&quot;X&quot;)
ax.set_ylabel(&quot;Y&quot;)
ax.set_zlabel(&quot;Z&quot;)
v = P1-P0
ax.quiver(P0[0], P0[1], P0[2], v[0], v[1], v[2], color='red')
ax.scatter(V0[0], V0[1], V0[2], color='black')
ax.scatter(V0[0]+n[0], V0[1]+n[1], V0[2]+n[2], color='black')
ax.scatter(I[0], I[1], I[2], color='black')
ax.quiver(V0[0], V0[1], V0[2], n[0], n[1], n[2], color='blue')
plot3d.plot_plane(ax, list(V0), list(n), color='y')
plt.savefig('calc_multi_75_app_07.jpg')
</code></pre>

<p><img alt="" src="calc_multi_75_app_07.jpg" /></p>
<p>Green'in Teorisi, Uzaklaşım, Stokes, Yol ve Çizgi Entegralleri</p>
<p>Yüzeyler (Surfaces)</p>
<p>Üç boyut içindeki iki boyut yüzeyler parametrize edilerek gösterilir,
tek boyutlu eğri bir parametre $t$ ile parametrize ediliyordu, alan için
iki değişken $u,v$ gerekir. Notasyonel olarak $r$'nin taradığı bir yüzey</p>
<p>$$
r(u,v) = &lt; x(u,v), y(u,v), z(u,v) &gt;
$$</p>
<p>Mesela $r(u,v) = &lt; u, u^2, v &gt;$ bir yüzey olabilir.</p>
<p>Yüzey alan hesabı için tüm yüzeyi kenarları $\Delta u$, $\Delta v$ olan hücreler
yaratabiliriz. Her noktada iki tane teğet vektör bulunabilir, bunlar $t_u$ ve
$t_v$ olsun,</p>
<p>$$
t_u = &lt; \frac{\partial x}{\partial u},
        \frac{\partial y}{\partial u},
        \frac{\partial z}{\partial u} &gt;, \quad
t_v = &lt; \frac{\partial x}{\partial v},
        \frac{\partial y}{\partial v},
        \frac{\partial z}{\partial v} &gt;      <br />
$$</p>
<p>Yaklaşık olarak her hücrenin alanı $\Delta S_{ij}$ her hücredeki $t_u$ ve $t_v$
(ya da yeni notasyonla onlara $t_u^{ij}$ ve $t_v^{ij}$ diyelim) yönündeki
$\Delta u$ ve $\Delta v$'nin oluşturduğu paralelogram alanıdır, bu paralelogram
bildiğimiz gibi iki vektörün çapraz çarpımından gelen üçüncü vektörün
büyüklüğüdür, o zaman </p>
<p>$$
\Delta S_{ij} \approx || \Delta u t_u^{ij} \times \Delta v t_v^{ij} ||
$$</p>
<p>$$
= ||  t_u^{ij} \times t_v^{ij} || \Delta u \Delta v
$$</p>
<p><img alt="" src="calc_multi_75_app_01.jpg" /></p>
<p><img alt="" src="calc_multi_75_app_02.jpg" /></p>
<p>Tüm ufak hücre alanlarını toplarız, ve hücre sayısı sonsuza yaklaşırken toplam
alan limitine bakabiliriz,</p>
<p>$$
\lim_{m,n \to \infty} \sum_{i=1}^{m} \sum_{j=1}^{n} || t_u^{ij} \times t_v^{ij} || \Delta u \Delta v
$$</p>
<p>Bu limit yüzey alan çift entegral hesabına yaklaşır / onu tanımlar, [2, sf. 769],</p>
<p>$$
= \iint_D || t_u \times t_v || \mathrm{d} u \mathrm{d} v = \iint_D || t_u \times t_v || \mathrm{d} A
$$</p>
<p>Yüzey Entegrali (Surface Integral)</p>
<p>Yukarıda gördüklerimiz parametrize edilmiş yüzeyin alanını hesaplamak içindir.
Yüzey entegrali bir yüzey <em>üzerinden</em> alınan entegrallere verilen isimdir,
mesela tek sayı / skalar değerli bir fonksiyon $f$'nin pürüzsüz bir yüzey $S$
üzerinden alınan yüzey entegrali, o fonksiyonun her noktadaki alan büyüklüğü ile
çarpılıp sonuçların toplanmasıdır, cebirsel olarak yine $t_u,t_v$ kavramlarını
kullanırsak,</p>
<p>$$
\iint_S f(x,y,z) \mathrm{d} S 
= \lim_{m,n \to \infty} \sum_{i=1}^{m} \sum_{j=1}^{n} f(P_{ij}) || t_u^{ij} \times t_v^{ij} || \Delta u \Delta v
$$</p>
<p>$$
= \lim_{m,n \to \infty} \sum_{i=1}^{m} \sum_{j=1}^{n} f(P_{ij}) \Delta S_{ij} 
$$</p>
<p>O zaman yüzey entegralleri alttaki şekilde hesaplanabilir,</p>
<p>$$
\iint_S f(x,y,z) \mathrm{d} S =
\iint_D f(r(u,v)) || t_u \times t_v || \mathrm{d} A
$$</p>
<p>Çizgi entegrali (line integrals) daha düşük boyuttaki benzer bir kavram idi.</p>
<p>Vektör Alanları Üzerinden Yüzey Entegrali</p>
<p>Skalar fonksiyona benzer şekilde bir vektör alanı $F$ ve yüzey $S$ üzerinden de
entegral hesaplanabilir. Yine bir ufak çarpımlar toplamından bahsediyoruz, bu
tür bir hesap pek çok uygulama için faydalı olabilir. Mesela bir su akışı
içindeki geçirgen bir yüzeyi düşünürsek, kütle akışını (mass flux) nasıl
hesaplarız? </p>
<p><img alt="" src="calc_multi_75_app_04.jpg" /></p>
<p>Her noktada yüzey $S$'ye dik olan alan $N$ olsun, her noktadaki akış hızı $v$
diyelim, o zaman bir noktadaki birim zaman ve birim alandaki kütle akışı $\rho v
\cdot N$. Ölçüm birimlerini kontrol edelim, hız $m/s$, yoğunluk $\rho$ 
$g/m^3$, çarparsak $g/s \cdot m^2$ elde ederiz, yani birim alan ve zamandaki
kütle akışı.</p>
<p>Şimdi $\rho v \cdot N$ değerini $\Delta S_{ij}$ ile çarparsak $S$ üzerindeki
hayali ufak hücreden birim zamanda akan kütleyi buluruz, tüm bu akışları
toplarız,</p>
<p>$$
\sum_{i=1}^{m} \sum_{j=1}^{n} (\rho v \cdot N) \Delta S_{ij}
$$</p>
<p>Tüm akışı elde etmiş oluruz. Izgara hücreleri $S_{ij}$ ufaldıkça üstteki toplam
gerçek kütle akışına yaklaşır, yani</p>
<p>$$
\iint_S \rho v \cdot N \mathrm{d} S = \lim_{m,n \to \infty}
\sum_{i=1}^{m} \sum_{j=1}^{n} (\rho v \cdot N) \Delta S_{ij}
$$</p>
<p>Devam edelim $\rho v$ yerine herhangi bir vektör alanı $F$ kullanalım, o zaman
şu genel tanımı artık yapabiliriz, $F$'nin $S$ yüzeyi üzerinden entegrali</p>
<p>$$
\iint_S \vec{F} \cdot \mathrm{d} \vec{S} = \iint_S \vec{F} \cdot \vec{N} \mathrm{d} S
$$</p>
<p>olarak gösterilir.</p>
<p><img alt="" src="calc_multi_75_app_05.jpg" /></p>
<p>Dikkat her yerde vektör notasyonu kullanmıyoruz, olmadığı yerde formül
çerçevesine göre anlaşılabilir.</p>
<p>$N$ yüzey normalı, öne dik olan birim vektör, hesabı için önceden gördüğümüz
$t_u,t_v$ vektörlerini kullanabiliriz,</p>
<p>$$
N = \frac{t_u \times t_v}{ || t_u \times t_v || }
$$</p>
<p>Üstteki ifadeyi yüzey entegralinde kullanırsak [2, sf. 778],</p>
<p>$$
\iint_S \vec{F} \cdot \vec{N} \mathrm{d} S =
\iint_S \vec{F} \cdot \frac{t_u \times t_v}{ || t_u \times t_v || } \mathrm{d} S
$$</p>
<p>Daha önce gördük</p>
<p>$$
\mathrm{d} S = || t_u \times t_v || \mathrm{d} u \mathrm{d} v = || t_u \times t_v || \mathrm{d} A
$$</p>
<p>İki üste geçirince</p>
<p>$$
= \iint_D \vec{F}(r(u,v)) \cdot \frac{t_u \times t_v}{ || t_u \times t_v || }
|| t_u \times t_v || \mathrm{d} A
$$</p>
<p>Basitleştirme sonrası,</p>
<p>$$
= \iint_D \vec{F}(r(u,v)) \cdot (t_u \times t_v) || t_u \times t_v || \mathrm{d} A
$$</p>
<p>Soru</p>
<p>$F = &lt; -y, x, 0 &gt;$ olarak veriliyor, $S$ yüzeyi $r(u,v) = &lt; u, v^2 - u, u+v &gt;$.</p>
<p>$\iint_S F \cdot N \mathrm{d} S$ yüzey entegralini hesaplayın.</p>
<p>Cevap</p>
<p>Teğet vektörler $t_u = &lt; 1, -1, 1 &gt;$, ve $t_v = &lt; 0, 2v, 1 &gt;$.</p>
<p>$t_u \times t_v$ çapraz çarpımı</p>
<pre><code class="python">import sympy

u,v = sympy.symbols('u v')
t_u = sympy.Matrix([[1,-1,1]])
t_v = sympy.Matrix([[0,2*v,1]])
print (t_u.cross(t_v))
</code></pre>

<pre><code>Matrix([[-2*v - 1, -1, 2*v]])
</code></pre>

<p>Yüzey entegral hesabı şöyle hesaplanabilir,</p>
<p>$$
\int _{0}^{4} \int _{0}^{3} F(r(u,v)) \cdot (t_u \times t_v) \mathrm{d} u \mathrm{d} v
$$</p>
<p>Verili $F = &lt; -y, x, 0 &gt;$, ve yüzey $r(u,v) = &lt; u, v^2 - u, u+v &gt;$ demiştik,
o zaman </p>
<p>$$
F(r(u,v)) = &lt; u-v^2, u, 0 &gt; 
$$</p>
<p>olur. Tüm entegral</p>
<p>$$
= \int _{0}^{4} \int _{0}^{3} &lt; u-v^2, u, 0 &gt;  \cdot &lt; -1-2v, -1, 2v &gt;
\mathrm{d} u \mathrm{d} v
$$</p>
<p>$$
= \int_{0}^{4} \int_{0}^{3} (2v^3 + v^2 -2uv -2u )
\mathrm{d} u \mathrm{d} v
$$</p>
<p>$$
= \int_{0}^{4} [ 2v^3u + v^2u - vu^2 - u^2 ]_{0}^{3} \mathrm{d} v
$$</p>
<p>$$
= \int_{0}^{4} (6v^3 + 3v^2 - 9v -9 ) \mathrm{d} v
$$</p>
<p>$$
= \left[ \frac{3v^4}{2} + v^3 - \frac{9v^2}{2} - 9v \right]_{0}^{4}
$$</p>
<p>$$
= 340
$$</p>
<pre><code class="python">from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
import numpy as np
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
u = np.linspace(0, 3, 100)
v = np.linspace(0, 4, 100)
u,v = np.meshgrid(u,v)

x = u; y = v**2 - u; z = u + v

ax.plot_surface(x, y, z, rstride=4, cstride=4, cmap = cm.copper)
x = np.linspace(0, 3, 5)
y = np.linspace(0, 10, 5)
z = np.linspace(0, 6, 5)

fu = -y; fv = x; fw = z*0

xx,yy,zz = np.meshgrid(x,y,z)
ax.quiver(xx, yy, zz, fu, fv, fw, length=0.2, color = 'red')
ax.view_init(elev=18, azim=-46)
plt.savefig('calc_multi_75_app_03.jpg',quality=30)
</code></pre>

<p><img alt="" src="calc_multi_75_app_03.jpg" /></p>
<p>Çizgi Düzlem Kesişmesi</p>
<p>Elimizde $P = 2x + y - 4z = 4$ düzlemi var. Bu düzlemin </p>
<p>$$ x = t \quad y = 2 + 3t \quad z = t$$</p>
<p>çizgisi ile kesiştiği yer neresidir? </p>
<p>Cevap kolay; çizgi denkleminde $t$ bazlı tanımlı $x,y,z$ değerleri $P$'ye
sokarsak, tek bilinmeyeni $t$ olan bir denklem çıkar, </p>
<p>$$ 2(t) + (2+3t)-4(t) = 4 \Rightarrow t = 2$$</p>
<p>İki Nokta Arasında Parametrize Edilmiş Eğri</p>
<p>Diyelim ki $(1,1)$ ve $(4,4)$ noktalarından geçen ve dışarıdan tanımlı
parametrelerle yeterince eğilip, bükülebilecek bir eğri tanımlamamız
lazım. Polinomlar üzerinden tanımlanan bir eğri ile bunu başarabiliriz, </p>
<p>$$
x(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3
$$</p>
<p>$$
y(t) = b_0 + b_1 t + b_2 t^2 + b_3 t^3
$$</p>
<p>Bu şekilde bir eğri yeterince eğilip bükülebilir, ve istenen şekle
sokulabilir. Fakat baş ve sonun verili noktalardan geçmesini nasıl garanti
ederiz? Bunun için bu noktaları üstteki denkleme sokalim, ve $0 \le t \le
1$ olacak sekilde kısıtlama yapalim, $t=0$'da</p>
<p>$$
1 = a_0 + a_1 (0) + a_2 (0)^2 + a_3 (0)^3
$$</p>
<p>$$
1 = b_0 + b_1 (0) + b_2 (0)^2 + b_3 (0)^3
$$</p>
<p>Yani  $a_0=1$ ve $b_0=1$. Peki $t=1$ icin?</p>
<p>$$
4 = 1 + a_1 (1) + a_2 (1)^2 + a_3 (1)^3 
$$</p>
<p>$$
4 = 1 + b_1 (1) + b_2 (1)^2 + b_3 (1)^3 
$$</p>
<p>$$
3 = a_1 + a_2 + a_3, \quad 3 = b_1 + b_2 + b_3
$$</p>
<p>Demek ki üstteki iki formüle mutabık kaldığımız sürece
$a_1,a_2,a_3,b_1,b_2,b_3$ ie istediğimiz şekilde oynayarak istediğimiz
eğriyi ortaya çıkartabiliriz. </p>
<pre><code class="python">t = np.linspace(0,1.0,100)

a1,a2 = -1.1, 1.9
b1,b2 = 1.1, 1.4

sx,sy=(1.0,1.0)
ex,ey=(4.0,4.0)

a3 = ex - sx - (a1+a2)
b3 = ey - sy - (b1+b2)

x = 1.0 + a1*t + a2*t**2 + a3*t**3
y = 1.0 + b1*t + b2*t**2 + b3*t**3

plt.xlim(0,5.0)
plt.ylim(0,5.0)
plt.plot(x,y)
plt.savefig('calc_multi_75_app_08.jpg')
</code></pre>

<p><img alt="" src="calc_multi_75_app_08.jpg" /></p>
<p>Max ve Sigmoid Bazlı Yaklaşım</p>
<p>Daha önce [6]'da görülen spline tekniğinin parametrik hali de
olabilir. Mesela </p>
<pre><code class="python">a1,b1,c1,d1 = (1, -1.4, 2, 2.5)
a2,b2,c2,d2 = (1, 1.4, 1, 2.5)
def f(t):
    x = ax + \
        bx*np.max([0,t-2]) + \
        cx*np.max([0,t-3]) + \
        dx*np.max([0,t-4])

    y = ay + \
        by*np.max([0,t-2]) + \
        cy*np.max([0,t-3]) + \
        dy*np.max([0,t-4])
    return x,y     

tmp = np.linspace(0,5,100)
res = np.array([f(tt) for tt in tmp])
plt.plot(res[:,0],res[:,1])
plt.savefig('calc_multi_75_app_09.jpg')
</code></pre>

<p><img alt="" src="calc_multi_75_app_09.jpg" /></p>
<p>Başlangıcı $a_x,a_y$ olan kesik bir eğriyi görüyoruz. Bu tür eğrileri aynen
[6]'da olduğu gibi sigmoid bazlı yapabiliriz,</p>
<pre><code class="python">rho = 7.0
def sig(x,a):
   return (x-a)*1/(1+np.exp(-rho*(x-a)))

def maxk(x,a):
   return np.max([0,x-a])

ax,bx,cx,dx,ex = (1, 2.4, 1, -3.5, -2.1)
ay,by,cy,dy,ey = (1, 0.4, -0.1, 0.5, -3)
def f(t):
    x = ax + \
        bx*maxk(t,2) + \
        cx*maxk(t,3) + \
        dx*maxk(t,3.5) + \
        ex*maxk(t,4.0)

    y = ay + \
        by*maxk(t,2) + \
        cy*maxk(t,3) + \
        dy*maxk(t,3.5) + \
        ey*maxk(t,4.0)
    return x,y     

def g(t):
    x = ax + \
        bx*sig(t,2) + \
        cx*sig(t,3) + \
        dx*sig(t,3.5) + \
        ex*sig(t,4.0)

    y = ay + \
        by*sig(t,2) + \
        cy*sig(t,3) + \
        dy*sig(t,3.5) + \
        ey*sig(t,4.0)
    return x,y     

tmp = np.linspace(0,5,100)
</code></pre>

<pre><code class="python">res = np.array([f(tt) for tt in tmp])
plt.plot(res[:,0],res[:,1])
plt.savefig('calc_multi_75_app_10.jpg')
</code></pre>

<pre><code class="python">res = np.array([g(tt) for tt in tmp])
plt.plot(res[:,0],res[:,1])
plt.savefig('calc_multi_75_app_11.jpg')
</code></pre>

<p><img alt="" src="calc_multi_75_app_10.jpg" />
<img alt="" src="calc_multi_75_app_11.jpg" /></p>
<p>Herhangi bir şekli katsayılarla yaratmak mümkün. </p>
<p>Bitiş noktalasını nasıl ayarlarız? Burada yine polinom örnekteki gibi
cebirsel bir yöntem seçebilirdik, fakat çoğunlukla başlangıç ve bitiş
arasındaki eğriler bir optimizasyon bağlamında kullanılır. Bu durumda
bitiş noktaları ile katsayılar arasında bir optimizasyon kısıtlaması
yaratmak ve bitiş noktalarını böyle ayarlamak daha iyidir. </p>
<p>Çünkü biliyoruz parametrize ortamda mesela önceki örnekte $0 \ge t \ge
5$. O zaman egrinin bitisinde $t=5$ olacağını biliyoruz. Bu durumda mesela </p>
<p>$$
    x = a_x + \
        b_x \sigma(t,2) + \
        c_x \sigma(t,3) + \
        d_x \sigma(t,3.5) +
        e_x \sigma(t,4.0)
$$</p>
<p>ifadesine $t$ tüm ilmik noktalarının ötesinde olduğu için artık tüm
$\sigma$ ifadeleri 1 veriyor. Eğer 1 veriyorsa, yani tüm sigmoid'ler aktif
ise, eğri bitişinde bilinen $t$ üzerinden elimizdeki $x$ 
$x = a_x + b_x(5-2) + c_x(5-3) + d_x(5-3.5) + e_x(5-4.0)$
olmalı. Optimizasyonda bu eşitliğin belli bir değer (istediğimiz bitiş
noktası kordinatı) olmasını şart tutarak amacımız erişebiliriz.</p>
<p>Kaynaklar</p>
<p>[1] Marsden, <em>Vector Calculus</em></p>
<p>[2] Strang, <em>Calculus Volume 3, OpenStaxa</em></p>
<p>[3] Sunday, <em>Intersection of Lines and Planes</em>, 
<a href="http://geomalgorithms.com/a05-_intersect-1.html">http://geomalgorithms.com/a05-_intersect-1.html</a></p>
<p>[4] Khaled, <em>Straight Line and Plane Intersection Matlab Code</em>, 
<a href="https://uk.mathworks.com/matlabcentral/fileexchange/17751-straight-line-and-plane-intersection">https://uk.mathworks.com/matlabcentral/fileexchange/17751-straight-line-and-plane-intersection</a></p>
<p>[5] <em>Distance between Point and Line</em>, 
<a href="https://brilliant.org/wiki/distance-between-point-and-line/">https://brilliant.org/wiki/distance-between-point-and-line/</a></p>
<p>[6] Bayramlı, <em>Hesapsal Bilim, Spline Eğrileri ve Baz Fonksiyonlar</em></p>
<p>[7] Rotenberg, <em>CSE169: Computer Animation</em>,
    <a href="https://cseweb.ucsd.edu/classes/wi19/cse169-a/slides/">https://cseweb.ucsd.edu/classes/wi19/cse169-a/slides/</a></p>
<p>[8] Bayramlı, <em>Cok Degiskenli Calculus - Ders 4</em></p>
          <div id="container-d84f574876e65b2d8f0c7bae784c22b3"></div>

          <br/><a href="../index.html">Yukarı</a>
        </section>          
      </div>
    </body>
</html>
