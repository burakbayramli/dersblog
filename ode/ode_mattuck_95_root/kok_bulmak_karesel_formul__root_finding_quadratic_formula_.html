<h1>Kök Bulmak, Karesel Formül (Root Finding, Quadratic Formula)</h1>
<!DOCTYPE html>
<html>
  <head>
    <title>Kök Bulmak, Karesel Formül (Root Finding, Quadratic Formula)
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
<script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
</script>
</head>

<p>$$ ax^2 + bx + c = 0$$</p>
<p>Yukarıdaki gibi bir formülü çözmek için, lise matematiğinden
hatırlayabileceğimiz aşağıdaki formül kullanılır.</p>
<p>$$ x = \frac{-b \pm \sqrt{b^2-4ac}}{2a} $$</p>
<p>Böylece denklemin kökleri bulunur, karesel durumda $(x-r_1)(x-r_2)=0$,
$r_1,r_2$ iki tane köktür.</p>
<p>Çözümü türetmek için kullanacağımız yöntem, "kareyi tamamlama (completing
the square)" yöntemi. Bu yönteme göre, c değerini denklemin solundan,
sağına atıyoruz, ve öyle bir yeni c değeri buluyoruz ki, karesel denklemin
tek bir kökü oluyor. Tek kökü olan karesel denklemleri biliyoruz, $x^2 +
6x + 9 = 0$ gibi bir denklem, tek kökü olan bir denklemdir.</p>
<p>Gelelim çözüm türetilmesine.. iki üstteki förmül ile başlayalım, iki tarafı
a ile bölelim. Elimize aşağıdaki sonuç gelecek.</p>
<p>$$ x^2 + \frac{b}{a}x + \frac{c}{a} $$</p>
<p>$c/a$ değerini sağ tarafa taşıyalım. </p>
<p>$$ x^2 + \frac{b}{a}x = -\frac{c}{a} $$</p>
<p>Şimdi, kareyi tamamlama yöntemi ile, iki tarafa da aşağıdaki değeri ekleyelim.</p>
<p>$$ \bigg( \frac{b}{2a} \bigg)^2 $$</p>
<p>Böylece, aşağıdaki işlem serisini başlatmış olacağız.</p>
<p>$$ x^2 + \frac{b}{a}x + \bigg( \frac{b}{2a} \bigg)^2 = 
-\frac{c}{a} + \bigg( \frac{b}{2a} \bigg)^2 $$</p>
<p>$$ \bigg( x + \frac{b}{2a} \bigg)^2 = 
-\frac{c}{a} + \frac{b^2}{4a^2}
 $$</p>
<p>$$ \bigg( x+ \frac{b}{2a} \bigg)^2 = \frac{b^2 - 4ac}{4a^2} $$</p>
<p>İki tarafın karekökünü alırsak: </p>
<p>$$ x + \frac{b}{2a} = \pm \frac{\sqrt{b^2 - 4ac}}{2a}  $$</p>
<p>ya da</p>
<p>$$ x = -\frac{b}{2a} \pm \frac{\sqrt{b^2 - 4ac}}{2a} $$</p>
<p>İşte bu formüle karesel formül denir, ve normalde şöyle yazılır. </p>
<p>$$ x = \frac{-b \pm \sqrt{b^2-4ac}}{2a} $$</p>
<ul>
<li>ve - işareti, elimizde 'iki' sonuç var demektir, yani elimizdeki
sayılardan biri</li>
</ul>
<p>$$ x = \frac{-b + \sqrt{b^2-4ac}}{2a} $$</p>
<p>Öteki de </p>
<p>$$ x = \frac{-b - \sqrt{b^2-4ac}}{2a} $$</p>
<p>olacak.</p>
<p>Örnek</p>
<p>$a=3,b=3,c=5$, </p>
<pre><code class="python">a=1.0;b=3.0;c=1.0
tmp=np.sqrt((b**2)-(4.0*a*c))
print (-b-tmp) / (2.0 * a)
print (-b+tmp) / (2.0 * a)
</code></pre>

<pre><code>-2.61803398875
-0.38196601125
</code></pre>

<p>Kütüphane çağrısı ile</p>
<pre><code class="python">print np.roots([a, b, c])
</code></pre>

<pre><code>[-2.61803399 -0.38196601]
</code></pre>

<p>Sayısal Yöntemler</p>
<p>Eğer analitik bir şekilde $f(x)=0$'da kök bulmak mümkün değilse, sayısal
yöntemler kullanılabilir. Newton'un yöntemi (Newton's method) bunlardan
biri, bu yöntem $f(x)$ karesel, küpsel, ne kadar çetrefil olursa olsun
kullanılabilir. Diyelim ki $f(x)$'in köklerinden birini $x_0$ olarak
tahmin ediyoruz. Bu tahmin etrafında fonksiyonun Taylor açılımı [1,
sf. 175],</p>
<p>$$ f(x) = f(x_0) + f'(x_0)(x-x_0) + ...$$</p>
<p>Kök aradığımız için $f(x)=0$ yaparız, ve $x$'i bir tarafa alacak şekilde
tekrar düzenleriz (ayrıca noktalı kısmı atarız çünkü belli bir yaklaşık
temsil ile yetinmeye karar verdik), </p>
<p>$$ 0 = \frac{f(x_0)}{f'(x_0)} + x-x_0$$</p>
<p>$$ x = x_0 - \frac{f(x_0)}{f'(x_0)} $$</p>
<p>Bu denklemi $x_0$'i baz alarak bir sonraki $x$'i hesaplayacak bir formül
gibi görebiliriz, </p>
<p>$$ x_1 = x_0 - \frac{f(x_0)}{f'(x_0)} $$</p>
<p>Genel olarak</p>
<p>$$ x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)} $$</p>
<p>Yani bir $x_0$ tahmini ile başlıyoruz, oradan $x_1$ elde ediyoruz, onu geri
verip $x_2$ elde ediyoruz, böyle devam ediyor.</p>
<p>Not: yöntemin işlemesi için $f(x)$'in türevi $f'(x)$ gerekiyor, fakat çoğu
zaman türev elde olmaz, o zaman türevi de yaklaşık olarak hesaplayabiliriz, </p>
<p>$$ f'(x) \approx \frac{f(x + \mathrm{d} x) - f(x)}{\mathrm{d} x}$$</p>
<p>Türev yaklaşık olarak hesaplandığında Newton'un Yöntemi ismi değiştirilip
Sekant Yöntemi (Secant Method) ismi kullanılıyor.</p>
<p>Örnek</p>
<p>$$ x^2 + 3 x + 1 = 0$$ formülünün köklerini bulalım. </p>
<pre><code class="python">def newton(f, x, dfdx=None, eps=1e-6):
    if dfdx is None: 
        delta = eps**0.5
    while True:
        fx = f(x)
        # turev bilinmiyorsa onu da sayisal hesapla
        if dfdx is None:
            dx = delta*x
            if abs(dx) &lt; delta: dx = delta
            df = (f(x+dx) - fx)/dx
        else:
            df = dfdx(x)
        dx = -fx/df
        x += dx
        if abs(dx) &lt; eps: return x

a=1.0;b=3.0;c=1.0

def f1(x): return a*(x**2.0) + b*x + c
print newton(f1,0.0) # baslangic 0'da
print newton(f1,-3.0) # farkli noktadan baslatalim

# bilinen turev 
def df1(x): return 2*a*x + b
print '\n',newton(f1,0.0,df1)
print newton(f1,-3.0,df1) 

</code></pre>

<pre><code>-0.381966010827
-2.61803398875

-0.38196601125
-2.61803398875
</code></pre>

<p>Çok Boyutlu Newton'un Yöntemi</p>
<p>Çok boyutta Taylor açılımı,</p>
<p>$$ 
0 = f(x_i + \Delta x_i) = f(x_i) + J(x_i) \cdot \Delta x_i + ... 
$$</p>
<p>$x_i$ bir $N$ boyutlu vektör, ve $J$ Jacobian matrisi</p>
<p>$$ 
J = \left[\begin{array}{rrr}
\frac{\partial f_1}{\partial x_1}  &amp; \dots &amp; \frac{\partial f_1}{\partial x_n} \\
 \vdots &amp; \ddots &amp; \vdots \\
\frac{\partial f_N}{\partial x_1}  &amp; \dots &amp; \frac{\partial f_n}{\partial x_N} 
\end{array}\right]
$$</p>
<p>$\Delta x_i$ adımlarını hesaplamak için,</p>
<p>$$  -f(x_i) =  J(x_i) \cdot \Delta x_i  $$</p>
<p>$$  -f(x_i)J(x_i)^{-1} = \Delta x_i  $$</p>
<p>Üstte ters alma işlemi yapıldı fakat çoğunlukla Gaussian eliminasyon
kullanılarak bu pahalı ters alma işleminden kaçınılmaya uğraşılır.</p>
<p>O zaman güncellemeyi</p>
<p>$$ x_{i+1} = x_i + \Delta x_i $$</p>
<p>olarak özyineli bir şekilde yapabiliriz.</p>
<p>İkiye Bölme Yöntemi (Bisection Method)</p>
<p>Bu yöntemle kök araması belli $x$ aralıkları içinde yapılır, her aralığın
orta noktasının $f(x)=0$'a ne kadar yaklaştığı kontrol edilir, eğer
yaklaşma yoksa aralık ikiye bölünerek sıfıra daha yaklaştıracak parça
içinde devam edilir. Parçalar bölündüğü için $O(\log)$ hızında sonuca
ulaşmak mümkündür.</p>
<pre><code class="python">def bisect(f, a, b, eps=1e-6):
     if f(a) &gt; 0: # swap a and b
          (a, b) = (b, a)
     xmid = None
     while np.abs(a - b) &gt; eps:
         xmid = (a+b)/2.0
         if f(xmid) &lt; 0:
             a = xmid
         else:
             b = xmid
     return xmid

print bisect(f1,-5.0,0.0) 
print bisect(f1,-2.0,0.0) 
</code></pre>

<pre><code>-2.618034482
-0.381966590881
</code></pre>

<p>Dikkat, hem Newton hem de ikiye bölme yönteminde bazı patalojik durumlar
ortaya çıkabiliyor, bunlara karşı tetikte olunmalı, detaylar için [2, sf. 71]</p>
<p>Kaynaklar </p>
<p>[1] Creighton, <em>Numerical Methods</em></p>
<p>[2] Kincaid, <em>Numerical Analysis</em></p>