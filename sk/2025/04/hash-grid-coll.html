
<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
   <script type="text/javascript"
       src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
   </script>
   <script async="async" data-cfasync="false" src="//pl22489825.profitablegatecpm.com/d84f574876e65b2d8f0c7bae784c22b3/invoke.js"></script>

   <link rel="stylesheet" type="text/css" media="screen" href="https://burakbayramli.github.io/css/style.css">
  </head>
    <body>
      <div id="header_wrap" class="outer">
        <header class="inner">
          <h1 id="project_title">
            <a href="https://burakbayramli.github.io" style="text-decoration:none; color:inherit;">dersblog</a>
          </h1>
          <h2 id="project_tagline"></h2>          
        </header>
      </div>
      <div id="main_content_wrap" class="outer">        
        <section id="main_content" class="inner">
        <h1></h1>
<h1>Geometrik Anahtarlama (Spatial Hashing) ve Izgara (Grid) ile En Yakın Noktaları Bulmak</h1>

<p>Grafik, fiziksel simülasyonlarda pek çok sayıda obje 3 boyutlu ortamda dünyaya
salınıp, ayrı ayrı onlara fiziksel kurallar uygulanır ve nereye geldiklerine
bakılır. Bu hesap sırasında objelerin birbirine çarpıp çarpmadığını hesaplamak
gerekir fakat böyle bir hesap, eğer mesela $n$ tane obje var ise, her görüntü
karesinde her $n$ tane objenin her $n-1$ diğer objenin yakınında olup olmadığı
kontrolü anlamına gelir, ki hesapsal yük $O(n^2)$ olurdu. Eğer $n$ milyonlar ise
bu ağır bir yüktür.</p>

<p>Benzer bir alandaki ihtiyaç sıvı akışı simülasyonlarında; bu yöntemlerin
bazıları için her parçacığın etrafındaki $R$ çapında bir daire / küre içine
düşen komşuları bulmak gerekebiliyor. Bu hesabın da hızlı bir şekilde
yapılabilmesi lazım.</p>

<p>Izgara (Grid) Bazlı Yöntem</p>

<p>İlk yöntem ızgara bazlı. Her parçacık için $R$ yakınlıktaki tüm diğer
parçacıkları bulmak istiyoruz. Bu durumda en basit, ve en etkili yollardan biri
tüm kordinat sistemini eşit parçalara, ``ızgaralara'' bölerek her parçacığı
içine düştüğü yeterince büyük bir bölüme atamak, öyle ki ızgara indisi i,j,k
üzerinden o hücrede hangi parçacıkların olduğu çok hızlı bir şekilde
bulunabilsin.</p>

<p><img src="algs_073_hash_03.png" alt="" /></p>

<p><img src="algs_073_hash_04.jpg" alt="" /></p>

<p>Artık bir parçacığın komşularını bulmak gerektiğinde o parçacığın hücre indisini
alıp bir yukarı, bir sağa, vs. şeklinde üç boyutta tüm 27 tane mümkün komşu
(içinde olduğumuz dahil olarak) ızgara hücresine bakarak oradaki parçacıkları
toplamak ve bunların $R$ kadar yakın olanı komşularını almak yeterli
oluyor. Altta bir örneği görüyoruz.</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.linalg</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">lin</span><span class="o">,</span><span class="w"> </span><span class="nn">itertools</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">mmin</span><span class="p">,</span><span class="n">mmax</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">200</span><span class="p">;</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">BN</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mmax</span><span class="o">-</span><span class="n">mmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">R</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="c1"># tum parcaciklar her parcacik indisini, hangi izgara hucresinde oldugunu, ve</span>
<span class="c1"># kordinatlarini bilir</span>
<span class="n">balls</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">mmin</span><span class="p">,</span> <span class="n">mmax</span><span class="p">,</span> <span class="n">BN</span><span class="p">)</span>

<span class="c1"># her izgara hucresindeki parcaciklari tuttugumuz yer, anahtar</span>
<span class="c1"># [i,j,k] seklinde izgara indisi, deger liste</span>
<span class="n">grid_hash</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">mmin</span><span class="p">,</span><span class="n">mmax</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">mmin</span><span class="p">,</span><span class="n">mmax</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">mmin</span><span class="p">,</span><span class="n">mmax</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">])</span>
    <span class="c1"># bir kordinatin hangi izgara hucresine dustugunu hesapla </span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="p">)</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="p">)</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bins</span><span class="p">)</span>
    <span class="n">ball</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;pos&#39;</span><span class="p">:</span><span class="n">p</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">yi</span><span class="p">,</span><span class="n">zi</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">balls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ball</span><span class="p">)</span>
    <span class="n">grid_hash</span><span class="p">[(</span><span class="n">xi</span><span class="p">,</span><span class="n">yi</span><span class="p">,</span><span class="n">zi</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ball</span><span class="p">)</span>

<span class="c1"># bir parcacigin tum komsularini bul, anahtari parcacik indisi degeri</span>
<span class="c1"># parcacik objesi olan bir esleme / sozluk icinde donduruyoruz ki</span>
<span class="c1"># boylece &quot;bu komsu var mi yok mu?&quot; sorusu hizla sorulabiliyor</span>
<span class="c1"># (anahtar varligini kontrol cok hizlidir)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_neighbors</span><span class="p">(</span><span class="n">ball</span><span class="p">):</span>
    <span class="c1"># komsulari sozluk olarak dondur alan hizli sekilde kontrol</span>
    <span class="c1"># edebilir, anahtar komsu kimligi</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">cx</span><span class="p">,</span><span class="n">cy</span><span class="p">,</span><span class="n">cz</span> <span class="o">=</span> <span class="n">ball</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span>
    <span class="c1"># 3d izgara hucresinin etrafindaki tum hucrelere bak, bunlar</span>
    <span class="c1"># icinde oldugumuz dahil 27 tane, sag, sol, alt, ust, vs, tum</span>
    <span class="c1"># yonlere bakiyoruz</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">xa</span><span class="p">,</span><span class="n">ya</span><span class="p">,</span><span class="n">za</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span>  <span class="p">)):</span>
        <span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">,</span><span class="n">nz</span> <span class="o">=</span> <span class="n">cx</span><span class="o">+</span><span class="n">xa</span><span class="p">,</span><span class="n">cy</span><span class="o">+</span><span class="n">ya</span><span class="p">,</span><span class="n">cz</span><span class="o">+</span><span class="n">za</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">,</span><span class="n">nz</span><span class="p">)</span> <span class="ow">in</span> <span class="n">grid_hash</span><span class="p">:</span>
            <span class="n">tn</span> <span class="o">=</span> <span class="n">grid_hash</span><span class="p">[(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">,</span><span class="n">nz</span><span class="p">)]</span>
        <span class="c1"># bulduklarini sonuca ekle</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tn</span><span class="p">:</span> <span class="n">neighbors</span><span class="p">[</span> <span class="n">n</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">neighbors</span>


<span class="n">tp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fn</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">b1</span> <span class="ow">in</span> <span class="n">balls</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">b2</span> <span class="ow">in</span> <span class="n">balls</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">b1</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">b2</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]:</span> <span class="k">continue</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">lin</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b1</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">b2</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">],</span><span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">neigh</span> <span class="o">=</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>
    <span class="c1"># izgara yontemi komsu diyor ve oyle</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">R</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b2</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">neigh</span><span class="p">):</span> <span class="n">tp</span><span class="o">+=</span><span class="mi">1</span>        
    <span class="c1"># yontem komsu degil diyor ve oyle</span>
        <span class="k">elif</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="n">R</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b2</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">neigh</span><span class="p">):</span> <span class="n">tn</span><span class="o">+=</span><span class="mi">1</span>
    <span class="c1"># yontem komsu diyor ve ama oyle degil</span>
        <span class="k">elif</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="n">R</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b2</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">neigh</span><span class="p">):</span> <span class="n">fp</span><span class="o">+=</span><span class="mi">1</span>
    <span class="c1"># yontem komsu degil diyor ve oyle degil</span>
        <span class="k">elif</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">R</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b2</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">neigh</span><span class="p">):</span> <span class="n">fn</span><span class="o">+=</span><span class="mi">1</span>

<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;dogru pozitif&#39;</span><span class="p">,</span> <span class="n">tp</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;dogru negatif&#39;</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span>

<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;yanlis pozitif&#39;</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;yanlis negatif&#39;</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>
</code></pre>
</div>

<pre><code>dogru pozitif 148
dogru negatif 38980
yanlis pozitif 672
yanlis negatif 0
</code></pre>

<p>Sonuçlara bakınca komşu değil denilen hiçbir top komşu değil, bunu görüyoruz. Bu
önemli çünkü onları elemek mümkün değil. Komşu denilenler arasında bazı
yanlışlar var ama onlar elenebilir. Komşu olmayan onbinlerce top komşu olmayacak
şekilde etiketlendi, bu güzel.</p>

<p>Performans bakımından iyi bir sonuç beklemek gerekir, üstteki kodda her kenarı
$R=20$ üzerinden 1000 tane hücre yaratıldı ve bunların hepsine bakmak yerine
sadece en yakın olan 27 tanesine direk sözlük erişimi üzerinden bakıyoruz.</p>

<p>Yanlış pozitif çıkması mümkün. Niye? Çünkü mesela iki boyutta üzerinde olduğumuz
hücreyi düşünürsek onun en sağ ucunda olsak, üst sağımızdaki komşu hücrenin yine
en üst sağında olan parçacık kenarları $R$ olan bir üçgenin hipotenüsü kadar
bizden uzaktır ki bu $R$'den büyüktür. Problem değil az sayıda olan bu noktaları
kaba kuvvet hesabı ile elemek gayet rahat.</p>

<p>Aynı işi yapan C++ kodunu <code>geogrid.cpp</code> içinde bulabiliriz.</p>

<p>Yerelliğe Hassas Böleç (Locality Sensitive Hashing, -LSH-)</p>

<p>Böleç tekniğini de kullanabiliriz. Öyle bir sihirli fonksiyonumuz olsun ki her
kordinat için bir anahtar değer üretsin ve birbirine yakın kordinatlar için bu
değer aynı olsun. Böylece basit eşitlik kontrolü ile iki kordinatın birbirine
yakın olup olmadığını hemen anlayabilirdik. Tabii daha detaylı kontrol için
böleçleri aynı olan kordinatları daha detaylı teste tabi tutardık, ama detaylı
kontrolün yapılacağı obje sayısını çok daha azaltmış olurduk.</p>

<p>Bu alandaki tekniklerden biri LSH tekniği. LSH ile çok boyutlu bir kordinat
sistemindeki noktaların yaklaşık olarak birbirine yakın olup olmadığını böleç
üzerinden hesaplayabiliyoruz. En yaygın LSH yaklaşımının temeli rasgele
izdüşümdür (random projection). [3]'te anlatıldığı gibi rasgele izdüşümün ilginç
bir özelliği mesafeleri koruması, yani orijinal kordinat sistemindeki noktalar
birbirine uzaksa yansıtıldıktan sonra da uzak kalmaya meyilliler.</p>

<p>Bunu herhangi bir (yani rasgele) 2 boyutlu düzlem üzerinde yansıtılan alttaki
noktalarda görebiliriz. Uzak olan noktalar düzlem uzerinde hala birbirine uzak.</p>

<p><img src="algs_073_hash_01.png" alt="" /></p>

<p>Tabii ki her (rasgele) düzlem her iki orijinal nokta arasındaki uzaklığı
mükemmel olarak göstermeyebilir. Fakat, eğer birkaç tane farklı düzleme yapılan
yansımların bir birleşiminden bir ölçüt / anahtar yaratabilirsek, o zaman bu
ölçüt ile bazı hızlı sonuçlara varabiliriz.</p>

<p>Alttaki yaklaşımda 2 boyuta yansıtma yapılacak. Bu yansıtma yeni reel sayısal
değerler ortaya çıkartır, bölec için bize ayrıksal ``kutular'' lazım, bu
kutuları şimdi göreceğimiz yöntem 0'dan büyük olma ya da olmama üzerinden
tanımlamış.</p>

<p><img src="algs_073_hash_02.png" alt="" /></p>

<p>Yani 2. boyuta indirgedikten sonra her eksen üzerinde üstteki irdeleme
yapılıyor, nokta sıfırdan büyük mü küçük mü? Bu evet / hayır sonuçlar yanyana
koyuluyor, ve 10, 01, vs şeklinde bitlerden oluşan bir sayı ortaya çıkıyor. Bu
sayıyı onluğa çevirip artık direk karşılaştırma için kullanabiliriz.</p>

<p>Altta üç tane örnek vektör görüyoruz. Bu vektörler bir şarkının ses
seviyelerini, bir müşterinin yer, alışveriş, gezinti bilgilerini temsil ediyor
olabilir. Acaba bu vektörler birbirine ne kadar yakın? Rasgele bir matris
\verb!projections! içinde (rasgele izdüşüm için her ögesi $N(0,1)$ dağılımından
gelen bir matris üretmek yeterlidir, gerçi altta bunu kütüphane çağrısı ile
yapmadık, [2] ile sonuçlar uysun diye direk oradan aldık),</p>

<div class="codehilite">
<pre><span></span><code><span class="n">vec1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.99137472</span><span class="p">,</span> <span class="mf">0.61572851</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.37733555</span><span class="p">,</span> <span class="mf">0.0363575</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.71647706</span><span class="p">]])</span>
<span class="n">vec2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.16737788</span><span class="p">,</span> <span class="mf">0.83147812</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.06947369</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.48174425</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.60276846</span><span class="p">]])</span>
<span class="n">vec3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.9074722</span><span class="p">,</span> <span class="mf">0.75953396</span><span class="p">,</span> <span class="mf">1.10696926</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8773451</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.11589595</span><span class="p">]])</span>

<span class="n">projections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.58834302</span><span class="p">,</span> <span class="mf">0.24020825</span><span class="p">,</span> <span class="mf">2.21323827</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.21147486</span><span class="p">,</span> <span class="mf">1.18477223</span><span class="p">],</span>\
                        <span class="p">[</span><span class="o">-</span><span class="mf">0.31146359</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.88214137</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.37489443</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.58475914</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.57121651</span><span class="p">]])</span>
</code></pre>
</div>

<p>Birinci vektörü rasgele düzleme yansıtıyoruz,</p>

<div class="codehilite">
<pre><span></span><code><span class="nb">print</span> <span class="p">(</span><span class="n">vec1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">projections</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
</code></pre>
</div>

<pre><code>(1, 5)
[[-2.12704963  0.39583023]]
</code></pre>

<p>Her öğeyi sıfırdan büyük olma / olmama filtresinden geçiriyoruz,</p>

<div class="codehilite">
<pre><span></span><code><span class="nb">print</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">projections</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span>  <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">projections</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>  <span class="p">)</span>
</code></pre>
</div>

<pre><code>[[False  True]]
01
</code></pre>

<p>Diğer vektörler için de aynı işlem,</p>

<div class="codehilite">
<pre><span></span><code><span class="nb">print</span> <span class="p">(</span>  <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec2</span><span class="p">,</span> <span class="n">projections</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>  <span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span>  <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec3</span><span class="p">,</span> <span class="n">projections</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>  <span class="p">)</span>
</code></pre>
</div>

<pre><code>01
11
</code></pre>

<p>Üstteki sonuçlara bakarak <code>vec1</code> ve <code>vec2</code> 'nin birbirine <code>vec2</code> ve
<code>vec3</code> ün birbirine olduğundan daha yakın olacağını
kestirebiliriz. Kosinüs yakınlık hesabını bu vektörler üzerinde
uygulayınca bunun doğrulandığını görüyoruz,</p>

<div class="codehilite">
<pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cosine_sim</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec2</span><span class="p">))</span>

<span class="nb">print</span> <span class="p">(</span><span class="n">cosine_sim</span><span class="p">(</span><span class="n">vec1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vec2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>   
<span class="nb">print</span> <span class="p">(</span><span class="n">cosine_sim</span><span class="p">(</span><span class="n">vec1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vec3</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>   
<span class="nb">print</span> <span class="p">(</span><span class="n">cosine_sim</span><span class="p">(</span><span class="n">vec2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vec3</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</code></pre>
</div>

<pre><code>0.6524342023889728
0.5610062492540248
0.1169500241078299
</code></pre>

<p>Tekniğin sezgisel temeli eğer iki nokta tamamen birbirine yakın ise, yani
orijine olan konumları mükemmel korelasyon halinde, o zaman bu teknikle aynı
kutuya düşme olasılıkları artıyor. İşin içinde rasgelelik olduğu için ve bir
noktayı pek çok farklı düzlemlere yansıttığımız için aynı kutuya düşme ihtimali
oldukca azalıyor, sadece hakikaten yakın olan noktalar aynı kutuya
düşüyorlar. Eğer o noktada hatalar ortaya çıkarsa, yaygın bir yaklaşım birden
yansıtma seçeneklerini gruplar altında toplamak ve en az bir grup aynı kutuya
düşmeyi bulmuşsa, o iki noktayı yakın olarak kabul etmek.</p>

<p>Notlar</p>

<p>0'dan küçük ya da büyük irdelemesi kutulamayı sadece iki kutu
üzerinden yapar. Fakat illa iki olması şart değil, <code>numpy.digitize</code>
ile istediğimiz kadar / genişlikte kutular yaratabilirdik.</p>

<p>Bir diğer konu bölecin yakın olan bazı noktalar için mükemmel olmayacağı. Bu
durumda bir çözüm ikinci, hatta üçüncü yansıtma matrisleri üzerinden ikinci,
üçüncü böleçleme grupları yaratmak, eğer böleç değerleri 1'inci ya da 2'inci ya
da 3'üncü, vs. gruplarda aynı ise iki noktayı yakın kabul etmek. Bu yöntem
yakınlık kontrolüne ek olarak yakın noktaların listesini almak için de faydalı,
bir sözlük içinde her böleç değeri için bir nokta listesi tutulur, eğer birden
fazla yansıtma yapılmışsa, bu sözlüklerden iki, hatta üç tane olabilir. Bir
noktanın komşularını almak istersek her sözlükte bu kordinatın geo böleç
değerine bakarız, ve alınan komşuları bir özgünlük filtresinden geçirerek nihai
sonucu döndürürüz. Bu yaklaşım parçacık simülasyonları ile uğraşanlar için
faydalı olabilir.</p>

<p>Bir diğer not, rasgele izdüşüm çoğunlukla ``boyut küçültme (dimensionality
reduction)'' konusu olarak gösterilir, fakat boyut arttırma da mümkün
olabilir. Özellikle üç boyutlu durumda iken zaten boyut sayısı azdır, fakat hala
pek çok açıdan iki noktaya bakabilmek isteriz, bu sebeple izdüşüm matrisi üçten
fazla boyut ta içerebilir.</p>

<p>Test</p>

<p>Altta üç tane farklı rasgele izdüşüm üzerinden anahtarlayan bir kod
görüyoruz. Bir 3 boyutlu kordinat sisteminde rasgele yerlerde toplar yarattık,
bunların bazıları birbirine yakın, bazıları değil, kodda LSH ile geometrik
yakınlığı gerçek yakınlık ile ne kadar benzediğini kontrol ediyoruz. LSH
anahtarı üç sözlükte kontrol ediliyor.</p>

<p>Önce tüm topları anahtarlıyoruz ve sözlüğe koyuyoruz. Sonra tüm topların birbiri
ile olan mesafesini ayrı ayrı teker teker külfetli yoldan yapıyoruz, ve bölecin
bu durum hakkında ne söylediğine bakıyoruz. Pozitif böleç(ler) yakın diyor,
negatif böleç uzak diyor anlamında, tabii yakınlık ve uzaklık böleç anahtar
değerinin aynı olup olmadığı ile ölçülüyor.</p>

<p>Kontrolün doğru pozitif bulması mesela geo anahtarın yakın dediğinin gerçekten
de yakın olması. Yanlış negatif tam tersi, anahtar uzak diyor ama aslında toplar
yakın.</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span><span class="o">,</span><span class="w"> </span><span class="nn">datetime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.linalg</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">lin</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">mmin</span><span class="p">,</span><span class="n">mmax</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">200</span>
<span class="n">B</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span> <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">mmax</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">balls</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">geo_hash_list</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">mmin</span><span class="p">,</span><span class="n">mmax</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">mmin</span><span class="p">,</span><span class="n">mmax</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">mmin</span><span class="p">,</span><span class="n">mmax</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">])</span>
    <span class="n">balls</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;pos&#39;</span><span class="p">:</span><span class="n">p</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="n">b</span><span class="p">})</span>

<span class="n">k</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">bnum</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">500.0</span><span class="p">,</span><span class="mf">500.0</span><span class="p">,</span><span class="n">bnum</span><span class="p">)</span>

<span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">spatial_hash1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">X1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P1</span><span class="p">)</span>
    <span class="n">h1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">h1</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

<span class="n">P2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">spatial_hash2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">X2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P2</span><span class="p">)</span>
    <span class="n">h2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">X2</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">h2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

<span class="n">P3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">spatial_hash3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">X3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P3</span><span class="p">)</span>
    <span class="n">h3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">X3</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">h3</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

<span class="n">tp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fn</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">balls</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">b2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">balls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">lin</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b1</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">b2</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">])</span>
        <span class="n">h11</span> <span class="o">=</span> <span class="n">spatial_hash1</span><span class="p">([</span><span class="n">b1</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]])</span>
        <span class="n">h12</span> <span class="o">=</span> <span class="n">spatial_hash1</span><span class="p">([</span><span class="n">b2</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]])</span>
        <span class="n">h21</span> <span class="o">=</span> <span class="n">spatial_hash2</span><span class="p">([</span><span class="n">b1</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]])</span>
        <span class="n">h22</span> <span class="o">=</span> <span class="n">spatial_hash2</span><span class="p">([</span><span class="n">b2</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]])</span>
        <span class="n">h31</span> <span class="o">=</span> <span class="n">spatial_hash3</span><span class="p">([</span><span class="n">b1</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]])</span>
        <span class="n">h32</span> <span class="o">=</span> <span class="n">spatial_hash3</span><span class="p">([</span><span class="n">b2</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">R</span> <span class="ow">and</span> <span class="p">(</span><span class="n">h11</span><span class="o">==</span><span class="n">h12</span> <span class="ow">or</span> <span class="n">h21</span><span class="o">==</span><span class="n">h22</span> <span class="ow">or</span> <span class="n">h31</span><span class="o">==</span><span class="n">h32</span><span class="p">):</span> <span class="n">tp</span> <span class="o">+=</span> <span class="mi">1</span>        
        <span class="k">elif</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">R</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">h11</span><span class="o">==</span><span class="n">h12</span> <span class="ow">or</span> <span class="n">h21</span><span class="o">==</span><span class="n">h22</span> <span class="ow">or</span> <span class="n">h31</span><span class="o">==</span><span class="n">h32</span><span class="p">):</span> <span class="n">tn</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">R</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">h11</span><span class="o">==</span><span class="n">h12</span> <span class="ow">or</span> <span class="n">h21</span><span class="o">==</span><span class="n">h22</span> <span class="ow">or</span> <span class="n">h31</span><span class="o">==</span><span class="n">h32</span><span class="p">):</span> <span class="n">fn</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">R</span> <span class="ow">and</span> <span class="p">(</span><span class="n">h11</span><span class="o">==</span><span class="n">h12</span> <span class="ow">or</span> <span class="n">h21</span><span class="o">==</span><span class="n">h22</span> <span class="ow">or</span> <span class="n">h31</span><span class="o">==</span><span class="n">h32</span><span class="p">):</span> <span class="n">fp</span><span class="o">+=</span><span class="mi">1</span>

<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;dogru pozitif&#39;</span><span class="p">,</span> <span class="n">tp</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;dogru negatif&#39;</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span>

<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;yanlis pozitif&#39;</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;yanlis negatif&#39;</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>
</code></pre>
</div>

<pre><code>dogru pozitif 128
dogru negatif 38374
yanlis pozitif 1278
yanlis negatif 20
</code></pre>

<p>Tabii ki istediğimiz doğru olan değerlerin yüksek olması. Ama yanlış pozitifin
hala çaresi var, anahtarın yakın dediklerini bir kontrolden daha geçirirsek bu
kontrol yanlış pozitifleri eleyecektir, tabii gene de yanlış pozitiflerin de
toplama kıyasla az olmasını isteriz. Tek problem yanlış negatif, topların çoğu
birbirinden uzakta olduğu için bu yanlıştan dönmek zor, fakat bu tür topların
oldukça az olduğunu görüyoruz.</p>

<p>Asal Sayılar ile Böleç (Hash) Tekniği</p>

<p>Bir diğer böleç bazlı teknik [1]'den. Teknik ile kordinat sistemini $l$
büyüklüğünde kutulara bölüyor, her eksen değerini bu büyüklük ile bölüyoruz,
bölüm sonrası elde edilen sayıyı taban (floor) tamsayıya indirgiyoruz, ardından
her eksen için farklı bir asal sayıyla çarpıp sonuçları XOR ile birleştiriyoruz
(ki XOR yaygın kullanılan bir böleç birleştirme yaklaşımı).</p>

<div class="codehilite">
<pre><span></span><code><span class="n">l</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span> <span class="o">=</span> <span class="mi">73856093</span><span class="p">,</span> <span class="mi">19349663</span><span class="p">,</span> <span class="mi">83492791</span>

<span class="n">x1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">33</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
<span class="n">x2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">31</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">14</span><span class="p">]</span>
<span class="n">x3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">44</span><span class="p">,</span><span class="mi">19</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">spatial_hash</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">ix</span><span class="p">,</span><span class="n">iy</span><span class="p">,</span><span class="n">iz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">l</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">l</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">l</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ix</span><span class="o">*</span><span class="n">p1</span><span class="p">)</span> <span class="o">^</span> <span class="nb">int</span><span class="p">(</span><span class="n">iy</span><span class="o">*</span><span class="n">p2</span><span class="p">)</span> <span class="o">^</span> <span class="nb">int</span><span class="p">(</span><span class="n">iz</span><span class="o">*</span><span class="n">p3</span><span class="p">))</span> <span class="o">%</span> <span class="n">n</span>

<span class="nb">print</span> <span class="p">(</span><span class="n">spatial_hash</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">spatial_hash</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">spatial_hash</span><span class="p">(</span><span class="n">x3</span><span class="p">))</span>
</code></pre>
</div>

<pre><code>1
1
3
</code></pre>

<p>Görüldüğü gibi ilk iki kordinat aynı böleç anahtarına düştü, ki bu iki kordinat
birbirine yakın.</p>

<p>Genel algoritma şöyle olabilir. Her görüntü karesi için iki faz düşünebiliriz,
ilk fazda tüm objelerin kordinat böleçi hesaplanır, her böleç değeri altında bir
liste vardır, ve her obje anahtarının değerine tekabül eden o listeye
eklenir. İkinci fazda bir objeye bakarken onun üzerinde daha detaylı çarpışma
hesabı gerekip gerekmediğini anlamak için böleç anahtarındaki listeye bakarız,
listede sadece bir öğe var ise çarpışma yok, birden fazla ise o listedeki her
diğer obje için detaylı çarpışma hesabına devam edilebilir.</p>

<p>Bazı istatistikleri toplayalım. Acaba yaklaşım ne kadar başarılı?</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span><span class="o">,</span><span class="w"> </span><span class="nn">datetime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.linalg</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">lin</span>

<span class="n">mmin</span><span class="p">,</span><span class="n">mmax</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">200</span>
<span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span> <span class="o">=</span> <span class="mi">73856093</span><span class="p">,</span> <span class="mi">19349663</span><span class="p">,</span> <span class="mi">83492791</span>
<span class="n">B</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">B</span><span class="o">*</span><span class="mi">20</span>

<span class="k">def</span><span class="w"> </span><span class="nf">spatial_hash</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">ix</span><span class="p">,</span><span class="n">iy</span><span class="p">,</span><span class="n">iz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">R</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">R</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">R</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ix</span><span class="o">*</span><span class="n">p1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">iy</span><span class="o">*</span><span class="n">p2</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">iz</span><span class="o">*</span><span class="n">p3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tmp</span> <span class="o">%</span> <span class="n">n</span>

<span class="n">balls</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">geo_hash_list</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">mmin</span><span class="p">,</span><span class="n">mmax</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">mmin</span><span class="p">,</span><span class="n">mmax</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">mmin</span><span class="p">,</span><span class="n">mmax</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">])</span>
    <span class="n">balls</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;pos&#39;</span><span class="p">:</span><span class="n">p</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="n">b</span><span class="p">})</span>

<span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">balls</span><span class="p">):</span>
    <span class="n">geo_hash_list</span><span class="p">[</span><span class="n">spatial_hash</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">])]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

<span class="n">tp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fn</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">balls</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">b2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">balls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">lin</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b1</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">b2</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">])</span>
        <span class="n">h1</span> <span class="o">=</span> <span class="n">spatial_hash</span><span class="p">(</span><span class="n">b1</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">])</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="n">spatial_hash</span><span class="p">(</span><span class="n">b2</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">R</span> <span class="ow">and</span> <span class="n">h1</span> <span class="o">==</span> <span class="n">h2</span><span class="p">:</span> <span class="n">tp</span> <span class="o">+=</span> <span class="mi">1</span>        
        <span class="k">elif</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">R</span> <span class="ow">and</span> <span class="n">h1</span> <span class="o">!=</span> <span class="n">h2</span><span class="p">:</span> <span class="n">tn</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">R</span> <span class="ow">and</span> <span class="n">h1</span> <span class="o">==</span> <span class="n">h2</span><span class="p">:</span> <span class="n">fp</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">R</span> <span class="ow">and</span> <span class="n">h1</span> <span class="o">!=</span> <span class="n">h2</span><span class="p">:</span> <span class="n">fn</span><span class="o">+=</span><span class="mi">1</span>

<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;dogru pozitif&#39;</span><span class="p">,</span> <span class="n">tp</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;dogru negatif&#39;</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span>

<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;yanlis pozitif&#39;</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;yanlis negatif&#39;</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>
</code></pre>
</div>

<pre><code>dogru pozitif 38
dogru negatif 39634
yanlis pozitif 14
yanlis negatif 114
</code></pre>

<p>Kaynaklar</p>

<p>[1] <a href="https://matthias-research.github.io/pages/publications/tetraederCollision.pdf">Optimized Spatial Hashing for Collision Detection of Deformable Objects</a></p>

<p>[2] Hari, <a href="https://towardsdatascience.com/locality-sensitive-hashing-for-music-search-f2f1940ace23">Locality Sensitive Hashing for Similar Item Search</a>,</p>

<p>[3] Bayramlı, Rasgele İzdüşümü (Random Projection) ile SVD</p>

<p>[4] Slaney, <a href="https://www.slaney.org/malcolm/yahoo/Slaney2008-LSHTutorial.pdf">Locality-Sensitive Hashing for Finding Nearest Neighbors</a></p>

          <div id="container-d84f574876e65b2d8f0c7bae784c22b3"></div>

          <br/><a href="../index.html">Yukarı</a>
        </section>          
      </div>
    </body>
</html>
