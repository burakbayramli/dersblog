<h1>Pandas</h1>
<p>Pandas'ı ilk kez bir CSV dosyasını okumak ve işlemek için
kullanmıştım; numpy bu amacla yazılmamış -rivayete göre ticari ürün
Matlab hala CSV dosyalarını basit bir şekilde okuyamıyor-, ve bazı
belgelere göre Pandas bu işi R'ye benzer şekilde yapabiliyordu. Pandas
kurduktan sonra, alttaki gibi bir kod Pandas noktalı virgül ile
ayrılmış dosyayı söylendiği gibi güzelce okudu,</p>
<pre><code class="python">import pandas as pd, StringIO

s1 = &quot;&quot;&quot;
c;d;a;b
one;0;0;7
one;1;1;6
one;2;2;5
two;0;3;4
two;1;4;3
two;2;5;2
two;3;6;1
&quot;&quot;&quot;

df1 = pd.read_csv(StringIO.StringIO(s1),sep=';')
print df1
     c  d  a  b
0  one  0  0  7
1  one  1  1  6
2  one  2  2  5
3  two  0  3  4
4  two  1  4  3
5  two  2  5  2
6  two  3  6  1
</code></pre>

<p>Not: CSV'yi yazıda gösterebilmek için StringIO uzerinden okuduk, fakat
aslında read_csv ile direk dosyadan da okuyabilirdik.</p>
<p>Güzel... Ama sol tarafta bir takım sayılar var, 0,1,..,6 diye gidiyor,
bunlar nedir? CSV okuyup direk numpy matrisi elde etsek olmaz mıydı?
Bu "ekstra" "gereksiz" şeyleri ne yapacağız? Baştaki amacımız Pandas'i
numpy için bir önyüz gibi kullanmaktı (gerçi np.array(df1)) ile hemen
çevrim yapılabilirdi ama, şimdi, bu ek aşamaya ne gerek var?), fakat
Pandas belgelerini takip ettikçe, ve örnekleri gördükçe bu rakamların,
yanı indisin gerekliği anlaşılmaya başladı.</p>
<p>İndis</p>
<p>Pandas'in en temel iki objesi Series ve DataFrame'in muhakkak bir
indisi vardır. Öyle ki herhangi bir Series, DataFrame için indis
tanımlanmamissa, Pandas otomatik olarak bir indis kendisi yaratır. Bu
indis cok temel, birer birer artan düz sayılar olacaktır (üstteki
gibi) ama muhakkak bir indis olur.</p>
<p>Pandas ile bir kolona erismek istersem bu cok basittir; mesela</p>
<pre><code class="python">print df1['b']
</code></pre>

<pre><code>0    7
1    6
2    5
3    4
4    3
5    2
6    1
Name: b, dtype: int64
</code></pre>

<p>Dikkat, kolona erişince indis de onunla "beraber geldi". Üstte elde
ettiğimiz bir Series objesi, DataFrame'in kolonları Series
objeleridir. Series tek bir kolonu temsil eden bir objedir.</p>
<p>İndis pek çok türlü tipte olabilir. Bir tarih, bir string bile
olabilir. Onu mevcut bir kolon üzerinden kendimiz tanımlayabiliriz,</p>
<pre><code class="python">s2 = &quot;&quot;&quot;
c;d;a;b
2016-01-02;one;0;0;7
2016-01-03;one;1;1;6
2016-01-04;one;2;2;5
2016-01-05;two;0;3;4
2016-01-06;two;1;4;3
2016-01-07;two;2;5;2
2016-01-08;two;3;6;1
&quot;&quot;&quot;

df2 = pd.read_csv(StringIO.StringIO(s2),sep=';', parse_dates=True,index_col=0)
print df2
</code></pre>

<pre><code>
              c  d  a  b
2016-01-02  one  0  0  7
2016-01-03  one  1  1  6
2016-01-04  one  2  2  5
2016-01-05  two  0  3  4
2016-01-06  two  1  4  3
2016-01-07  two  2  5  2
2016-01-08  two  3  6  1
</code></pre>

<p>Sıfırıncı, ilk kolonu indis olarak tanımladık, Pandas'a ayrıca
parse_dates ile bu kolonun içinde "tarihimsi" veriler olduğunu
söyledik ki onları otomatik olarak DateTime objesi haline
getirsin. Böylece tarihsel olarak büyüktür, küçüktür işlemlerini
kullanabiliriz,</p>
<pre><code class="python">print df2[df2.index &gt; '2016-01-06']
</code></pre>

<pre><code>
              c  d  a  b
2016-01-07  two  2  5  2
2016-01-08  two  3  6  1
</code></pre>

<p>İndisi sonradan değiştirmek mümkün. Mesela b kolonunu indisi yapalım,</p>
<pre><code class="python">print df2.reset_index().set_index('b')
</code></pre>

<pre><code>       index    c  d  a

b                      

7 2016-01-02  one  0  0

6 2016-01-03  one  1  1

5 2016-01-04  one  2  2

4 2016-01-05  two  0  3

3 2016-01-06  two  1  4

2 2016-01-07  two  2  5

1 2016-01-08  two  3  6

</code></pre>

<p>Dikkat <code>reset_index()</code> ile mevcut indisi iptal ettik, o indis normal
bir kolon haline geldi. Tabii bir isme sahip olmasi gerekiyordu,
Pandas da ona "index" diye bir isim verdi. Bu isim degistirilebilir
muhakkak.</p>
<p>İndisin esas değeri DataFrame'de yeni bir kolon yaratmak istediğimiz
zaman ortaya çıkar. Diyelim ki bir şekilde elimizde şöyle bir Series
var,</p>
<pre><code class="python">s1 = pd.Series(['x','y','z'], index=[1,2,3])
print s1
</code></pre>

<pre><code>1    x
2    y
3    z
dtype: object
</code></pre>

<p>Bu seriyi tamamen kendimiz, yan bir tarafta apayrı bir şekilde
yarattık. Şimdi bu seriyi bir kolon olarak df1'e ekleyelim. Ne olacak
acaba?</p>
<pre><code class="python">df1['s1'] = s1
print df1
</code></pre>

<pre><code>     c  d  a  b   s1
0  one  0  0  7  NaN
1  one  1  1  6    x
2  one  2  2  5    y
3  two  0  3  4    z
4  two  1  4  3  NaN
5  two  2  5  2  NaN
6  two  3  6  1  NaN
</code></pre>

<p>Pandas seriyi aldı, indisine baktı, ve o indisi df1 ile eşledi, uyan
öğeleri yeni kolon öğesi olarak ekledi, diğerlerini boş bıraktı!</p>
<p>Pandas'in bu özelliği sayesinde zaten formülsel hesaplar çok rahat
yapılabiliyor. Mesela x = d + a + b gibi bir hesabı direk DataFrame
üzerinde yapabiliriz,</p>
<pre><code class="python">df1['x'] = df1.d + df1.a + df1.b
print df1
</code></pre>

<pre><code>     c  d  a  b   s1   x
0  one  0  0  7  NaN   7
1  one  1  1  6    x   8
2  one  2  2  5    y   9
3  two  0  3  4    z   7
4  two  1  4  3  NaN   8
5  two  2  5  2  NaN   9
6  two  3  6  1  NaN  10
</code></pre>

<p>Bu ifadenin çok rahat bir şekilde işleyebilmesinin arkasında yatan sır
kolon erişiminin, toplama işlemlerinin sonucunun hepsinin içinde indis
olan sonuçlar üretmeleri - bu sayede Pandas bu sonucu alıp pat diye
geri DataFrame içine yazabiliyor.</p>
<p>İndis uyumu üzerinden akla gelebilecek her türlü operasyon mümkün;
mesela bir dizin içinde Series objeleri var, onları yanyana yapıştırıp
bir DataFrame oluşturabilirim, Pandas indisleri uyan hücreleri aynı
satıra koyar.</p>
<pre><code class="python">s1 = pd.Series(['x','y','z'], index=[1,2,3])
s2 = pd.Series(['a','b','c'], index=[1,2,3])
s3 = pd.Series(['aa','bb','cc'], index=[1,2,3])
df3 = pd.concat([s1,s2,s3],axis=1)
df3.columns = ['bir','iki','uc']
print df3
</code></pre>

<pre><code>  bir iki  uc

1   x   a  aa

2   y   b  bb

3   z   c  cc
</code></pre>

<p>Aynı şekilde DataFrame'ler de yanyana yapıştırılabilir. </p>
<p>Bu arada Pandas aynen SQL tabanları gibi birleştirme operasyonu
yapabiliyor, yani iki DataFrame'i alıyorum, indis uyumu üzerinden, ya
da sadece bazı kolonların ismini verip kolon uyumu üzerinden iki
DataFrame birleştirilebilir. İşlem oldukça hızlı; bir projede her biri
1 gigabaytlık iki DataFrame'i birleştirip üçüncü bir devasa DataFrame
yaratmıştım bir kez, tamamen hafızada!</p>
<p>Kordinat bazlı (kordinat derken indeks ve kolon, ki indeks hangi tipte
ise o) kalıcı değişimler için</p>
<pre><code class="python">df2.loc['2016-01-05','d'] = 1000
print df2
</code></pre>

<pre><code>              c     d  a  b
2016-01-02  one     0  0  7
2016-01-03  one     1  1  6
2016-01-04  one     2  2  5
2016-01-05  two  1000  3  4
2016-01-06  two     1  4  3
2016-01-07  two     2  5  2
2016-01-08  two     3  6  1
</code></pre>

<p>Sadece tek bir hücre değiştirdik.</p>
<p>Fonksiyonlar</p>
<p>Üstte gördüğümüz formülsel erişim her türlü satırsal işlem için
yeterli olmayabilir. Belki bir Series'in tüm öğleri, ya da
DataFrame'in tüm satırları üzerinde bir fonksiyon işlemesi
gerekir... Burada map ve apply fonksiyonları var; Python'un
fonksiyonel ruhuna uygun bir şekilde satır satır gezinen kod
yazmıyoruz, genel bir geziciye bir fonksiyon geçiyoruz, ve gezici her
satıra / öğeye verilen fonksiyonu uyguluyor.</p>
<p>Diyelim ki bir kolondaki her ögeyi string haline getirip yanına "XX"
ekliyoruz,</p>
<pre><code class="python">def f(x): return str(x)+&quot;XX&quot;

print df1.d.map(f)
</code></pre>

<pre><code>0    0XX

1    1XX

2    2XX

3    0XX

4    1XX

5    2XX

6    3XX

Name: d, dtype: object
</code></pre>

<p>Çok basit fonksiyonlar için Python'un lambda kullanımı var,</p>
<pre><code class="python">print df1.d.map(lambda x: str(x)+&quot;XX&quot;)
</code></pre>

<p>Aynı sonucu verir. Elde edilen sonucun bir Series olduğuna dikkat, bir
indisi var, ve alıp bu Series'i bir DataFrame içine yazabilirdik.</p>
<p>Eğer fonksiyon içinde tüm DataFrame satırına  erişim gerekiyorsa,
apply kullanımı var, apply ona geçilen fonksiyona satır geçer; yani
apply satırları teker teker gezer ve satırlar sırasıyla bizim
verdiğimiz fonksiyonun ilk parametresine "düşer".</p>
<pre><code class="python">print df1.apply(lambda x: str(x.c) + &quot;:&quot; + str(x.d), axis=1)
</code></pre>

<pre><code>0    one:0

1    one:1

2    one:2

3    two:0

4    two:1

5    two:2

6    two:3
</code></pre>

<p>Pivot</p>
<p>Satır olarak tekrar eden iki kolondaki verileri bir tür kordinat
olarak alıp, üçüncü bir kolondaki değere göre bir tablo hücresinde
değer atamak istiyorsak, Pandas paketinin pivot özelliği ise
yarar. Pivot genel bir veri prezentasyon yaklaşımı, Postgres içinde
crosstab diye bir fonksiyon var, fakat kullanımı pek kolay değil.</p>
<pre><code class="python">import numpy as np
from pandas import DataFrame
df=DataFrame({
       'foo': ['one',  'one',  'one',  'two',  'two',  'two'],
       'bar':  [ 'A' ,   'B' ,   'C' ,   'A' ,   'B' ,   'C' ] ,
       'baz':  [ '1',   '2',   '3',   '4',   '5',   '6']
       })
print df
pv = df.pivot('bar', 'foo')
print pv.to_string()
</code></pre>

<p>Sonuc</p>
<pre><code>foo one two
bar       
A     1   4
B     2   5
C     3   6
</code></pre>

<p>Kolonda Liste</p>
<p>DataFrame pek cok Python tipini kabul edebilir, liste de bunlardan biri,</p>
<pre><code class="python">import numpy as np
from pandas import DataFrame
df=DataFrame({
       'foo': ['one',  'one',  'one',  'two',  'two',  'two'],
       'bar':  [ '[2,3]',   '[4,5]', '[6,7]', '[8,9]', '[10,11]', '[12,13]'],
       'baz':  [ [2,3],   [4,5],   [6,7],   [8,9],   [10,11],   [12,13]]
       })
print (df)
</code></pre>

<pre><code class="text">   foo      bar       baz
0  one    [2,3]    [2, 3]
1  one    [4,5]    [4, 5]
2  one    [6,7]    [6, 7]
3  two    [8,9]    [8, 9]
4  two  [10,11]  [10, 11]
5  two  [12,13]  [12, 13]
</code></pre>

<p>Artık <code>bar</code> ve <code>baz</code> kolonları içinde liste var, biri metin bazli
digeri duz Python objesi halinde. Listeleri nasıl geri okuruz?</p>
<pre><code class="python">print (df.iloc[0].baz)
print (type(df.iloc[0].baz))
print (df.iloc[0].bar)
print (type(df.iloc[0].bar))
</code></pre>

<pre><code class="text">[2, 3]
&lt;class 'list'&gt;
[2,3]
&lt;class 'str'&gt;
</code></pre>

<p>İlk durum kolay, liste doğru Python tipinde direk erişip
kullanırız. Eğer liste bir string olarak geliyorsa, onu Python tipine çevirmek
lazım. Burada <code>eval</code> kullanımı önerenler olabilir fakat bu kullanım yavaştır,
ayrıca verilen parametreyi bir Python kodu kabul edip işlettiği için tehlikeli
olabilir. Bu durumda en hızlı ve güvenli çözüm <code>json</code> kullanmak.</p>
<pre><code class="python">import json
res = json.loads(df.iloc[0].bar)
print (res)
print (type(res))
print (res[0])
</code></pre>

<pre><code class="text">[2, 3]
&lt;class 'list'&gt;
2
</code></pre>

<p>Bu yaklaşım işledi çünkü liste kabaca zaten bir JSON formatına
sahiptir, sözlük (dictionary) yok ama liste var. Bu sebeple <code>loads</code>
listeye çevrimi yapabildi.</p>
<p>Dosyalardan Okumak</p>
<p>Üstteki örneklerde <code>StringIO</code> kullandık, ama en basit Pandas kullanımı
aslında <code>df = pd.read_csv('[dosya]')</code> ile direk diskten okumak.</p>
<pre><code class="python">import pandas as pd

df = pd.read_csv('data.csv')
</code></pre>

<p>Burada ilginç bazı ek numaralar da yapılabiliyor, örnek zip içinde olan csv
direk zip üzerinden okunabilir! Mesela <code>test.zip</code> içinde olan <code>test.csv</code>
dosyasını okumak için</p>
<pre><code class="python">import pandas as pd, zipfile
with zipfile.ZipFile('test.zip', 'r') as z:
      df =  pd.read_csv(z.open('test.csv'))
      ... 
</code></pre>

<p>Eğer CSV dosyası dosyası direk, basit ekranda gösterilebilen türden
bir bağlantıysa, o zaman <code>https://...</code> diye giden bağlantıyı
<code>read_csv</code> çağrısına geçmek yeterlidir.</p>
<pre><code class="python">df = pd.read_csv('https://.../data.csv')
</code></pre>

<p>Fakat bazen URL bağlantısı bir 'dosya indirme' aksiyonu tetikler, bu
durumda o indirilen dosyanın 'yakalanması' ve okunması gerekir. Bu
durum için ek hareketler gerekir, mesela Yahoo Finance üzerinde
görelim,</p>
<pre><code class="python">import pandas as pd, urllib.request as urllib2, io

url = &quot;https://query1.finance.yahoo.com/v7/finance/download/AAPL?period1=1492524105&amp;period2=1495116105&amp;interval=1d&amp;events=history&quot;
r = urllib2.urlopen(url).read()
file = io.BytesIO(r)
df = pd.read_csv(file,index_col='Date')
print (df['Adj Close'].tail())
</code></pre>

<pre><code class="text">Date
2017-05-12    37.154709
2017-05-15    37.059498
2017-05-16    37.004768
2017-05-17    35.762302
2017-05-18    36.307369
Name: Adj Close, dtype: float64
</code></pre>

<p>Bunun bir ileri noktasi İnternet üzerinden indirme tetikleyen bir ZIP
bağlantısını hiç diske indirmeden hem yakalamak, hem açmak, sonra
içindeki dosyayı Pandas'a okutmak!</p>
<pre><code class="python">import pandas as pd, datetime
import urllib.request as urllib2
r = urllib2.urlopen(&quot;https://www.filanca.com/test.zip&quot;).read()
file = ZipFile(BytesIO(r))
csv = file.open(&quot;test.csv&quot;)
df = pd.read_csv(csv,sep='\t',header=None)
</code></pre>

<p>Bazi Ayarlar</p>
<p>Ekranda <code>print</code> ile dataframe basınca bazen tüm kolonlar gözükmeyebilir,</p>
<pre><code class="python">import pandas as pd
pd.set_option('display.max_columns', None)
</code></pre>

<p>Kolonun kendisini en büyük halde görmek için</p>
<pre><code class="python">pd.set_option('display.max_colwidth',-1)
</code></pre>

<p>Kaynaklar</p>
<p>http://pandas.pydata.org/pandas-docs/stable/</p>