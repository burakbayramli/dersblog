<!DOCTYPE html>
<html>
  <head>
    <title>Direkli Araba, Ters Sarkaç (Cart Pole, Inverted Pendulum)
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
   <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
   </script>
   <link rel="stylesheet" type="text/css" media="screen" href="https://burakbayramli.github.io/css/style.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1548953794786292"
          crossorigin="anonymous"></script>  
  </head>
    <body>
      <div id="header_wrap" class="outer">
        <header class="inner">
          <h1 id="project_title">
            <a href="https://burakbayramli.github.io" style="text-decoration:none; color:inherit;">dersblog</a>
          </h1>
          <h2 id="project_tagline"></h2>          
        </header>
      </div>
      <div id="main_content_wrap" class="outer">        
        <section id="main_content" class="inner">
        <h1>Direkli Araba, Ters Sarkaç (Cart Pole, Inverted Pendulum)
</h1>

<p>Sadece sağa ve sola giden bir araba üzerinde duran bir direk var. Bu
direğin üzerinde bir kütle var; acaba bu direği sadece arabaya uygulanan
bir $F$ kuvveti ile sağa sola götürerek dengeleyebilir miyiz? Belki
bazılarımız elimiz üzerinde bir sopayı dengelemeye uğraşmışızdır, yapmaya
çalışacağımız buna çok benziyor.</p>
<p><img alt="" src="phy_cartpole_01.png" /></p>
<p>Sistemin hareket denklemlerini modellemek için Lagrange formüllerini
kullanacağız. $L = K - P$ üzerinden,</p>
<p>$$
L = \frac{1}{2} M v_1^2 + \frac{1}{2} m v_2^2 - m g \ell \cos\theta
$$</p>
<p>$v_1$ arabanın hızı, $v_2$ ise sarkacın hızı. $x(t)$ arabanın yerini
belirleyecek. Hızları yer türeviyle değiştirebiliriz, mesela
$v_1^2 = \dot{x}^2$. Sarkacın hızı $v_2$'yi onun yeri üzerinden tanımlamak
gerekiyor, sarkacın yeri nedir? Onun yatay, dikey kordinatlarına bakalım,
dikey $x-\ell\sin\theta$, dikey $\ell\cos\theta$. Genel
$v^2 = v_x^2 + v_y^2$ formülü üzerinden,</p>
<p>$$
v_2^2 = 
\left( \frac{\mathrm{d}}{\mathrm{d} t} (x - \ell\sin\theta) \right)^2 + 
\left( \frac{\mathrm{d}}{\mathrm{d} t} (x - \ell\cos\theta) \right)^2 
$$</p>
<p>$v_2$'yi basitleştirince, </p>
<p>$$
v_2^2 = \dot{x}^2 - 2 \ell \dot{x}\dot{\theta}\cos\theta + \ell^2 \dot{\theta}^2
$$</p>
<p>Lagrangian şu hale geliyor,</p>
<p>$$
L = 
\frac{1}{2} (M + m) \dot{x}^2 - 
m \ell \dot{x}\dot{\theta} \cos\theta +
\frac{1}{2} m \ell^2 \dot{\theta}^2 - 
m g \ell \cos\theta
$$</p>
<p>Şimdi Euler-Lagrange denklemlerini yazalım,</p>
<p>$$
\frac{\mathrm{d}}{\mathrm{d} t} \frac{\partial L}{\partial \dot{x}} -
\frac{\partial L}{\partial x}  = F
$$</p>
<p>$$
\frac{\mathrm{d}}{\mathrm{d} t} \frac{\partial L}{\partial \dot{\theta}} -
\frac{\partial L}{\partial \theta}  = 0
$$</p>
<p>İki üstteki denklemde eşitliğin sağ tarafında $F$ var, niye sıfır değil?
Hamilton ve Lagrange-d'Alembert prensibine göre dış kuvvetler bir sisteme
eşitliğin sağ tarafından dahil edilebilir. Ayrıca hıza doğru oranda ters
yönde etki eden bir sürtünme kuvveti $\mu\dot{x}$ de ekleriz. $L$'yi
üstteki denklemlere sokarsak ve basitleştirirsek ters sarkacın hareket
denklemlerini elde ediyoruz.</p>
<p>$$
(M+m) \ddot{x} + 
m \ell \ddot{\theta} \cos\theta - 
m \ell \dot{\theta}^2 \sin\theta + \mu\dot{x} = F
$$</p>
<p>$$
\ell \ddot{\theta} - g \sin\theta + \ddot{x} \cos\theta = 0
$$</p>
<p>Ya da</p>
<p>$$
\left[\begin{array}{rr}
M+m &amp; m l \cos\theta \\ \cos\theta &amp; l
\end{array}\right]
\left[\begin{array}{r}
\ddot{x} \\ \ddot{\theta}
\end{array}\right] 
=
\left[\begin{array}{c}
m l \dot{\theta}^2 \sin\theta - \mu \dot{x} \\
g \sin\theta
\end{array}\right] + 
\left[\begin{array}{r}
1 \\ 0
\end{array}\right] F 
$$</p>
<p>$$
\left[\begin{array}{r}
\ddot{x} \\ \ddot{\theta}
\end{array}\right] 
=
\left[\begin{array}{rr}
M+m &amp; m l \cos\theta \\ \cos\theta &amp; l
\end{array}\right]^{-1}
\left(
  \left[\begin{array}{c}
  m l \dot{\theta}^2 \sin\theta - \mu \dot{x} \\
  g \sin\theta
  \end{array}\right] + 
  \left[\begin{array}{r}
  1 \\ 0
  \end{array}\right] F
\right)
\qquad (1)
$$</p>
<p>Örneğe dönelim; Noktalı kısımları atarsak 1. dereceden bir yaklaşıksallama
ve lineerizasyon elde ediyoruz ve görülen $x^\ast,y^\ast$ noktasındaki değerleri
kullanılan 2x2 matrisi Jacobian matrisidir.</p>
<p>Birinci derece ODE sistemi elde etmek için konum vektörünü tanımlayalım,</p>
<p>$$
\frac{\mathrm{d}}{\mathrm{d} t} \left[\begin{array}{r}
x_1 \\ x_2 \\ x_3 \\ x_4
\end{array}\right] = 
\frac{\mathrm{d}}{\mathrm{d} t} 
\left[\begin{array}{r}
x \\ \theta \\ \dot{x} \\ \dot{\theta}
\end{array}\right]
$$</p>
<p>(1)'den elde edilen matrisin 1. ve 2. satırı sırasıyla alttaki noktalı
yerlere gelecek,</p>
<p>$$
\frac{\mathrm{d}}{\mathrm{d} t} \left[\begin{array}{rrr}
x_1 \\ x_2 \\ x_3 \\ x_4
\end{array}\right] = 
\left[\begin{array}{c}
x_3 \\ x_4 \\ \textrm{.. 1. satır ...} \\ \textrm{.. 2. satır ...}
\end{array}\right]
$$</p>
<p>Görüldüğü gibi $x_1,x_2$'nin ne olduğu basit. $x_3,x_4$ için (1)
denklemindeki matris işlemlerini yapıp 1. ve 2. satırlarını $x_3,x_4$ için
kullanabiliriz. Önce (1) formülündeki gerekli $x_i$ değişken değişimlerini
yaparız,</p>
<p>$$
\left[\begin{array}{rr}
M+m &amp; m l \cos x_2 \\ \cos x_2 &amp; l
\end{array}\right]^{-1}
\left(
  \left[\begin{array}{c}
  m l x_4^2 \sin x_2 - \mu x_3 \\
  g \sin x_2
  \end{array}\right] + 
  \left[\begin{array}{r}
  1 \\ 0
  \end{array}\right] F
\right)
$$</p>
<p>Bu cebirsel olarak oldukca çetrefil bir işlem. <code>sympy</code> ile işlemler
daha kolay yapılabilir,</p>
<pre><code class="python">import sympy

x1, x2, x3, x4 = sympy.symbols('x1 x2 x3 x4')
M, m, l, mu, g, F = sympy.symbols('m M l mu g F',constant = True)

a = sympy.Matrix([[M+m, m*l*sympy.cos(x2)],[sympy.cos(x2), l]])

b = sympy.Matrix([m * l * x4**2 * sympy.sin(x2) - mu*x3 + F , g * sympy.sin(x2)])

c = a.inv() * b

sympy.pprint(sympy.latex(sympy.simplify(c)))
</code></pre>

<pre><code>\left[\begin{matrix}\frac{F - \frac{M g \sin{\left(2 x_{2} \right)}}{2} + M l 
x_{4}^{2} \sin{\left(x_{2} \right)} - \mu x_{3}}{M \sin^{2}{\left(x_{2} \right
)} + m}\\\\\frac{g \left(M + m\right) \sin{\left(x_{2} \right)} - \left(F + M l 
x_{4}^{2} \sin{\left(x_{2} \right)} - \mu x_{3}\right) \cos{\left(x_{2} \right
)}}{l \left(M \sin^{2}{\left(x_{2} \right)} + m\right)}\end{matrix}\right]
</code></pre>

<p>İki matris satırı elde ettik, bunları yerine koyalım,</p>
<p>$$
\frac{\mathrm{d}}{\mathrm{d} t} \left[\begin{array}{rrr}
x_1 \\ x_2 \\ x_3 \\ x_4
\end{array}\right] = 
\left[\begin{array}{c}
x_3 \\ x_4 \\ 
\frac{F - \frac{M g \sin{\left(2 x_{2} \right)}}{2} + M l 
x_{4}^{2} \sin{\left(x_{2} \right)} - \mu x_{3}}{M \sin^{2}{\left(x_{2} \right
)} + m} \\
\frac{g \left(M + m\right) \sin{\left(x_{2} \right)} - \left(F + M l 
x_{4}^{2} \sin{\left(x_{2} \right)} - \mu x_{3}\right) \cos{\left(x_{2} \right
)}}{l \left(M \sin^{2}{\left(x_{2} \right)} + m\right)}
\end{array}\right]
\qquad (2)
$$</p>
<p>Bir gayrı-lineer ODE elde etmiş olduk. Şimdi yapmak istediğimiz bu sistemi </p>
<p>$$
\dot{x} = Ax(t) + B u(t)
$$</p>
<p>$$
y(t) = C x(t) + D u(t)
$$</p>
<p>haline sokmak, yani lineer bir şekilde temsil edebilme, örnekte birinci
denklem $\dot{x} = Ax(t) + B u(t)$ yeterli. Lineerizasyonu kritik nokta
yakınında yapacağız, o zaman LQR adlı bir teknik sistemin o noktada kalması
için gerekli kontrol $u$ değerini hesaplayabiliyor.</p>
<p><em>Gayri-Lineer Dinamik ve Kaos, Ders 6</em>'da Jacobian matrisi ile denge
noktaları yakınında bir sistemi nasıl lineerize edebileceğimizi gördük. İki
boyutta $x^\ast,y^\ast$ denge noktası yakınında, $\dot{u} = \dot{x} = f(x,y)$ ve
$\dot{v} = \dot{y} = g(x,y)$ ODE sistem için mesela (buradaki $u$ üstteki
$u$ ile karıştırılmasın), ya da,</p>
<p>$$
\left[\begin{array}{r}
\dot{u} \\ \dot{v}
\end{array}\right] = 
\left[\begin{array}{r}
f(x,y) \\ g(x,y)
\end{array}\right] 
$$</p>
<p>için, lineerizasyon sonrası şöyle bir görüntü var,</p>
<p>$$
\left[\begin{array}{r}
\dot{u} \\ \dot{v}
\end{array}\right]
=
\left[\begin{array}{rr}
\frac{\partial f}{\partial x} &amp; \frac{\partial f}{\partial y} \\
\frac{\partial g}{\partial x} &amp; \frac{\partial g}{\partial y} 
\end{array}\right]_{x^\ast,y^\ast  }
\left[\begin{array}{r} u \\ v \end{array}\right]
+ ...
$$</p>
<p>Örneğe dönelim; (2) matrisinin Jacobian'inin kritik nokta $(0,0,0,0)$'daki
değerini bulabiliriz. Jacobian'ın ana matris 1. ve 2. satırı için alınan
kısmı türevleri basit,</p>
<p>$$
J_x = \left[\begin{array}{cccc}
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
&amp; \textrm{..... 3. satır ...} &amp;  &amp;  \\ 
&amp; \textrm{..... 4. satır ...} &amp;  &amp; 
\end{array}\right]
$$</p>
<ol>
<li>ve 4. satır Jacobian işlemleri de <code>sympy</code> ile yapılabilir. İlginç
olan tek sonuçlar $x_2,x_3$ üzerinden Jacobian,</li>
</ol>
<pre><code class="python">tmp = sympy.diff(c[0], x2).subs({x1:0,x2:0,x3:0,x4:0}).simplify()
print(sympy.latex(tmp), ',')
tmp = sympy.diff(c[0], x3).subs({x1:0,x2:0,x3:0,x4:0}).simplify()
print(sympy.latex(tmp), ',')
tmp = sympy.diff(c[1], x2).subs({x1:0,x2:0,x3:0,x4:0}).simplify()
print(sympy.latex(tmp), ',')
tmp = sympy.diff(c[1], x3).subs({x1:0,x2:0,x3:0,x4:0}).simplify()
print(sympy.latex(tmp), ',')
</code></pre>

<pre><code>- \frac{M g}{m} ,
- \frac{\mu}{m} ,
\frac{g \left(M + m\right)}{l m} ,
\frac{\mu}{l m}
</code></pre>

<p>Bu değerleri $J_x$'deki yerlerine koyarsak,</p>
<p>$$
A = J_x = \left[\begin{array}{cccc}
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; - \frac{M g}{m} &amp; - \frac{\mu}{m} &amp; 0 \\ 
0 &amp; \frac{g \left(M + m\right)}{l m}  &amp; \frac{\mu}{l m}  &amp; 0
\end{array}\right]
$$</p>
<p>Ardından $F$ için Jacobian, yine 1. ve 2. satır atlanıyor, (2)'nin 3. ve
4. satırları için kısmı türev,</p>
<pre><code class="python">tmp = sympy.diff(c[0], F).subs({x1:0,x2:0,x3:0,x4:0}).simplify()
print(sympy.latex(tmp), ',')
tmp = sympy.diff(c[1], F).subs({x1:0,x2:0,x3:0,x4:0}).simplify()
print(sympy.latex(tmp))
</code></pre>

<pre><code>\frac{1}{m} ,
- \frac{1}{l m}
</code></pre>

<p>$$
B = J_F = \left[\begin{array}{c}
0 \\
0 \\
1/m \\
- 1 / lm
\end{array}\right]
$$</p>
<p>Böylece $(0,0,0,0)$ kritik noktası etrafında lineerize edilmiş sistemimiz
için bir $\dot{x} = A x + B u$ denklemi elde etmiş olduk, </p>
<p>Lineer Karesel Düzenleyici (Linear Quadratic Regulators -LQR-)</p>
<p>Sistemi belirtilen kritik nokta etrafında lineerize etmemizin bir sebebi
vardı; çünkü bir lineer sistem varsa, o sistem herhangi bir denge noktası
etrafında LQR ile tutulabilir. $(0,0,0,0)$ noktası çubuğun tam dik olduğu
(açı orada sıfır) yerdir, amacımız çubuk dengelemek, o zaman dengelemeyi
burada yapabiliriz. Eğer sistem bu duruma yakınsa (çubuğun tam aşağı düşmüş
olduğu durumlarda bu yaklaşım ise yaramaz), LQR kullanılabilir. Tam tanım;
başlangıcı $x_0$ olarak bilinen bir</p>
<p>$$
\dot{x} = A x + B u
$$</p>
<p>sistemi için amaç</p>
<p>$$
J = \frac{1}{2} \int_{0}^{\infty} [ x^T(t) Q x(t) + u^T(t) R u(t) ] \mathrm{d} t
$$</p>
<p>$$
x(t_0) = x_0
$$</p>
<p>bedel fonksiyonunu minimize etmektir, yani bu minimizasyonu yapacak kontrol
$u$ değerini bulmaktır. Çözüm $u(t) = -K(t) x (t)$, ve $K$ cebirsel
Riccati denklemi üzerinden bulunur [2]. Hesapsal pek çok kütüphanede bu
çözümü yapacak <code>lqr</code> çağrıları vardır. $Q,R$ ile $x,u$ içindeki hangi
değişkenlere daha önem, ağırlık vereceğimizi tanımlayabiliriz, mesela iki
boyutlu durumda köşegen matriste </p>
<p>$$
Q = \left[\begin{array}{rrr}
2 &amp; 0 \\ 0 &amp; 1
\end{array}\right]
$$</p>
<p>tanımlamak $x_1$'e $x_2$'ye göre iki kat daha önem verildiğini gösterir. </p>
<p>O zaman gerekli $u(t)$'yu bulduktan sonra bu aksiyonu sisteme
uygulayabiliriz, yani $\dot{x} = A x + B u$ sistemini bulunan $u$ ile
entegre ederiz, ve bu sistem dengeye giden bir çubuk olacaktır. Altta bu
çözümü, başlangıç acısı $\theta = 0.5$ ve $-5$ için görüyoruz. Sonuçlar
animasyon olarak [5,6]'da.</p>
<pre><code class="python">from scipy.integrate import odeint
import control, gym, time
import numpy as np
from numpy import sin, cos

import matplotlib.pyplot as plt
import numpy as np
import math
import time

l_bar = 2.0  # length of bar
l = l_bar 
m = 0.3  # [kg]
g = 9.8
m = 0.3
M = 1.0
l = 1.0
mu = 0.1 # friction
Q = np.array([[100., 0., 0., 0.],[0, 1, 0, 0],[0, 0, 1000, 0],[0, 0, 0, 1]] )
R = 0.0001
init_theta = -5.0
#init_theta = 0.5
x0 = [0.0, 0.0, init_theta, 2.0]

def flatten(a):
    return np.array(a).flatten()

def show_cart(fout, xt, theta):
    cart_w = 1.0
    cart_h = 0.5
    radius = 0.1

    cx = np.matrix([-cart_w / 2.0, cart_w / 2.0, cart_w /
                    2.0, -cart_w / 2.0, -cart_w / 2.0])
    cy = np.matrix([0.0, 0.0, cart_h, cart_h, 0.0])
    cy += radius * 2.0

    cx = cx + xt

    bx = np.matrix([0.0, l_bar * math.sin(-theta)])
    bx += xt
    by = np.matrix([cart_h, l_bar * math.cos(-theta) + cart_h])
    by += radius * 2.0

    angles = np.arange(0.0, math.pi * 2.0, math.radians(3.0))
    ox = [radius * math.cos(a) for a in angles]
    oy = [radius * math.sin(a) for a in angles]

    rwx = np.copy(ox) + cart_w / 4.0 + xt
    rwy = np.copy(oy) + radius
    lwx = np.copy(ox) - cart_w / 4.0 + xt
    lwy = np.copy(oy) + radius

    wx = np.copy(ox) + float(bx[0, -1])
    wy = np.copy(oy) + float(by[0, -1])

    plt.figure()
    plt.plot(flatten(cx), flatten(cy), &quot;-b&quot;)
    plt.plot(flatten(bx), flatten(by), &quot;-k&quot;)
    plt.plot(flatten(rwx), flatten(rwy), &quot;-k&quot;)
    plt.plot(flatten(lwx), flatten(lwy), &quot;-k&quot;)
    plt.plot(flatten(wx), flatten(wy), &quot;-k&quot;)
    plt.xlim(-3, 3)
    plt.savefig(fout)

A = np.array([[0, 0, 1, 0],
    [0, 0, 0, 1],
    [0, -(M/m)*g, -mu/m, 0],
    [0, (m+M)*g/m*l, mu/m*l, 0]])

B = np.array([[0], [0], [1/m],[-1/m*l]])

K,X,e = control.lqr(A,B,Q,R);

def rhs(x, t):

    x1,x2,x3,x4 = x
    xs = np.array([1,0,0,0])
    F = np.float(np.dot(K,(xs - np.array([x1,x2,x3,x4]))))

    tmp1 = (F - M*g*sin(2*x2)/2 + M*l*x4**2*sin(x2) - mu*x3) \
           / (M*sin(x2)**2 + m)

    tmp2 = (g*(M + m)*sin(x2) - (F + M*l*x4**2*sin(x2) - mu*x3)*cos(x2)) \
           /(l*(M*sin(x2)**2 + m))

    return [x3, x4, tmp1, tmp2 ]


t = np.linspace(0, 5, 100)
sol = odeint(rhs, x0, t)

for i,row in enumerate(sol):
    if i % 5 == 0:
        show_cart('frames2/cart-%04d' % i, row[0], row[1])
</code></pre>

<p>$\theta = 0.5$</p>
<p><img alt="" src="frames1/cart-0005.png" />
<img alt="" src="frames1/cart-0015.png" /></p>
<p><img alt="" src="frames1/cart-0020.png" />
<img alt="" src="frames1/cart-0030.png" /></p>
<p>$\theta = -5.0$</p>
<p><img alt="" src="frames2/cart-0005.png" />
<img alt="" src="frames2/cart-0015.png" /></p>
<p><img alt="" src="frames2/cart-0020.png" />
<img alt="" src="frames2/cart-0030.png" /></p>
<p>Kodlar genel hatlarıyla [4]'u baz almıştır. </p>
<p>Özyineli bir şekilde LQR yapan bir diğer kod [7]'de, <code>ilqr.py</code> dosyasında
bulunabilir.</p>
<p>Ödev</p>
<p>[4] bağlantısında paylaşılan kodda bir "yukarı fırlatma (swing-up)"
tekniği görülüyor. Bu teknik direğin tam aşağı düşmüş olduğu durumlarda
kullanılabilir, (üst denge noktasından uzaktayız, bu sebeple mevcut
sistem ise yaramaz), arabaya hızlı ve belli bir şekilde sağ-sol hareketi
yaptırarak direği "yukarı fırlatıyoruz". [4]'teki kod bağlantısını takip
edip Matlab kodlara bakarak aynısını üstteki koda uygulayın. </p>
<p>Kaynaklar</p>
<p>[1] Wikipedia, <em>Inverted Pendulum</em>, <a href="http://www.wikipedia.com/wiki/Inverted_pendulum">http://www.wikipedia.com/wiki/Inverted_pendulum</a></p>
<p>[2] Wikipedia, <em>Optimal control</em>, <a href="http://wikipedia.com/wiki/Optimal_control">http://wikipedia.com/wiki/Optimal_control</a></p>
<p>[3] Gutman, <em>Technion, Linear Systems Lecture</em>, <a href="http://leo.technion.ac.il/Courses/LS/">http://leo.technion.ac.il/Courses/LS/</a></p>
<p>[4] Suhm, {\em LQR Control Tutorial For An Inverted Pendulum With Octave /
  Matlab}, <a href="https://www.youtube.com/watch?v=KqdP0DVZ-lQ">https://www.youtube.com/watch?v=KqdP0DVZ-lQ</a></p>
<p>[5] Bayramlı, <em>Animasyon</em>, <a href="https://github.com/burakbayramli/classnotes/blob/master/phy/phy_050_cont5/frames1/cart.gif">https://github.com/burakbayramli/classnotes/blob/master/phy/phy_050_cont5/frames1/cart.gif</a></p>
<p>[6] Bayramlı, <em>Animasyon</em>, <a href="https://github.com/burakbayramli/classnotes/blob/master/phy/phy_050_cont5/frames2/cart.gif">https://github.com/burakbayramli/classnotes/blob/master/phy/phy_050_cont5/frames2/cart.gif</a></p>
<p>[7] Eiting, <em>ilqr</em>, <a href="https://gist.github.com/jeiting/c381e195d6153eaf657c21f691c2e456">https://gist.github.com/jeiting/c381e195d6153eaf657c21f691c2e456</a></p>
        </section>          
      </div>
    </body>
</html>
