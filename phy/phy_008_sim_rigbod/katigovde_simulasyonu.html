<p><a href="..">Yukarı</a></p>
<h1>Katı-Gövde Simülasyonu</h1>
<!DOCTYPE html>
<html>
  <head>
    <title>Katı-Gövde Simülasyonu
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
<script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
</script>
</head>

<p>Bir örnek gövde üzerinde simülasyon yapmaya uğraşalım. Elimizde bir simit, ya da
geometride torus denen bir şekil var. Bu dosya STL denen bir format içinde,
detaylar için [1]. Torus STL şekli içiçe geçmiş üçgenler ile tanımlı, bu
üçgenlerin herbirine dik olan normal vektörü biliyoruz. O üçgenlerden birinin
orta noktasından çıkan vektörlerden birini ters çevirirsek, o noktaya o yönde
bir kuvvet uyguladığımızı hayal edelim, ve simülasyonun geri kalanını bu
noktadan devam ettirelim.</p>
<pre><code class="python">from stl import mesh

your_mesh = mesh.Mesh.from_file('torus.stl')

prop = your_mesh.get_mass_properties()
print ('hacim',np.round(prop[0],3))
print ('\nyercekim merkezi (COG)',np.round(prop[1],3))
print ('\nCOG noktasinda atalet matrisi')
print (np.round(prop[2],3))
</code></pre>

<pre><code>hacim 4.918

yercekim merkezi (COG) [-0.  0. -0.]

COG noktasinda atalet matrisi
[[ 3.223 -0.     0.   ]
 [-0.     3.223  0.   ]
 [ 0.     0.     5.832]]
</code></pre>

<p>COG'nin sıfır noktasında olması mantıklı çünkü STL dosyasında simit şekli oraya
konmuş, ve simit şekli simetrik bir şekil.</p>
<pre><code class="python">import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d

fig = plt.figure()
axes = mplot3d.Axes3D(fig)

scale = your_mesh.points.flatten()
axes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors,alpha=0.3))
axes.auto_scale_xyz(scale, scale, scale)

def plot_vector(fig, orig, v, color='blue'):
   ax = fig.gca(projection='3d')
   orig = np.array(orig); v=np.array(v)
   ax.quiver(orig[0], orig[1], orig[2], v[0], v[1], v[2],color=color)
   ax = fig.gca(projection='3d')  
   return fig

LIM = 5
axes.set_xlim(-LIM,LIM);axes.set_ylim(-LIM,LIM);axes.set_zlim(-LIM,LIM)

SCALE = 4
tidx = 2000
o = np.mean(your_mesh.vectors[tidx],axis=0)
axes.plot (o[0],o[1],o[2],'gd')
n = your_mesh.get_unit_normals()[tidx]
plot_vector(fig, o, n*SCALE)
plot_vector(fig, o, -n*SCALE, color='red')
axes.view_init(azim=84,elev=28)

plt.savefig('phy_005_basics_04_05.png')
</code></pre>

<p><img alt="" src="phy_005_basics_04_05.png" /></p>
<p>[devam edecek]</p>
<p>Kaynaklar</p>
<p>[1] Bayramlı, <em>3D Baskıya Hazır CAD Tasarımlarına Erişmek, Numpy-STL</em>,
    <a href="https://burakbayramli.github.io/dersblog/sk/2020/08/numpy-stl.html">https://burakbayramli.github.io/dersblog/sk/2020/08/numpy-stl.html</a></p>
<p>[2] Witkin, <em>Physically Based Modeling</em></p>