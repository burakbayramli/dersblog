<!DOCTYPE html>
<html>
  <head>
    <title>Hesapsal Karmaşıklık Teorisi (Computational Complexity)
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
   <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
   </script>
   <link rel="stylesheet" type="text/css" media="screen" href="https://burakbayramli.github.io/css/style.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1548953794786292"
          crossorigin="anonymous"></script>  
  </head>
    <body>
      <div id="header_wrap" class="outer">
        <header class="inner">
          <h1 id="project_title">
            <a href="https://burakbayramli.github.io" style="text-decoration:none; color:inherit;">dersblog</a>
          </h1>
          <h2 id="project_tagline"></h2>          
        </header>
      </div>
      <div id="main_content_wrap" class="outer">        
        <section id="main_content" class="inner">
        <h1>Hesapsal Karmaşıklık Teorisi (Computational Complexity)
</h1>

<p>Bu bilim dalı algoritmaların yer ve zaman gibi kaynakları ne kadar
kullandığından hareketle bu algoritmaları kategorize etmeye uğraşır. Diğer
bazı amaçlar, hangi algoritmaların çözümsüz olacağı, hangi algoritmaların
çok zaman alacak olsa bile, eninde sonunda bir sonuca varabileceği gibi
konulardır.</p>
<p>Algoritma türlerinin arasındaki benzerlikleri bulmak zorluk teorisin ana
eylemlerinden; mesela problem $A$ için bir algoritma yazmamız gerektiğini
düşünelim, ve aynı gün kuramsal bir bilgisayar bilim makâlesinde, bizim
problemin diğer bir "$B$ problemi" ile tıpatıp aynı olduğunu okuduk. Bu makâleye
göre, $B$ probleminin kabakuvvet çözümünün "yavaş" olduğu belirtilmiş olabilir,
ve hızlı çözümün imkansız olduğu da ispat edilebiliyor. Bu bilgiden hareketle,
$A$'nın da hızlı cözümünün olamayacağını daha baştan anlarız, akıllı tahmin
(heuristic) ekleyerek çözümü biraz olsun hızlandırmaya çalışabiliriz.</p>
<p>P (Polinom) Grubu</p>
<p>Bir algoritmanın P grubu içinde olduğu söyleniyorsa, bu algoritma polinom
zamanda işliyor demektir, yani algoritma karmaşıklığı $O(n^2)$ gibi bir
şekilde belirtilebiliyordur; polinom ifadesi herhalde $n^2$ ifadesinin bir
polinom olmasından, $O(n)$, yani eleman sayısına direk orantılı / lineer
zamanda işleyen algoritmalar de tabii ki bu grupta ($n^1$ de bir polinom
(!) ). P grubu en hızlı işleyen algoritmalar grubudur, algoritmalarımızı bu
grupta görmek isteriz, ve ona göre tasarlamaya çabalarız. En iyi bilinen,
"iyi" algoritmaların hepsi bu gruptadır, mesela tüm popüler sıralama
(sorting) algoritmaları, aritmetik hesaplar, lineer cebirdeki çoğu matris
işlemi, kısayol bulma algoritmaları, vs.</p>
<p>NP-Zor (NP-Hard) ve NP-Tam (NP-Complete)</p>
<p>Bilgisayar bilimde öyle problemler vardır çözümlerini bulmak için mümkün
girdinin tüm kombinasyonlarını denemek gerekir. 3SAT bu problemlerden
biri. Diyelim ki $x_1,..,x_n$ değişkenlerini kullanıp en fazla üç öğeli, ve
grup içinde VEYA ile birbirine bağlı, gruplararası ise VE ile birbirine
bağlı bir ifade zinciri oluşturuyoruz.</p>
<p>$$
(x_1 \lor x_2 \lor \bar{x_3}) \land 
(\bar{x_1} \lor \bar{x_2} \lor \bar{x_3}) \land
(x_1 \lor \bar{x_2}) \land
(\bar{x_1} \lor \bar{x_2})
$$</p>
<p>ki $\lor$ işareti VEYA (OR), $\land$ işareti ise VE (AND), değişken
üzerinde çizgi olması onun tersinin alınması (NOT) demek. Soru şu, bu
ifadenin doğru yani 1 sonucunu vermesini sağlayacak girdiler / onu tatmin
edecek (satisfy -SAT kısaltması buradan geliyor-) var mıdır? Ve bu sonuç
polinom zamanda bulunabilir mi?</p>
<p>Bu ufak örnekte tahmin etmeye uğraşırsak, $x_1=1,x_2=0,x_3=0$ bu formülü
"tatmin eder", yani üstteki ifade 1 sonucunu verebilen bir
ifadedir. Fakat bu sonuca "kesinlikle" erişmek ve bunu her tür 3SAT
problemi için yapabilmek için bir programın tüm girdi kombinasyonlarını
denemesi gerekir. Tüm seçeneklerin denenme mecburiyeti bir problemi zor
kategorisine sokar. Kısayol, cinlik, envai türden tahmin (heuristic) her
zaman ise yaramaz, bazı problemlerde yarayabilir, fakat hesapsal zorluk her
zaman en kötü şartın performansını baz alır.</p>
<p>3SAT o kadar temel bir problemdir ki, zor problemler kategorisinde temsili bir
özelliği vardır. Tüm zor problemler 3SAT'a indirgenebilirler. Bu tür problemlere
ayrıca NT-Tam ismi de verilir, çünkü çok zor problemleri "tam" olarak temsil
ederler.</p>
<p>Turing Makinaları</p>
<p>Şimdi Turing makinalarına, onların baştan planlı (deterministic), baştan
plansız (nondeterministic) şekillerinin üzerinden geçelim.</p>
<p>Algoritma başı sonu belli, her muhtemel seçenek için önceden belirlenmiş bir kod
parçasının devreye girdiği bir veri ve eylemler dizisidir. Bu algoritmayı
yazarken içinde bulunduğumuz evren, değişkenler, girdi, çıktı aletleri,
eğer/eylem çiftleri, gibi kavramların olduğu bir evren. Bu dili işleten makinayı
bir soyut makina olarak görelim. Fakat göreceğiz ki, halâ teorik iş yapmamız
için bu makina yeteri kadar basit değildir. Kullandığımız 'esnek' dili
destekleyen makinamız oldukça çetrefil hâlde. Ayrıca, dili değiştirirsek (Java
yerine LISP gibi) makinın da değişmesi gerekir, bütün dilleri temsil edebilen
bir makina bulamaz mıyız?  Teorik iş yapabilmemiz için böyle evrensel bir
makinaya ihtiyacımız var.</p>
<p>Dili basitleştirelim. Direk erişimli (random access) belleği olan, komutları ve
verisi aynı gözüken bir makina yapalım ve onun kullandığı dili tasarlayalım. (Bu
makina günümüzde kullanılan bilgisayardır).</p>
<p>Peki bu makina daha da basit olamaz mı?</p>
<p>Olur. Tek bir teyp üzerinde girdisini tutan, her an, önceden belirli ve sayılı
konum/durum içinde olabilen, komutlarını, durumdan/duruma geçiş listesi olarak
tutan bir makina düşünelim.</p>
<p>Öyle gözüküyor ki, artık bilgisayar işleminin ruhuna indik. Bundan daha basit
bir makina tasarlamamız mümkün gözükmüyor. Durum, geçiş, ve teyp kavramlarını
kullanarak her türlü bilgisayar hesabını temsil edebileceğimizi düşünürsek
(bunun ispatları yapılmıştır), en basit temsil şeklinde varmış olduğumuzu
görüyoruz.</p>
<p>İşte bu makina, Turing makinası olarak bilinir.</p>
<p><img alt="" src="turing_makinasi.jpg" /></p>
<p>Formel olarak, Turing makinası M şu dörtlüyü içerir: </p>
<p>$$ M = (K,\Sigma,\delta, s) $$</p>
<p>$K$ = makina durumu (state)</p>
<p>$\delta$ = gecis fonksiyonu </p>
<p>$\Sigma$ = teyp alfabesi </p>
<p>$s$: teyp verisi </p>
<p>Dörtlü içindeki bütün terimler birer kümedir. K terimi, M makinasının içerdiği
durumların kümesi, delta bütün geçişlerin listesi, sigma, alfabe olduğu için
teypin kullandığı harflerin kümesi ve s, giriş için M makinasına verilen
harflerin kümesidir.</p>
<p>Şimdi programa dönelim: Geçiş fonksiyonu olan delta, yani program, K x Sigma
ile, (K U {dur, "evet", "hayır"}) x Sigma x {Sol, Sağ, Hareketsiz} küme
üyelerini birbirine eşler. Yani geçiş fonksiyonu, durum+teyp sembolu
ikililerini, durum+teyp sembolu+teyp hareketi üçlülerine eşlemektedir.</p>
<p>Not: 'x' operasyonu, iki küme arasında kartezyen eşleme yapmaktadır. Yâni,
A x B, A kümesinin her elemanı ile B kümesinin her elemanını eşleyerek,
|A|*|B| sayıda yeni bir küme oluşturur. SQL dilini bilenler JOIN komutu ile
bağlantı kurabilirler)</p>
<p>Turing makinasının işlevi, makinanın o anda gördüğü, kafasının okuduğu sembol,
ve o an içinde olunan duruma göre başka bir duruma geçmek, ve (gerekiyorsa)
teype yeni bir harf yazmak, sonra da teyp kafasını gene programa göre sağa ya da
sola hareket ettirmekten ibarettir. Teyp kafasını hareketsiz bırakmakta
mümkündür.</p>
<p>Bu kadar basit temel işlemlere dayanan bir modelin dünyadaki bütün
algoritmaları temsil edebilmesi ilginç değil mi?</p>
<p>Örnek Turing makinası olarak, aşağıda teyp üzerinden verilen bir metnin
palındrom olup olmadığını anlayabilen bir Turing Makinayı görebiliriz. Bu
program (makina), eğer metin palındrom ise "evet" cevabı verecek, değil ise
"hayır" cevabı verecektir. Palındrom metni, "arabaabara" gibi, içinde
"araba" kelimesinin ters yüz edilerek yanyana konulduğu metne verilen
isimdir. Palındrom tanımak çok kolay olmayıp çok zor da olmayan bir örnek
olduğu için hesapsal karmaşıklık teorisi kitaplarında oldukca
kullanılmaktadır [1]. Alttaki örnek ikisel veri üzerinde işliyor, yani
$M(0000) = 'evet'$, $M(011) = 'hayır'$, ve $M(0110) = 'evet'$ cevaplarını
hesaplayacak. </p>
<p><img alt="" src="turing_pallindrome.png" /></p>
<p>$\Sigma$ her zaman özel karakterler $\sqcup$ ve $\rhd$'yi içerir, bunlar
sırasıyla "boş" ve verinin başını temsil eden ilk semboldur. Program
denen şey $\delta$'dir, $\delta(q,\sigma) = (p,\rho,D)$ olarak belirtilir,
yani her $q \in K$ ve o anda üzerinde olunan sembol $\sigma \in \Sigma$
için sonraki konum $p$'yi, $\sigma$ üzerine yazılacak (bir önceki
silinerek) sembol $\rho$'yu, ve teyp üzerinde hangi yöne hareket
edileceğini gösteren $D \in { \leftarrow, \rightarrow, -}$'yi
üretir. Eğer başlangıçta isek bu sembolü silmeden hep sağa gitmek
istiyoruz, o sebeple programın değişmeyen tek parçası
$\delta(q,\rhd) = (p,\rho,D)$ $p=\rhd$, $D=\rightarrow$.</p>
<p>Program nasıl başlar? İlk önce konum $s$'dir. Girdi $\rhd$'ye getirilir, bu
sembol arkasında sonlu (finite) bir karakter dizisi vardır,
$x \in (\Sigma-{\sqcup} )$. $x$'e Turing makinasının girdisi adı
verilir. Başta teyp kafası $\rhd$ üzerindedir. </p>
<p>İşleyiş şöyle devam eder: $s$ konumunda girdinin ilk sembolü aranır,
bulununca bu sembol bir $\rhd$ haline getirilir (böylece sanki girdi sola
doğru çekilmiş gibi olur, daha doğrusu girdinin ilk öğesini "işlenmiş"
hale getirdik, onu sildik -ama konumda onu hatırlıyoruz-). Konumda
hatırlamak ilk karakter 0 ise $q_0$ konumuna 1 ise $q_1$ konumuna girmek
ile oluyor. Sonsuz olmayan girdi öğelerini konum üzerinden hatırlanması
Turing makinalarının önemli numaralarından biridir bu arada, ve pek çok
farklı yerde kullanılır. Ardından $M$ teyp kafasını $\sqcup$ bulununcaya
kadar sağa doğru gönderecektir, bir kez sona gelinince en sondan bir önceki
sembole bakılır. Tabii "sona gitmek" te belli programsal adımlar ile
yapılıyor, ilk sembol 0'dı diyelim, sağa geldik 0 ise 0 yaz, sağa git, 1
ise 1 yaz, sağa git adımları bu gidişi hallediyorlar. </p>
<p>Sona gelinince akılda tutulan $q_0'$ ya da $q_1'$'e geçilir, böylece hem
sona gelmiş olduğumuzu, ve başta ne okumuş olduğumuzu hatırlamış oluyoruz,
sonra teyp kafasını sola hareket ettiriyoruz. Buradaki öğe hatırlanan öğe
ile uyumlu ise oraya $\sqcup$ yazıyoruz, böylece bu öğeyi bir bakıma
"işlenmiş" olarak siliyoruz. Eğer uyumsuzluk var ise, 'hayır' cevabı
verip duruyoruz. Devam ediyorusak bu noktada eldeki dizi hem soldan hem
soldan hem sağdan küçülmüş oldu, ve geri kalan veri üzerinde aynı işleme
devam edebiliriz, veri küçülecek, küçülecek, eğer elde bir palındrom var
ise elde hiç girdi kalmayana kadar bu işlem devam edecek.</p>
<p>Church-Turing Tezi</p>
<p>Araştırmacılar uzun süre Turing makinasından daha basit bir model bulmaya
uğraştılar, ve bu uğraşıda başarısız oldular.</p>
<p>Daha sonra araştırmacılar, kaç değişik makina modelinin mevcut olabileceğini
anlamak için, en basit Turing makinasının çözemeyeceği problemleri çözecek
makinalar tasarlamaya da uğraştılar. Mesela RAM, birden fazla teyp, vs. gibi
ekler koyarak, basit modeli güçlendirmeye çabaladılar. Eğer en basit modelin
çözemeyeceği bir problemi çözen bir model bulsalardı, bu model yeni ve
alternatif bir model olabilirdi. Yeni modelin değişik olup olmadığını nasıl
anlamak için, kuramcılar indirgeme denen bir tekniği kullandılar. İndirgeme,
yeni modelle kurulmuş olan makinayı, eski modelle kurulmuş makina aracılığı ile,
yani onun dili ile, simule etmektir.</p>
<p>Bu simulasyonun 'dönüşüm' denen aşamasında, simule edilen makinanın
girdisi, ötekine çok hızlı bir şekilde dönüştürülür. Hemen ardından simule
eden makinaya girdi olarak verilir. Çıktı da aynı şekilde dönüştürülür.</p>
<p>Eğer çok hızlı (polinom zamanlı) olarak dönüşümü yapabildiysek, ve simule
de çalışır ise, indirgeme başarılı olmuş demektir.</p>
<p>Fakat, görülmüştür ki, envai türden ekler ile güçlenen her 'sözde yeni' model en
basit Turing makinasına indirgenebilmiştir. Demek ki bu 'yeni' modeller
gerçekten yeni model değillerdi, ve işte bu bu sayede bilgisayarlar için en
basit Turing makinasından alternatif bir model olamacağı kanıtlanmış oldu.</p>
<p>Bütün bu bulgulara dayanarak Church ve Turing şu tezi kabul etmeye karar
verdiler.</p>
<p>"Bir algoritma ile, (bütün girdilerine "evet" ve "hayır" cevabı verebilen) bir
Turing makinası tamamen aynıdır. Birbirleri arasında direk ilişki vardır. "</p>
<p>Yani, algoritma denen soyut kavram, en basit Turing makinası üzerinde yazılan
bir program demektir, bütün teorik hesaplar ve kuramlar bu en basit makina
üzerinden yapılabilir.</p>
<p>Bu ortak bilgisayar kavramında fikirbirliğine varılmasının ne kadar önemli
olduğunu vurgulamak istiyorum. Teorik dünyada, 'bilgisayar' denince, formel bir
kavram akla gelmelidir. En basit makinalar arasında en güçlüsü seçilerek, bu
makinayı baz alan kuramların da aynı şekilde basit olması
sağlanmıştır. Basitlik, bilim dünyasında önemli yer tutar.</p>
<p>"Her girdiye evet ya da hayır cevabı veren" makinaların özellikle belirtilmesi
ilginçtir. Bunun sebebi şudur; Her Turing makınasının (yani programın)
işleyişini biterek durması garanti değildir. Sonsuz döngüye giren programları
hepimiz biliyoruz. Eğer evrendeki her Turing makinasını 11001010... gibi bir
ikili düzen kodu ile belirtiliyorsak, bu makinalardan her biri durup, "evet" ya
da "hayır" cevabı veriyor olamaz (bu söylemin ispatını algoritma çetrefilliğini
işlediğimiz yazıda bulunabilir).</p>
<p>Church-Turing tezi, duran ve "evet" ya da "hayır" cevabı veren makinaların bir
algoritma ile eşgörülmesini belirtmiştir.</p>
<p>Ek olarak belirtmek gerekir ki, Church-Turing tezi sadece bir tezdir, yani bir
önkabuldür. Aynen matematikteki bir aksiyom gibidir, yani ispatlanmış teori
değildir. Bu sebeple doğruluğu veya yanlışlığı ispat edilemez. Geometride nokta,
çizgi gibi kavramların en baştan ispatsız olarak kabul edildiği gibi,
Church-Turing tezi bir başlangıç önkabuludur. Bu önkabul olmadan geri kalan
teorileri bir temele oturtmamız mümkün olmazdı.</p>
<p>Tabii, Church-Turing tezi bir tez olduğuna göre, başka bir tez gelecek olsa
değişik bir bilgisayar bilim teorisi kurulabilirdi. Fakat araştırmacılar bunun
mümkün olduğunu düşünmüyor.</p>
<p>Sonsuza Giden İkili Sayıların Kümesi</p>
<p>Aşağıda gösterilen küme, sayılamayan sonsuz bir kümedir.</p>
<pre><code>B =
{1101 ....... }
{1011 ....... }
{1110 ....... }
{.100 ....... }
{.011 ....... }
...
</code></pre>

<p>Teori: B sayılamayan sonsuzluktadır.</p>
<p>İspat:</p>
<p>B'nin sayılabilir olduğunu farzedelim.</p>
<p>Kullanılan matematiksel teknik: Bir teorinin "karşıtının" doğru olduğunu, yani
B'nin sayılabilir bir sonsuzluk olduğunu farzedip yola devam eder, ve anlamsız /
saçma / absürt bir sonuca varırsak, tersini farzettiğimizi teori doğru
demektir. Bu, yanlışın yanlışlığının doğruyu vermesidir bir anlamda.</p>
<p>Bu teknik, matematikte "karşıtlık ile ispat etmek" diye bilinir. Teorinin
tersini kabul edip yanlış bir sonuca vardıysak, demek ki teori doğrudur .</p>
<p>Devam edelim. B'nin sayılabilir olduğunu farzettiğimize göre, aşağıdaki
gibi bir eşleme mümkün olabilir.</p>
<p><img alt="" src="inf_binary_diagonalization_once.jpg" /></p>
<p>Şimdi, doğal sayılar ile olan eşlemeyi yanlış çıkartmak için öyle bir sayı
bulacağız ki, hiçbir n ile eşlenemeyecek.</p>
<p>Bu sayı, köşegen üzerindeki sayının ikili aritmetiğe göre tam tersi olsun
(köşegen aşağıda gösterilmiştir)</p>
<p><img alt="" src="inf_binary_diagonalization.jpg" /></p>
<p>Yani köşegendeki 1010.. yerine, 0101... kullanacağız. Bu sayı, bir n ile
eşlenebilir mi?</p>
<p>Hayır! Neden olduğunu görelim. Bu eşlemenin imkansız olmasının sebebi, sol
tarafta 1,2,..n diye giderken, n'in karşısındaki f(n)'in (terslik kuralımız
yüzünden) n'inci değerinin her zaman gerekenden ters bir değer olacağıdır.</p>
<p>Halbuki, elimizde sonsuz tane 0 ve 1 var, ve elimizdeki 0101.. değerini bir
yerlere koyabilmeliydik. Fakat elimizdeki gayet masum ve basit kurala göre
bile bunu yapamıyoruz. Demek ki, başta yapılan faraziye, yanlış idi, bu da
teorinin doğruluğunu ispatlar. B sayılamayan büyüklükte bir sonsuz kümedir.</p>
<p>Sonsuzluklar Arasındaki Farklar</p>
<p>İki sonsuzluk arasındaki en bariz fark, bir sonsuzluğun sayılabilir
ötekinin de sayılamayan türden olduğu zaman ortaya çıkar. Sayılabilen
sonsuzlukları tanımlamak için, ünlü matematikçi Kurt Gödel, incelediği
kümeyi doğal sayılar ile eşleme tekniğini denedi. Doğal sayılar bildiğimiz
gibi 1'den başlayarak sonsuza kadar birer birer artan tam sayıların
kümesidir.</p>
<p>Sayılabilir Sonsuzluklar</p>
<p>Zaten herhangi bir şeyi sayarken de yaptığımiz bu değil midir? Parmakla
gösterip, söyleriz "bir..iki..üç...vs.", ve kullandığımız bütün bu sayılar
birer doğal sayıdır. Yani sayarken biz de gösterdiğimiz şeyi, bir doğal
sayı ile eşleriz.</p>
<p>Bu eşlemenin geçerli olabilmesi için, en güçlü matematiksel hâlinde olması
gerekiyor, yani bize lazım olan birebir ve örten türden bir eşlemedir... A
ve B kümesi düşünürsek; Birebir eşleme, iki değişik A elemanının hiçbir
zaman aynı B elemanına eşlenmediği zaman ortaya çıkar, örten eşleme ise,
B'nin bütün elemanlarının A'nın bir elemanı ile muhakkak eşlendiği zaman
ortaya çıkar.</p>
<p>Bu iki tür eşlemenin olduğu zaman, elimizde tekabül etme (correspondence)
ilişkisi çıkar.</p>
<p>Şimdi tekabül tekniği kullanarak örnek kümeleri inceleyelim: Mesela,
2,4,6,... olarak ikişer ikişer artan sayılar kümesi sayılabilir bir
sonsuzluk mudur?</p>
<p>Bu soruyu, yeni bilgilerimiz ışığında değiştirerek tekrar soruyoruz; Doğal
sayılar ile {2,4,...} kümesi arasında ilişki varmı dır?</p>
<p>Ek not: Lise matematiğinden hatırlayacağımız fonksiyon kavramı, aslında bir
tekabül ilişkisidir.</p>
<p>Demek ki, doğal sayılar ile {2,4,...N} arasında bir fonksiyon bulabilirsek,
tekabül ilişkisini kurmuş olacağız, ve {2,4,...N}'in sayılabilir bir küme
olduğunu ispatlamış olacağız.</p>
<p>Bu fonksiyonu bulmak oldukça basit: f(x) = 2x. Demek ki {2,4,6..} kümesi
sayılabilir bir sonsuzluktur.</p>
<p>Sayılamayan Sonsuzluklar</p>
<p>Gerçek sayılar, noktadan sonra kesire devam eden sayılardır, mesela pi
sayısı 3.1415926.. ya da 2'nin karekökü 1.4142135... sayıları gerçek
sayılardır. Cantor, R kümesinin sayılamaz olduğunu köşegenleştirme
(diagonalization) tekniğini kullanarak ispat etmiştir.</p>
<p>Teori: Gerçek sayılar kümesi R (real numbers), sayılamaz bir kümedir.</p>
<p>İspat: R'ın sayılamaz olduğunu ispat etmek için, R ile N (doğal sayılar)
arasında tekabül ilişkisi olmadığını ispat etmek zorundayız. İspat,
karşıtlık ile ispat etme tekniğini kullanacak. Düşünelim ki, N ile R
arasında f denen bir tekabül ilişkisi mümkün. Bizim yapmamız gereken, f'in
gerektiği gibi çalışamacağını ispat etmekten ibaret.</p>
<p>F'in doğru bir tekabül ilişkisi olabilmesi için, f bütün N'in elemanlarını,
tüm R elemanları ile eşlemelidir. Ama biz öyle bir x bulacağız ki, bu x
hiçbir N elemanı ile eşlenemeyecek. Aradığımız karşıtlıkta işte bu x
olacak.</p>
<p>Bu x'i arayıp bulamayız tabii, ama inşa edebiliriz.</p>
<p>Şimdi, tekabül ilişkisinin olduğu farzından yola çıkarak, aşağıdaki türden
bir ilişkinin mevcut olduğunu varsayalım.</p>
<p>\begin{array}{ll}
n &amp; f(n) \\
\hline
1 &amp;  3.14159....\\
\hline
2 &amp;  55.555555...\\
\hline
3 &amp;  0.12345...\\
\hline
4 &amp;  0.5000000...\\
\hline
.. &amp;  ...
\end{array}</p>
<p>Bu tekabül ilişkisi, f(1) = 3.14159...., f(2) = 55.55555..., f(3) =
.. .olarak devam ediyor. Yani, f işlevi 1 sayısını 3.14159 ile eşliyor, 2
sayısını 55.55555 ile eşliyor, vs.</p>
<p>Baştaki farzla ilerleyip geri kalan sonuçları patlatmak için, amacımız
f(n)'in üyesi olamayacak bir x bulmak idi. Bunun için şöyle bir x
kurgulayabiliriz.</p>
<p>X'in inşa kuralını şöyle saptayalım: X'in 1. basamağındaki sayı, f(1)'in
noktadan sonraki 1. basamağındaki sayıdan farklı olsun. Ne olursa olsun
(önemli değil) ama farklı olsun. Yukarıdaki f(1) örneğinde bu sayı 1
(3.14159..), o zaman x'in noktadan sonraki 1. sayısı, 1'den farklı olması
gerekiyor; mesela, rasgele seçiyoruz, 4.</p>
<p>Aynı şekilde, x'in f(2)'de olamamasını zorlamak için, x'in 2. basmağındaki
sayının f(2)'nin 2. basamağındaki sayıdan farklı seçiyoruz. Yani, 5 yerine
(55.55555..) diyelim 6.</p>
<p>Gene aynı şekilde, x'in f(3) için, 3 yerine 4 seçebiliriz, vs..</p>
<p>Bu şekilde f(n)'in köşegeni üzerinde devam ederek bir x oluşturmuş oluruz.</p>
<p>$$
\begin{array}{ll}
n &amp; f(n) \\
\hline
1 &amp;  \textrm{ }3.<em>1</em>4159....\\
\hline
2 &amp;  55.5<em>5</em>5555...\\
\hline
3 &amp;  \textrm{ }0.12<em>3</em>45...\\
\hline
4 &amp;  \textrm{ }0.500<em>0</em>000...\\
\hline
.. &amp;  ...
\end{array}
$$</p>
<p>x = 0.464...</p>
<p>X'in f(n)'in üyesi olamayacağını bu şekilde ispatlamış oluyoruz, çünkü x'in
n'inci basamağı, f(n)'in noktadan sonraki n'inci basamağından <em>her zaman</em>
değişik olacaktır.</p>
<p>Not: Biraz daha görsel olan ispatlar, şunu da ekleyebiliyor: X'i f(n) içine
sokuşturmuş olduğumuzu düşünelim;</p>
<p>$$
\begin{array}{ll}
n &amp; f(n) \\
\hline
1 &amp;  \textrm{ }3.<em>1</em>4159....\\
\hline
2 &amp;  55.5<em>5</em>5555...\\
\hline
3 &amp;  \textrm{ }0.12<em>3</em>45...\\
\hline
4 &amp;  \textrm{ }0.500<em>0</em>000...\\
\hline
.. &amp;  ... \\
\hline
.. &amp;  0.464 ???
\end{array}
$$</p>
<p>Soru işareti yerine hangi sayı gelmelidir? :) Soru işareti yerine
istediğiniz sayıyı koyalim, bir taraf o sayıyı öyle kabul etmekte, x sırası
ise ne olursa olsun o sayı olmasın (!)  demektedir. Bu bir çakışma,
uyuşmazlı, absürdlük ve saçmalıktır. Demek ki baştaki faraziyemiş
yanlıştır. Demek ki, R kümesi olan f(n), doğal sayılar (n) ile eşlenemiyor;
O zaman R sayılamayan büyüklükte sonsuz bir küme olmaktadır.</p>
<p>Durmayan Turing Makinaları Var mıdır?</p>
<p>Bilgisayar bilimde, bir dil (language) ile algoritma (Turing makinası) arasında
çok sıkı bir bağlantı vardır.</p>
<p>Algoritma, belli bir problemi çözmek için yazılır. Bu problemi çözmek
demek, önceden kararlaştırılmış bir alfabe üzerinden oluşturulabilecek bir
girdinin işlenmesi, ve bu girdiye ve programın mantığına göre bir cevabın
verilmesidir.</p>
<p>Algoritma ile eş görülen Turing makinalarının yaptığı (bkz. Church-Turing
tezi), girdiye "ret" vermek, ya da "kabul" etmektir.</p>
<p>O zaman, bir Turing makinasının kabul ettiği tüm girdilerin toplamını
düşünürsek; bu toplama bir dil diyebiliriz.</p>
<p>Formel olarak</p>
<p>$M = (K,\Sigma,\delta,s)$</p>
<p>$\Sigma$: Teyp Alfabesi</p>
<p>$\Sigma^\ast$: Teyp alfabesi ile oluşturulabilecek tüm girdilerin kümesi</p>
<p>$s$: Teyp verisi</p>
<p>$L \in \Sigma^\ast$, ki $x \in L$, $M(x)='evet'$, ve $x \cancel{\in} L$,
$M(x)='hayır'$ olacak şekilde.</p>
<p>Demek ki, bir evet/hayır türünden karar problemini, aynı zamanda "bir dilin
karar verilme" problemi gibi de görebiliriz. Bilgisayara verilen girdiyi
(bir dile ait olan bir girdiyi) anlayabiliyor muyuz? Anlamaktan öte, evet
ya da hayır diyebiliyor muyuz? Verilen girdinin, beklediğimiz dile ait olup
olmadığına kesin evet ya da hayır diyebiliyor muyuz?</p>
<p>Diller, Problemler</p>
<p>Bunu takiben şu soru sorulabilir: Bütün bunlar iyi de, bilgisayarların işi
çoğu zaman evet/hayır cevabı veren programlar değil ki. Çoğu problem,
hesaplanmış bir değer istiyor, bir sonuç, çıktı veriyor. Dünyadaki her
problemi bir karar problemine çevirebilir miyiz?</p>
<p>Bu da kritik bir sorudur. Bunun da cevabı da "evet" olacak. Mesela bir
optimizasyon problemini düşünelim. Şu ünlü seyahat eden satıcı problemi. N
sayıda şehir arasındaki uzaklıklar biliniyor, bütün şehirleri ziyaret etmek
kaydıyla, en kısa katedilebilecek yolu bulmamız lazım. Yani cevap, en kısa
olan güzergahın raporudur.</p>
<p>Başlangıçta evet/hayır cevabı verilmesi mümkün gözükmeyen bu problemi,
aslında bir eşik değeri vererek bir karar problemine
dönüştürebiliriz. Yani, "en kısa yolu bul" yerine, "katedilen en kısa yol
1-4-3-3 şehirleri mi?" sorusuna evet ya da hayır cevabı verilmesi gibi.</p>
<p>Her Problem = Dil Ama Her Dil=Problem Mi?</p>
<p>Bu kadar girişi, bir problemin (makinanın) bir dil ile aynı olduğunu
belirtmek için yaptık. Fakat bunun tersi, her zaman geçerli değildir.</p>
<p><em>Dünyadaki her dile karar verebilen bir Turing makinası olmayabilir</em>.</p>
<p>Bu uyuşmazlığın sebebi ne olabilir? </p>
<p>Basit bir sayı farkı bu uyuşmazlığa yol açacaktır. Eğer evrendeki tüm
mümkün dillerin sayısı, tüm mümkün Turing makinalarından fazla ise, demek
ki bazı diller için Turing makinası olamaz, ve bu diller karar verilen
diller kategorisine giremezler.</p>
<p>İyice kafaların karıştığını görür gibi oluyorum. Tüm diller derken bir
sonsuzluktan bahsediyoruz, aynı şekilde tüm Turing makinaları derken de
sonsuzluktan bahsediyoruz.. Bir sonsuzluk öteki sonsuzluktan nasıl büyük
olabilir?</p>
<p>Evet olabiliyor! Bazı sonsuzlukların bazı sonsuzluklardan daha büyük olduğu
matematiksel olarak ispatlandı, ve tabii ki bu çok büyük bir buluş oldu.</p>
<p>Bu yazıda numaralar üzerinden gördüğümüz örnekte olduğu gibi, tüm Turing
makinalarının sayılabilir olduğunu, ama tüm dillerin sayılamayan kadar
olduğunu ispatlayabilirsek, aradaki bariz farktan hareketle, bazı dilleri
karar verebilecek bir Turing makinasının olamayacağını da ispatlamış
oluruz.</p>
<p>Teori: Her dil karar verilebilen bir dil değildir.</p>
<p>İspat: Bütün Turing makinalarının sayılabilir kadar olduğunu
biliyoruz. Turing makinası bir program olduğuna göre, her programın bir
metin olarak kodlanması mümkündür. Bu kodlamayı {0,1} gibi bir alfabe ile
yapacak olsak, tüm Turing makinaları {0,1}<em> kümesine dahil olduğunu
söyleyebiliriz. {0,1}</em> kümesi, {0,1,00,01,11,000,...} olarak sonsuza giden
bir kümedir. Bu kümenin içinden geçerli olmayan (bozuk) Turing makinalarını
atsak, geriye kalan hâla sayılabilir bir sonsuzluktadır.</p>
<p>Şimdi, tüm dillere dönelim. Bir dil, mesela gene aynı sigma alfabesi
üzerinde {0,1,00,01,11,000,...} olarak giden bir kümede "sadece 1 ile
başlayan metinler" olabilir. Aynı şekilde "sadece 0 ile başlayan metinler"
bir başka dil olabilir, vs. Yani, sayılabilir sonsuz olduğunu bildiğimiz
{0,1}* üzerinden, sonsuz kadar altküme oluşturuyoruz, tüm diller işte bu
kümede oluyor.</p>
<p>Bu yeni küme, sayılamayan bir sonsuzluktur. İspat için, yeni kümeyi, B
adını vereceğimiz sayılamayan sonsuz başka bir küme ile birebir ve örten
türden eşleyelim.</p>
<p>B kümesi, sigma alfabesi üzerinden yarattığımız ve her bir üyesi sonsuza
giden, ayrıca bu üyelerden sonsuz kadar olan bir kümedir.</p>
<p>Eğer eşleme başarı ile sonuçlanırsa, tüm dillerin de sayılamayan kadar
sonsuz olduğu ispatlanmış olacaktır.</p>
<p>Aşağıda bu eşlemenin bir örneğini görüyoruz. A ile gösterilen bir dildir. A
dili, 0 ile başlayan bütün ikili düzenli sayıların dili olsun. Şimdi, bu
dilin elemanlarına tekabül eden hemen altındaki Xa sırasına bakın. Bu
sırada, eğer bir öğe o dile ait ise, bu öğenin o sıradaki bit değeri 1
olacak. Ait değil ise 0.</p>
<p><img alt="" src="infinite_binary_esleme.png" /></p>
<p>Nereye gelmeye çalıştığımızı herhalde görüyoruz. $X_A$ numarasının tamâmı,
A dilinin bir nevi "temsilci numarası" olmaktadır. Aynı şekilde "1 ile
başlayan metinlerin toplamı olan dil"'in temsilci no'su başka olacaktır
(mesela $X_C$). Temsilci no'su, aynen B kümesinin elemanları gibi, sonsuza
giden bir ikili sayıdır. Bütün dillerin temsilci no'larının kümesi, B ile
tekabül eden bir ilişki içindedir.</p>
<p>Demek ki bütün diller sayılamayan sonsuzluktadır, çünkü B'nin sayılamayan
sonsuzlukta olduğunu ispatlamıştık. Kıyasla, Turing makinaları sayılabilir
sonsuz olduğuna göre, aradaki fark, karar verilemeyen diller olacaktır. Bu
dilleri karar verebilen Turing makinasının yazılması mümkün değildir.</p>
<p>Kaynaklar </p>
<p>[1] Papadimitrou, <em>Computational Complexity</em></p>
        </section>          
      </div>
    </body>
</html>
