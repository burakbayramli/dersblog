<p><a href="..">Yukarı</a></p>
<h1>Uygulama - Yağmur Yağış Verisi</h1>
<!DOCTYPE html>
<html>
  <head>
    <title>Uygulama - Yağmur Yağış Verisi
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
<script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
</script>
</head>

<pre><code class="python">import pandas as pd
df = pd.read_csv('rainfall.csv',index_col=0,parse_dates=['dt'])
df.columns = ['rain']
</code></pre>

<pre><code class="python">x = df[df.index.month == 3]['rain']
</code></pre>

<pre><code class="python">from scipy.stats import gamma
res = gamma.fit(df['rain'])
a,loc,scale = res  
x.hist(density=True)
plt.ylim(0,0.4)
plt.plot(x, gamma.pdf(x,a,loc,scale),'r.')
plt.savefig('stat_176_app1_01.png')
</code></pre>

<p><img alt="" src="stat_176_app1_01.png" /></p>
<p>Veriye olan uygunluğu kontrol için olasılık dağılımları arasında bir yakınlık
ölçüsü olan Kullback-Leibler mesafesini [2] kullanalım. Veri histogramı ve
tahmin edilen dağılım üzerinden üretilen verinin histogramı arasında mesafeyi
alttaki fonksiyon ile ölçebiliriz,</p>
<pre><code class="python">def kl(p, q):
    return np.sum(p * np.log(p / q))    
</code></pre>

<pre><code class="python">b = range(0,50)
eps = 1e-5
s = 4000
dh = np.histogram(df.rain, bins=b, density=True)[0]+eps

r1 = gamma.rvs(a,loc,scale,size=s)
h1 = np.histogram(r1, bins=b, density=True)[0]+eps
print ('Gamma', kl(h1, dh))
</code></pre>

<pre><code>Gamma 0.28355078534621225
</code></pre>

<pre><code class="python">from scipy.stats import weibull_min
res = weibull_min.fit(df['rain'])
a,loc,scale = res  
x.hist(density=True)
plt.ylim(0,0.4)
plt.plot(x, weibull_min.pdf(x,a,loc,scale),'r.')
plt.savefig('stat_176_app1_02.png')
</code></pre>

<p><img alt="" src="stat_176_app1_02.png" /></p>
<pre><code class="python">r2 = weibull_min.rvs(a,loc,scale,size=s)
h2 = np.histogram(r2, bins=b, density=True)[0]+eps
print ('Weibull Min', kl(h2, dh))
</code></pre>

<pre><code>Weibull Min 0.06455219814752436
</code></pre>

<p>Weibull Min daha yakin gozukuyor.</p>
<p>Yagmur Gunleri, Kuraklik Gunleri</p>
<p>Bazı araştırmalar ne kadar yağdını ayrı bir şekilde tahmin edip, yagıp
yağmadığını ayrı bir şekilde tahnin ediyor. Bu alanda Markov Zincirleri
kullanımı var. [4]'te gösterilen tek gün öncesine dayanarak yapılan
sonraki gün tahminidir (bkz ilk örnek te yağmur hakkında). Fakat önceki
iki gün tüm kombinasyonları kuru (D), yağışlı (W) üzerinden 4 konum ile
temsil edilirse, mesela DD, DW, WW, WD olarak, o zaman iki gün öncesi de
hesaba dahil edilebilir.</p>
<p>Markov Zinciri hazirligi, onceki gun yagis olup olmadigi D2, iki gun once D1,
bugun D3.</p>
<pre><code class="python">df = pd.read_csv('rainfall.csv',index_col=0,parse_dates=['dt'])
df.columns = ['rain']
df['r1ago'] = df.rain.shift(1)
df['r2ago'] = df.rain.shift(2)
df['D1'] = df.apply(lambda row: (row.r2ago &gt; 0.0).astype(int), axis=1)
df['D2'] = df.apply(lambda row: (row.r1ago &gt; 0.0).astype(int), axis=1)
df['D3'] = df.apply(lambda row: (row.rain &gt; 0.0).astype(int), axis=1)
pd.set_option('display.max_columns', None)
print (df)
</code></pre>

<pre><code>            rain  r1ago  r2ago  D1  D2  D3
dt                                        
2015-01-01   0.6    NaN    NaN   0   0   1
2015-01-02   0.0    0.6    NaN   0   1   0
2015-01-03   0.0    0.0    0.6   1   0   0
2015-01-04   0.0    0.0    0.0   0   0   0
2015-01-05   0.0    0.0    0.0   0   0   0
...          ...    ...    ...  ..  ..  ..
2022-01-27   0.0    0.0    0.0   0   0   0
2022-01-28   0.0    0.0    0.0   0   0   0
2022-01-29   0.0    0.0    0.0   0   0   0
2022-01-30   3.8    0.0    0.0   0   0   1
2022-01-31   0.0    3.8    0.0   0   1   0

[2588 rows x 6 columns]
</code></pre>

<pre><code class="python">g = df.groupby(['D1','D2','D3']).size().reset_index()
print (g)
#pivot = g.pivot_table(index=['D1','D2'], columns='D3', aggfunc='mean')
#print (pivot)
</code></pre>

<pre><code>   D1  D2  D3    0
0   0   0   0  633
1   0   0   1  269
2   0   1   0  244
3   0   1   1  253
4   1   0   0  268
5   1   0   1  228
6   1   1   0  253
7   1   1   1  440
</code></pre>

<p>Bu sayilari nasil Markov matrisine cevirecegimizi anlamak icin [1, sf. 193],</p>
<p>[devam edecek]</p>
<p>Kaynaklar</p>
<p>[1] <em>Meteorological Service Singapore</em>,
    <a href="http://www.weather.gov.sg/climate-historical-daily/">http://www.weather.gov.sg/climate-historical-daily/</a></p>
<p>[2] Bayramli, <em>Kullback-Leibler (KL) Mesafesi</em></p>
<p>[3] Ross, <em>Introduction to Probability Models, 10th Ed</em></p>
<p>[4] Bayramli, <em>Lineer Cebir, Markov Zincirleri</em></p>