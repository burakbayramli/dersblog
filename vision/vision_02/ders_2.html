<!DOCTYPE html>
<html>
  <head>
    <title>Ders 2
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
   <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
   </script>
   <link rel="stylesheet" type="text/css" media="screen" href="https://burakbayramli.github.io/css/style.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1548953794786292"
          crossorigin="anonymous"></script>  
  </head>
    <body>
      <div id="header_wrap" class="outer">
        <header class="inner">
          <h1 id="project_title">
            <a href="https://burakbayramli.github.io" style="text-decoration:none; color:inherit;">dersblog</a>
          </h1>
          <h2 id="project_tagline"></h2>          
        </header>
      </div>
      <div id="main_content_wrap" class="outer">        
        <section id="main_content" class="inner">
        <h1>Ders 2
</h1>

<p>Çoğunlukla özvektör kavramına atıf yapıldığında söylenmek istenen ($C$
kompleks sayıların kümesi olsun),</p>
<p>$$ Av = \lambda v, \qquad \lambda \in C $$</p>
<p>ifadesidir, yani "sağ özvektör", yani bir matrisi <em>sağdan</em> çarpınca
boyu büyüyen ya da küçülen vektör. Sol özvektörler de mümkün, bu durumda, </p>
<p>$$ v^TA = \lambda v^T, \qquad \lambda \in C $$</p>
<p>$A$'nin spektrumu $\sigma(A)$ o matrisin tüm özvektörlerinin
kümesidir. Numpy ile</p>
<pre><code class="python">import numpy.linalg as lin
A = [[3,4,3],[5,5,6],[5,5,5]]
A = np.array(A)
[V,D] = lin.eig(A)
print 'ozvektorler'
print D
print 'ozdegerler'
print V
</code></pre>

<pre><code>ozvektorler
[[-0.41963784+0.j          0.72738656+0.j          0.72738656-0.j        ]
 [-0.66394149+0.j         -0.42567121+0.33744486j -0.42567121-0.33744486j]
 [-0.61893924+0.j         -0.25117492-0.33579002j -0.25117492+0.33579002j]]
ozdegerler
[ 13.75351937+0.j          -0.37675969+0.47073926j  -0.37675969-0.47073926j]
</code></pre>

<p>Eğer $B = PAP^{-1}$, ki $P$ eşsiz olmayacak şekilde, o zaman $\sigma(B) =
\sigma(A)$. İspatsız veriyoruz. Yani $P$ ve onun tersi ile bir matrisi iki
taraftan çarpmak, o matrisin spektrumunu değiştirmiyor.</p>
<p>Eğer $\lambda \in C$ bir özdeğer ise, onun eşleniği (conjugate)
$\bar{\lambda}$ da bir özdeğerdir. Bu sebeple reel matris $A$ için
$\sigma{A} = \overline{\sigma{A}}$. </p>
<p>Bir reel matrisin tüm özdeğerlerinin reel olduğu "güzel" bir durum
vardır; bu durum matrisin simetrik olduğu durumdur, yani $S^T = S$. Bu
güzel durum aslında pratikte pek çok kez karşımıza çıkar; mesela kovaryans
matrisleri olarak.</p>
<p>Simetrik matrisin özgün özdeğerlerine tekabül eden özvektörleri birbirine
dikgendir. İspat, $v_i^T S v_j $ formülüne bakalım, ki $v_i,v_j$
özvektörler, $S$ simetrik matris.</p>
<p>Özdeğer eşitliğinden $S v_j = \lambda_j v_j$ kullanırsam,</p>
<p>$$ v_i^T S v_j  = \lambda_j v_i^T v_j $$</p>
<p>Eğer  $v_i^TS = \lambda_i v_i^T$ kullanırsam,</p>
<p>$$ v_i^T S v_j  = \lambda_i v_i^T v_j $$</p>
<p>elde ederim. İkisini bir araya koyalım,</p>
<p>$$ \lambda_j v_i^T v_j =  \lambda_i v_i^T v_j $$</p>
<p>$$ (\lambda_j-\lambda_i) v_i^T v_j = 0$$</p>
<p>Bu eşitliğin doğru olması sadece iki durumda olabilir; ya
$\lambda_i,\lambda_j$ birbiriyle aynıdır, ya da birbirinden farklıdır ama
o zaman  $v_i,v_j$ birbirine dikgen olmalıdır. </p>
<p>[norm atlandı]</p>
<p>Eksi Bakışımlı Matrisler (Skew-symmetric Matrices)</p>
<p>Eğer $A^T = -A$ ise bu matrislere eksi bakışımlı deniyor [5]. Mesela</p>
<p>$$ 
\left[\begin{array}{rr}
0 &amp; 2 \\ -2 &amp; 0
\end{array}\right]
 $$</p>
<p>Bu matrisin devriği ve negatifi aynıdır. Eksi bakışımlı matrislerin
köşegeni sıfır olmalıdır. Bu tür matrislerin ilginç bazı özellikleri var,
mesela, hatırlarsak simetrik matrislerin pür reel spektrumu vardı. Eksi
bakışımlı matrislerin spektrumu pür sanaldır (imaginary).</p>
<p>[köşegenleştirme atlandı]</p>
<p>Çapraz Çarpım (cross-product) </p>
<p>Noktasal çarpım bize bir skalar verir. İki vektör arasındaki çapraz çarpım
bize başka bir vektör verir; $u,v \in \mathbb{R}^3$ olmak üzere çapraz çarpım,</p>
<p>$$ 
u \times v = 
\left[\begin{array}{r}
u_2v_3 - u_3v_2 \\
u_3v_1 - u_1v_3 \\
u_1v_2 - u_2v_1 
\end{array}\right]
$$</p>
<p>Yani $\mathbb{R}^3$'teki iki vektör $u,v$'nin çapraz çarpımı alınabilir, ve
$\mathbb{R}^3$'te yeni bir vektör elde ederiz. Bu yeni vektör $u,v$'ye
dikgendir. Sağ el kuralı (alttaki resimde $u,v$ yerine $a,b$ kullanılmış)</p>
<p><img alt="" src="righthand.png" /></p>
<p>Ayrıca çapraz çarpım simetriktir, $u \times v = - u \times v$. </p>
<p>Eksi Bakışımlı Matris (Skew-Symmetric Matrix)</p>
<p>Bilgisayar Görüşü (Computer Vision) alanında oldukça yaygın bir matris olan
eksi bakışımlı bir matris alttadır, ve onu herhangi bir vektörden oluşturan
şapka operatörüyle gösterelim, yani $u$ için $\hat{u}$ olsun,</p>
<p>$$ 
\hat{u} = \left[\begin{array}{rrr}
0 &amp; -u_3 &amp; u_2 \\
u_3 &amp; 0 &amp; -u_1 \\
-u_2 &amp; u_1 &amp; 0
\end{array}\right] \in \mathbb{R}^{3 \times 3}
 $$</p>
<p>Bu tür matrislerin kertesinin çift sayı olması şarttır.</p>
<p>$\hat{u}$'nun ilginç bir özelliği var, herhangi bir vektör $v$ ile</p>
<p>$$ \hat{u}v = u \times v $$</p>
<p>ki $\times$ bir çapraz çarpım. Yani, öncelikle, her vektörün bir eksi
bakışımlı matris karşılığı var, ve üstteki operatör ile bu geçişi
yapabiliriz, ayrıca ne zaman bir çapraz çarpım görsek, onu eksi bakışımlı
matris çevirimi üzerinen bir normal matris çarpımı olarak temsil
edebiliriz. Bu faydalı çünkü çapraz çarpımla uğraşmak biraz külfetli
olabiliyor. </p>
<p>3 boyut bağlamında $\hat{u}$'nun kertesi tabii ki 2'dir; çünkü eksi
bakışımlı matrislerinin kertesinin çift olması şart ise, ve 3 boyutlu
durumda bu kerte en fazla 3 olabilir, ama 3 olamaz çünkü 3 çift sayı değil,
o zaman 2 olur.</p>
<pre><code class="python">import numpy as np

def skew(a):
   return np.array([[0,-a[2],a[1]],[a[2],0,-a[0]],[-a[1],a[0],0]])
</code></pre>

<pre><code class="python">A = np.array([[1,2,3]]).T
print skew(A)
</code></pre>

<pre><code>[[ 0 -3  2]
 [ 3  0 -1]
 [-2  1  0]]
</code></pre>

<p>$A^3$</p>
<p>Diyelim ki $A$ bir $3 \times 3$ eksi bakışımlı matris, ve $a =
(a_1,a_2,a_3)$ vektörü üzerinden oluşturulmuş. $A^3$ nedir? </p>
<p>$$A \cdot x = u \times x$$</p>
<p>olduğunu biliyoruz. O zaman </p>
<p>$$A^3 x = a \times ( a \times ( a \times x))$$</p>
<p>demektir. Eşitliğin sağ tarafına bakarsak, eğer $a=e$, ki $e$ bir birim vektörü
olsun, yani $||e||=1$, o zaman norm'ların ilişkisi şu şekilde olurdu,</p>
<p>$$||e\times(e\times (e\times x)))\|=||e\times (e\times x))|| =||e\times x||$$</p>
<p>Neden? </p>
<p>$$ ||e \times x|| = ||e||||x|| \sin \theta = ||x|| \sin \theta$$</p>
<p>O zaman,</p>
<p>$$||e\times (e\times x))|| = ||e|||| e \times x|| \sin 90 = ||e \times x||$$</p>
<p>Böyle gider. Yani norm eşitlikleri doğru. </p>
<p>Eğer $a = ||a||e$ kabul edersek,</p>
<p>$$||a\times(a\times (a\times x)))|| = ||a||^3 ||e\times(e\times (e\times x)))||$$</p>
<p>$$ =\|a\|^3\|e\times x\| $$</p>
<p>$$ =\|a\|^2\|a\times x\| $$</p>
<p>$$ =(a^Ta)\|a\times x\| $$</p>
<p>Yani $A^3x = \pm (a^Ta) Ax$; eksi mi artı mı? Eksi işareti olduğunu sağ el
kuralıyla görebiliriz. Demek ki $A^3 = -(a^Ta) \cdot A$. </p>
<p>Simetrik matrisler için </p>
<p>$$ A = UDU^T $$ </p>
<p>olduğunu biliyoruz. Eksi bakışımlı matrisler için </p>
<p>$$ S = UBU^T $$</p>
<p>olur ki $B$ bir blok köşegen matristir, $U$ dikgen. $S$'in özdeğerleri pür
sanaldır. Blok köşegen matris $diag(a_1Z,a_2Z,...,z_mZ,0,..0)$, ve $Z =
\left[\begin{array}{cc} 0 &amp; 1 \\ -1 &amp; 0 \end{array}\right]$. 
Köşegende blok olması garip gelebilir, fakat tek sayılar yerine çapraz
yönde birkaç sayının "üst üste" olduğu bir durum bu. Basit matris
çarpımı ile kolay bir şekilde kontrol edilebilir ki</p>
<p>$Z^2 = -I, \qquad Z^3 = -Z, \qquad Z^4 = I$</p>
<p>Matris Üstelleri (Matrix Exponentials) [1, sf. 482]</p>
<p>$t \in \mathbb{R}$ ve bir kare matris $n \times n$ matrisi $A$ için, matris üsteli,</p>
<p>$$ U(t) = e^{tA} = \exp(tA) $$</p>
<p>alttaki problem için özgün bir $n \times n$ çözümüdür;</p>
<p>$$ \frac{dU}{dt} = AU, \qquad U(0) = I $$</p>
<p>Dikkat: matris üsteli $\exp$ fonksiyonun teker teker matris öğeleri
üzerinde işletilmiş hali değildir.</p>
<p>Matris üstelleri bir seri olarak ta gösterilebilir, </p>
<p>$$ e^{tA} = \sum_{n=0}^{\infty} \frac{t^n}{n!} A^n = 
I + tA + \frac{t^2}{2}A^2 + \frac{t^3}{6}A^3 + ...
$$</p>
<p>Bu seri yakınsayan (converging) bir seridir. </p>
<p>Örnek</p>
<p>$$ A = \left[\begin{array}{rrr}
0 &amp; 1 \\ 0 &amp; 0
\end{array}\right] $$</p>
<p>için </p>
<p>$$ e^{tA} = \left[\begin{array}{rrr}
1 &amp; t \\ 0 &amp; 1
\end{array}\right] $$</p>
<p>Örnek</p>
<p>$$ A = \left[\begin{array}{rrr}
1 &amp; 0 \\ 0 &amp; 1
\end{array}\right] $$</p>
<p>için </p>
<p>$$ e^{tA} = \left[\begin{array}{rrr}
e^t &amp; 0 \\ 0 &amp; e^t
\end{array}\right] $$</p>
<p>Teori </p>
<p>Eğer $A$ bir eksi bakışımlı matris ise, $Q(t) = e^{tA}$ muntazam 
(proper) bir dikgen matristir. </p>
<p>İspat </p>
<p>Dikgenlik tersi ile devriğin aynı olması demektir, o zaman üstteki
eşitlikte sol tarafın tersi, sağ tarafın devriği aynı olmalı, yani
$Q(t)^{-1}$ ile $e^{tA^T}$.</p>
<p>$$ Q(t)^{-1} = e^{-tA} = e^{tA^T} = (e^{tA})^T = Q(t)^T $$</p>
<p>Hakikaten de öyle. </p>
<p>Not: Bir diğer ispata göre <em>tüm</em> dikgen matrisler bir eksi bakışımlı
matrisin $e$'nin üsteli alınarak oluşturulabilir. Buradaki nüansa dikkat,
tüm eksi bakışımlı matrislerin üsteli dikgendir demek ile <em>tüm</em> dikgen
matrisler eksi bakışımlı matrislerin üsteli alınmış halidir demek farklı.</p>
<p>Rotasyon</p>
<p>Genel olarak rotasyon bir eksen ve o eksen etrafındaki bir açı olarak
gösterilebilir,</p>
<p><img alt="" src="rotation.png" /></p>
<p>Ya da rotasyon eksenini $\hat{n}$ olarak gösterelim, ve dönüşün o eksene
dikgen olan bir düzlem üzerinde olduğunu düşünelim [3, sf. 37],</p>
<p><img alt="" src="rotation2.png" /></p>
<p>Yani $v$ vektörü, $\hat{n}$ etrafında $\theta$ kadar dönüp $u$ olacak. $\hat{n}$ birim vektör, 
ve dikgen olduğu düzlemi tanımlamak için kullanılıyor.</p>
<p>$v$'nin dönüşten etkilenmeyen bileşeni $v_\parallel$'yi hesaplamak için
$v$'nin $\hat{n}$ üzerine olan yansımasını (projection) hesaplayabiliriz. 
Yansıtma formülü, bkz [2],</p>
<p>$$ v_\parallel =  \frac{\hat{n}\hat{n}^T}{\hat{n}^T\hat{n}} v 
= (\hat{n}\hat{n}^T) v
$$</p>
<p>Peki $v$'nin düzlem üzerindeki yansıması $v_\perp$ nedir? Resme göre $v =
v_\perp + v_\parallel$ olduğuna göre ve üstteki formülü yerine koyunca,</p>
<p>$$ v_\perp = v - v_\parallel 
= v - (\hat{n}\hat{n}^T) v 
= (I - \hat{n}\hat{n}^T) v
$$</p>
<p>Burada $v_\perp$'in 90 derece çevrilmiş hali $v_x$ nedir? Aslında bu
$\hat{n} \times v$ olmalı, sağ el kuralıyla bu görülebilir. Eğer $N$
matrisini $\hat{n}$'i baz alan bir eksi bakışımlı matris olarak alırsak, </p>
<p>$$ v_x = \hat{n} \times v = Nv $$</p>
<p>ki $\hat{n}$ öğeleri $\hat{n}_x,\hat{n}_y,\hat{n}_z$ olacak şekilde</p>
<p>$$ 
N = \left[\begin{array}{rrr}
0 &amp; -\hat{n}_x  &amp; \hat{n}_y \\
\hat{n}_z &amp; 0 &amp; -\hat{n}_x \\
-\hat{n}_y &amp; \hat{n}_z &amp; 0
\end{array}\right]
 $$</p>
<p>Eğer $v_\perp$'u tekrar saat yönü tersinde 90 derece döndürmek istesek,
tekrar aynı çarpımı yapardık,</p>
<p>$$ v_{xx} = \hat{n} \times v_x =  N  v_x = N \cdot N v = N^2v = -v_\perp
$$</p>
<p>çünkü $v_{xx} = -v_\perp$. Şimdi tekrar $v_\parallel = v - v_\perp$ formülüne dönelim,</p>
<p>$$ v_\parallel = v - v_\perp = v + v_{xx} = v + N^2v  = (I+N^2)v $$</p>
<p>Eğer $u_\perp$'u $v_\perp$ ve $v_x$ üzerinden tanımlamak istersek, önce $u_\perp$'un $v_\perp$ 
vektörünün $\theta$ kadar döndürülmüş hali olduğu bilgisini kullanabiliriz. </p>
<p>Bu dönme işlemi iki boyuttadır (yani aynı düzlem üzerinde) o zaman standart
rotasyon matrisi yeterli,</p>
<p>$$ 
u_\perp = R_\theta \cdot v_\perp = 
\left[\begin{array}{rrr}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta
\end{array}\right]
\left[\begin{array}{rrr}
v_\perp^1 \\
v_\perp^2
\end{array}\right] = 
\left[\begin{array}{rrr}
v_\perp^1 \cos \theta  - v_\perp^2 \sin \theta \\
v_\perp^2 \cos \theta  + v_\perp^1 \sin \theta<br />
\end{array}\right]
$$</p>
<p>$$ =
\cos \theta
\left[\begin{array}{rrr}
v_\perp^1  \\
v_\perp^2 <br />
\end{array}\right] 
+ 
\sin \theta
\left[\begin{array}{rrr}
 - v_\perp^2  \\
 + v_\perp^1<br />
\end{array}\right] 
$$</p>
<p>Dikkat, $\sin \theta$ ile çarpılan vektör, aynı zamanda $v_\perp$'un 90 derece
döndürülmüş hali. Kontrol edelim, $\theta = 90$'lik rotasyon matrisi 
üzerinden,</p>
<p>$$ 
\left[\begin{array}{rrr}
0 &amp; -1 \\ 1 &amp; 0
\end{array}\right]
\left[\begin{array}{rrr}
v_\perp^1 \\
v_\perp^2
\end{array}\right] = 
\left[\begin{array}{rrr}
-v_\perp^2 \\
v_\perp^1
\end{array}\right]
$$</p>
<p>Doğrulandı. Ayrıca önceden biliyoruz ki $v_\perp$'u 90 derece döndürerek $v_x$'i elde
etmiştik. O zaman iki üstteki formül</p>
<p>$$ u_\perp = \cos \theta v_\perp + \sin \theta v_x $$</p>
<p>olarak gösterilebilir. Daha önce hesapladığımız $v_\perp$ ve $v_x$'i
yerlerine koyarsak, </p>
<p>$$ = \sin \theta Nv - \cos \theta N^2 v $$</p>
<p>$$ u_\perp = (\sin \theta N - \cos \theta N^2) v $$</p>
<p>Hepsini bir araya koyarsak, </p>
<p>$$ u = u_\perp + v_\parallel $$</p>
<p>$$ = ( \sin \theta N - \cos \theta N^2 + I + N^2)v  $$</p>
<p>$$ = \big( I + \sin \theta N - (1-\cos \theta) N^2 \big) v  $$</p>
<p>Yani bir eksen $\hat{n}$ etrafında $\theta$ kadar dönüşü bir matris olarak
yazabiliriz ki bu matrisin formülü şu şekilde olur, </p>
<p>$$ R(\hat{n},\theta) =  I + \sin \theta N - (1-\cos \theta) N^2 $$</p>
<p>ki bu Rodriguez formülüdür. </p>
<p>Altta $(-1/3,2/3,2/3)$ ekseni etrafında 70 derece dönüş birkaç farklı
açıdan gösteriliyor. </p>
<pre><code class="python">o = np.array([5,5,5])
v = np.array([3,3,3])
n = [-1/3.,2/3.,2/3.]
</code></pre>

<pre><code class="python">import skew
theta = np.deg2rad(70)
N = skew.skew(n)
R = np.eye(3) + np.sin(theta) * N - (1-np.cos(theta))*N**2
print R
vr = np.dot(R,v)
print vr
</code></pre>

<pre><code>[[ 1.         -0.91889724  0.33402626]
 [ 0.33402626  1.          0.240122  ]
 [-0.91889724 -0.38633975  1.        ]]
[ 1.24538705  4.72244477 -0.91571096]
</code></pre>

<pre><code class="python">from mpl_toolkits.mplot3d import axes3d
from matplotlib.patches import Circle, PathPatch
import matplotlib.pyplot as plt
from matplotlib.transforms import Affine2D
from mpl_toolkits.mplot3d import art3d
import numpy as np

def plot_vector(fig, orig, v, color='blue'):
   ax = fig.gca(projection='3d')
   orig = np.array(orig); v=np.array(v)
   ax.quiver(orig[0], orig[1], orig[2], v[0], v[1], v[2],color=color)
   ax.set_xlim(0,10);ax.set_ylim(0,10);ax.set_zlim(0,10)
   ax = fig.gca(projection='3d')  
   return fig

def rotation_matrix(d):
    sin_angle = np.linalg.norm(d)
    if sin_angle == 0:return np.identity(3)
    d /= sin_angle
    eye = np.eye(3)
    ddt = np.outer(d, d)
    skew = np.array([[    0,  d[2],  -d[1]],
                  [-d[2],     0,  d[0]],
                  [d[1], -d[0],    0]], dtype=np.float64)

    M = ddt + np.sqrt(1 - sin_angle**2) * (eye - ddt) + sin_angle * skew
    return M

def pathpatch_2d_to_3d(pathpatch, z, normal):
    if type(normal) is str: #Translate strings to normal vectors
        index = &quot;xyz&quot;.index(normal)
        normal = np.roll((1.0,0,0), index)

    normal /= np.linalg.norm(normal) #Make sure the vector is normalised
    path = pathpatch.get_path() #Get the path and the associated transform
    trans = pathpatch.get_patch_transform()

    path = trans.transform_path(path) #Apply the transform

    pathpatch.__class__ = art3d.PathPatch3D #Change the class
    pathpatch._code3d = path.codes #Copy the codes
    pathpatch._facecolor3d = pathpatch.get_facecolor #Get the face color    

    verts = path.vertices #Get the vertices in 2D

    d = np.cross(normal, (0, 0, 1)) #Obtain the rotation vector    
    M = rotation_matrix(d) #Get the rotation matrix

    pathpatch._segment3d = np.array([np.dot(M, (x, y, 0)) + (0, 0, z) for x, y in verts])

def pathpatch_translate(pathpatch, delta):
    pathpatch._segment3d += delta

def plot_plane(ax, point, normal, size=10, color='y'):    
    p = Circle((0, 0), size, facecolor = color, alpha = .2)
    ax.add_patch(p)
    pathpatch_2d_to_3d(p, z=0, normal=normal)
    pathpatch_translate(p, (point[0], point[1], point[2]))

</code></pre>

<pre><code class="python">from mpl_toolkits.mplot3d import Axes3D
import plot3d
fig = plt.figure()
ax = Axes3D(fig)
plot3d.plot_vector(fig, o, v)
ax.hold(True)
plot3d.plot_vector(fig, o, vr, 'cyan')
ax.hold(True)
plot3d.plot_vector(fig, o, 3*np.array(n), 'red')
ax.hold(True)
plot3d.plot_plane(ax, o, n, size=3)
ax.view_init(elev=40., azim=10)
plt.savefig('vision_02_01.png')
ax.view_init(elev=30., azim=40)
plt.savefig('vision_02_02.png')
ax.view_init(elev=40., azim=50)
plt.savefig('vision_02_03.png')
ax.view_init(elev=50., azim=80)
plt.savefig('vision_02_04.png')
</code></pre>

<p><img alt="" src="vision_02_01.png" />
<img alt="" src="vision_02_02.png" /></p>
<p><img alt="" src="vision_02_03.png" />
<img alt="" src="vision_02_04.png" /></p>
<p>SVD </p>
<p>Bu işlemin özdeğer / özvektör hesabının karesel olmayan matrisler
durumundaki genelleştirilmiş hali olduğu düşünülebilir. Pek çok lineer
cebir işlemi, mesela tersini alma, kerte hesabı, vs. SVD bağlamında
incelenebilir. Genelleştirme dedik, eğer $A$ karesel değilse özvektörleri
hesaplayamayız, ama $A^TA$ kareseldir, ve bu matrisin özvektörleri $A$'nin
SVD'si ile yakından alakalıdır.</p>
<p>[İspat atlandı]</p>
<p>Geometrik olarak $A = U \Sigma V^T$ ile gösterilen SVD'nin bir $x \in
\mathbb{R}^n$'yi $A$ uzerinden transform ettiğimiz durumda, $y = Ax$
diyelim, $y$'nin $U$'da bazındaki kordinatlarının $V$ bazındaki
kordinatları ile bir ilişki ortaya çıkarttığını söyleyebiliriz; bu ilişki
$\Sigma$'nin öğeleri üzerinden bir ölçeklemeden ibarettir. Yani</p>
<p>$$ y = Ax = U\Sigma V^Tx 
\quad \Leftrightarrow \quad
U^Ty = \Sigma V^T x
$$</p>
<p>[birim küre ellipsoid eşlemesi atlandı]</p>
<p>Genelleştirilmiş Ters (Generalized -Moore Penrose- Inverse)</p>
<p>Lineer sistem çözerken $Ax = b$ için eğer $A$'nin tersi alınabiliyorsa,
çözüm kolay, $x^\ast = A^{-1}b$. Fakat $A$'nin tersi alınamıyorsa, ki bu $A$
karesel olmadığında otomatik olarak doğru olacaktır, ne yapacağız?
Genelleştirilmiş tersi alma, ya da sözde ters (pseudoinverse) işlemi burada
ise yarar. Sözde ters için, her $A$ için bir SVD olduğuna göre, $A = U
\Sigma V^T$, ve $\Sigma$'nın sıfır olmayan eşsiz değerlerinin tersi alınır (yani 
öğe $\sigma_i$, $1/\sigma_i$ olur), sıfır değerlerine dokunulmaz, bu sonuçlar yeni 
bir $\Sigma^{\dagger}$'in köşegenine dizilir, "sözde ters" bu matris olur,</p>
<p>$$ \Sigma^{\dagger} = \left[\begin{array}{cc}
\Sigma_1^{-1} &amp; 0 \\ 0 &amp; 0 
\end{array}\right]$$</p>
<p>Ve bu ters işlemi tüm $A$'nin tersini almak için kullanılır, ki bu sözde
tersi de boyutu $n \times m$ olan bir $A^{\dagger}$ ile gösteriyoruz
(İngilizce "$A$-dagger" olarak telafuz ediliyor, biz "$A$-kama"
diyelim), </p>
<p>$$ 
A^{\dagger} = V \Sigma^{\dagger} U^T<br />
\qquad (1)
$$</p>
<p>Bu noktaya nasıl geldiğimize dikkat, eğer SVD sonucunun pür tersini
alabilseydik, </p>
<p>$$ A^{-1} = V^{-T}\Sigma^{-1}U^{-1} $$</p>
<p>Dikgen matrisler için $Q^{-1}=Q^T$ olduğu için </p>
<p>$$ = V\Sigma^{-1}U^{T} $$</p>
<p>$\Sigma^{-1}$ olmadığı için yerine $\Sigma^{\dagger}$ kullanıyoruz ve (1)'e erişiyoruz.  </p>
<p>Bazı özellikler,</p>
<p>$$ A A^{\dagger} A = A $$</p>
<p>ya da</p>
<p>$$ A^{\dagger} A  A^{\dagger} =  A^{\dagger} $$</p>
<p>Peki sözde tersi alma işlemini denklem sistemi çözmekte nasıl kullanırız? </p>
<p>Lineer sistem çözümü bağlamında durumunda 3 türlü sonuç olabileceğini
görmüştük. Eğer sonsuz tane çözüm varsa, bu büyük bir ihtimalle problemin
tam kısıtlanmamış (constrained) olması ile alakalıdır. Tabii hiçbir çözüm
olmayabilir, ve size para veren kişi sizden hala çözüm beklemektedir (!),
bu durumda $Ax=b$'yi çözmek yerine ona en yakın olabilecek şeyi
çözebiliriz, yani $|Ax - b|^2$'yi minimize etmeyi seçebiliriz, $Ax$'i
$b$'yi mümkün olduğu kadar yaklaştırırız. Burada sözde ters ise yarar,
çünkü $x^\ast = A^{\dagger}b$ ile hesaplanan çözüm aynı zamanda $|Ax - b|^2$'yi
minimize eder! Bu çözüm En Az Kareler (Least Squares) çözümü olarak ta
bilinir, tabii burada sistem aşırı belirtilmiş (overdetermined) değil,
eksik belirtilmiş (underdetermined) durumda. Not: Ayrıca sözde ters ile
bulunan $x^\ast$'in mümkün tüm çözümler arasında "norm'ü en az olan $x^\ast$'i
bulduğu da" söylenir.</p>
<p>Eğer çözüm özgün ise, sözde ters yine işler, özgün çözümü bulur. Yani her
halükarda sözde ters tüm problemlerimizi çözer.</p>
<p>Lineer cebir'i böylece gözden geçirmiş olduk. Artık dersimizin ana
konularına başlayabiliriz. </p>
<p>Hareketli bir Sahneyi Temsil Etmek</p>
<p>Burada sahne dış dünya, yani kamera ile hareket ederken gördüğümüz şeyler. </p>
<p>Hareket ederken kamera pek çok resim alabilir, tabii bu dersimiz uzun
zamandır yapılan araştırmalara dayanıyor, ve bu araştırmalar çoğunlukla iki
resim durumuna odaklandılar; fakat günümüzde bir kamera saniyede mesela 30
tane resim çekebilir, bu durum için gerekli matematiği de göreceğiz. Önce
iki resimle başlayacağız, ve bu matematiğin daha genel, çok resimli haline
de kendimizi hazırlayacağız. </p>
<p>3D'de Yeniden Oluşturmak (3D Reconstruction)</p>
<p>Durağan olduğu kabul edilen 3D dış dünyayı pek çok açıdan ama iki boyutlu
resmi ile tekrar oluşturma çabasının bilimde uzun bir tarihi var. Bu
problem klasik bir "kötü konumlanmış (ill-posed)" problemdir, çünkü
yeniden oluşturulan sonuç tipik olarak özgün değildir (pek çok farklı
yeniden oluşturma mümkündür). Bu yüzden ek bazı kısıtlamalar getirmek
gerekir. Bu alanda hala yapılacak çok iş olduğunu belirtmek isterim, yani
bilim dalımız oldukça bakir [araştırmacılar, atlayın]. </p>
<p>Dış dünyanın gördüğümüz imajdaki nasıl oluştuğunu perspektif izdüşümü
(perspective projection) üzerinden modelleyeceğiz, bu modelleme kamera modeli
olarak iğne deliği kamera (pinhole camera) modelini kullanır. Bu modeli şöyle
hayal etmek mümkün, karanlık bir odadayız, duvarda tek bir delik var, ve bu oda
dışındaki tüm görüntüler bu delik üzerinden odaya giriyor. Perspektif izdüşüm
ilk kez Öklit tarafından, I.O. 400 yılında araştırıldı; bu hakikaten çok ilginç,
yani sonuçta bugün bilgisayarlar ile araştırdığımız bu konunun temelindeki bazı
kavramların ne kadar önceden beri bilindiği şaşırtıcı olabiliyor.</p>
<p>Ardından bu konu Rönesans sırasında çok yoğun araştırıldı, bu zamanlarda
yapılan resimlerdeki derinliği temsil etme çabaları bugüne kalan eserlerden
hepimiz biliyoruz. Sanatçılar, bilimciler iki boyut üzerinde derinliği, üç
boyutluluğu gösterebilmek için kafa yordular, ve perspektif izdüşümün
araştırılması 17. ve 18. yüzyılda perspektif geometrisi adında bir yeni alana
dönüştü.</p>
<p>Çoklu Bakış Açıdan Tekrar Oluşturma (Multiview Reconstruction) alanında
yapılan ilk araştırma oldukça eskiye gidiyor, ki bu da şaşırtıcı. Kruppa bu
konuyu 1913'te araştırdı, iki farklı kameranın aynı objeye dönük iki
resmine odaklandı, kendine şu soruyu sordu, "bu iki resimde en az kaç tane
noktaya bakmalıyım ki 3 boyutta bir model oluşturabileyim". Kruppa
gösterdi ki en az 5 nokta sonlu miktarda çözüm bulmak için yeterli, ki
kameranın hareketi de buna dahil. Tabii bulunan özgün tek çözüm değildir,
ama daha önce söylediğimiz gibi bu problem kötü konumlanmış bir problemdir,
ama en azından çözüm sonsuz tane değil, sonlu sayıda.</p>
<p>İki görüntüden hareket ve yapıyı çıkartabilen ilk lineer algoritma
Lonquet-Higgins tarafından 1981'de bulundu, bu algoritma eş kutupsal
kısıtlama (epipolar constraint) kullanarak bu işi becerdi. Bu derste eş
kutupsal kısıtlama konusunu öğreneceğiz. Bu buluş pek çok takip eden diğer
buluşa ilham verdi, 80 ve 90'li yıllarda ek buluşlar yapıldı. Ardından
alanımızın klasik kitaplarından Zisserman ve arkadaşlarının yazdığı Çoklu
Bakış Açı Geometrisi (<em>Multiple View Geometry</em>) adlı kitap var, ve iş
giderek bizim bu derste kullandığımız en güncel olan kitaba geliyor, 
<em>An Invitation to 3D Vision</em>. </p>
<p>Derste işlediğimiz konu farklı isimlerde ortaya çıkabiliyor, hareketten
yapı çıkartmak (structure from motion) ismini gördük, bir diğer isim görsel
(visual) SLAM, ki SLAM kısaltması "aynı anda yer belirlemek ve haritalamak
(simultaneous localization and mapping)" kelimelerinden geliyor. Robotik
alanındakiler bu kelimeyi çok kullanırlar, bir robotun dış dünyada hem
etrafını haritalaması, hem de aynı anda o harita içindeki yerini
kestirebilmesi, hesaplaması bu alanın baş problemlerinden. Tabii görsel
SLAM bunu görsel olarak yapabilmek; çünkü çok farklı şekillerde SLAM
yapılabiliyor, mesela 1. ders başında söylediğimiz gibi lazer
algılayıcılarla SLAM yapılabilir, hatta sonar algılayıcılarla bile, ya da
tüm bunları bir algılayıcı füzyonu (sensor fusion) üzerinden birleştirerek.</p>
<p>Kaynaklar </p>
<p>[1] Olver, <em>Applied Linear Algebra</em></p>
<p>[2] Bayramlı, Lineer Cebir, <em>Ders 15</em></p>
<p>[3] Sastry, <em>An Invitation to 3-D Vision</em></p>
<p>[4] Zissermann, <em>Multiple View Geometry</em></p>
<p>[5] Bayramlı, Lineer Cebir, <em>Ders 5</em></p>
          <br/><a href="../index.html">Yukarı</a>
        </section>          
      </div>
    </body>
</html>
