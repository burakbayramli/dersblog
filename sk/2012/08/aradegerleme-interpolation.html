
<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
   <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
   </script>
   <link rel="stylesheet" type="text/css" media="screen" href="https://burakbayramli.github.io/css/style.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1548953794786292"
          crossorigin="anonymous"></script>  
  </head>
    <body>
      <div id="header_wrap" class="outer">
        <header class="inner">
          <h1 id="project_title">
            <a href="https://burakbayramli.github.io" style="text-decoration:none; color:inherit;">dersblog</a>
          </h1>
          <h2 id="project_tagline"></h2>          
        </header>
      </div>
      <div id="main_content_wrap" class="outer">        
        <section id="main_content" class="inner">
        <h1></h1>
<h1>Aradeğerleme (Interpolation)</h1>

<p>Özet olarak aradeğerleme eldeki veriye dayanarak bilinmeyen veriyi
tahmin etmek, boşlukları doldurma tekniklerine verilen isimdir. Eğer
elde x,y verisi var ise ki bu verinin f(x) = y gibi bir fonksiyondan
(artı gürültü) ile elde edildiği varsayılır, elde olmayan bir yeni x
verilince bunun eşleneceği y değeri acaba ne olur?</p>

<p>Bu bağlamda aradeğerleme model uydurma, modele sorma ikilisi ile
çözülebilir, mesela elimde alttaki gibi değerler var, veriye bir düz
çizgi uyduruyorum, yeni nokta 7 değeri sorulunca modele danışıyorum,
ve oradan gelen y sonucu aradeğerlenen sonuç oluyor.</p>

<p><img src="aradegerleme-interpolation_01.jpeg" alt="" /></p>

<p>Fakat illa ki formülsel bir model varlığı da gerekli değil; bazı
teknikler yakındaki noktalara bakarak yakın x, ya da eğer y değerleri
varsa yine yakın y değerleri döndürebilir. Her iki teknik te çok
boyutta kullanılabilir, hem x hem y değerleri vektör içinde olacaktır.</p>

<p>Konunun daha matematiksel açıklamalarını [1,2,3,4] yazılarında
bulabiliriz.  Bu yazı daha çok pür yazılımsal tekniklere odaklanacak,
ve direk kütüphane çağrılarına bakacağız. Daha çok yemek tarifi daha az
formül.</p>

<h3>Pandas</h3>

<p>Pandas paketinin de içinde aradeğerleme yapabilen kodlar var, bunlar
bir DataFrame tablosunun eksik değerlerini doldurmak için kullanılabiliyor.
Mesela,</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">df</span><span class="p">)</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>      0
0   1.0
1   2.0
2   3.0
3   NaN
4   5.0
5   6.0
6   7.0
7   6.0
8   5.0
9   NaN
10  4.0
11  3.0
</code></pre>
</div>

<p><code>NaN</code> degerleri eksik. Doldurmak icin basit lineer aradegerleme yapilabilir,</p>

<div class="codehilite">
<pre><span></span><code><span class="nb">print</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">))</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>      0
0   1.0
1   2.0
2   3.0
3   4.0
4   5.0
5   6.0
6   7.0
7   6.0
8   5.0
9   4.5
10  4.0
11  3.0
</code></pre>
</div>

<p>Görüldüğü gibi 3 ile 5 arasındaki değer 4 ile dolduruldu, 5 ile 4 arasındaki
4.5 ile.</p>

<h3>Matriste Boş Değerleri Yakın Değerle Doldurmak</h3>

<p>Eğer içinde nan yani "tanımsız" ve "boş" değerler olan bir vektörümüz
var ise, bu tanımsız değerlerin yerine, yine aynı vektörde, ve o boş
değerin iki yanindaki değere yakın olan bir değerle doldurmak
isteyebiliriz.</p>

<p>Mesela vektor</p>

<pre><code>1, nan, nan, 2, 2, nan, 0
</code></pre>

<p>olsun, ve <code>nan</code> diyen yerlerde 1 ve 2 arası, sonraki <code>nan</code> yerine 2 ve 0
arası değerler olmalı.</p>

<div class="codehilite">
<pre><span></span><code><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">bad_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">good_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">bad_indexes</span><span class="p">)</span>
<span class="n">good_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">good_indexes</span><span class="p">]</span>
<span class="n">interpolated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">bad_indexes</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">good_indexes</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">good_data</span><span class="p">)</span>
<span class="n">data</span><span class="p">[</span><span class="n">bad_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolated</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>[ 1. nan nan  2.  2. nan  0.]
[1.         1.33333333 1.66666667 2.         2.         1.
 0.        ]
</code></pre>
</div>

<p>Peki işlemi bir matris üzerinde, ve her kolon için ayrı ayrı yapmak
istersek?</p>

<div class="codehilite">
<pre><span></span><code><span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">bad_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">good_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">bad_indexes</span><span class="p">)</span>
    <span class="n">good_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">good_indexes</span><span class="p">]</span>
    <span class="n">interpolated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">bad_indexes</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">good_indexes</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">good_data</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="n">bad_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolated</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span>
              <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">500</span><span class="p">]])</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>[[  1.  20. 300.]
 [  2.  30. 400.]
 [  3.  40. 500.]]
</code></pre>
</div>

<h3>RBF</h3>

<p>Bu tekniği daha önce [4]'de detaylı işledik. Fakat açıkça söylemek
gerekirse en yavaş işleyen aradeğerleme tekniklerinden biri
RBF'tır. Yine de bazen kullanışlı olabilir, basit bir örnekte görelim,
ana fonksiyon üç boyutlu bir fonksiyon olsun,</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">x1</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span> <span class="n">y1</span> <span class="o">=</span> <span class="mf">5.0</span>
    <span class="n">g1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="mi">4</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">s1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g1</span> 

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span>
<span class="n">xx</span><span class="p">,</span><span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="n">zz</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="p">)</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">zz</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;aradegerleme-interpolation_02.png&#39;</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="aradegerleme-interpolation_02.png" alt="" /></p>

<p>Eğer <code>func</code> fonksiyonu elde olmasaydı, onun verilerine bakarak RBF ile
yeni bir nokta için, 4,4 diyelim, aradeğerlemeyi alttaki gibi
yapardık,</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">Rbf</span>
<span class="n">rbfi</span> <span class="o">=</span> <span class="n">Rbf</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="p">,</span><span class="n">zz</span><span class="p">,</span><span class="n">function</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;Aradeg:&#39;</span><span class="p">,</span><span class="n">rbfi</span><span class="p">([</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">]),</span> <span class="s1">&#39;Gercek:&#39;</span><span class="p">,</span><span class="n">func</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>Aradeg: [0.53970076] Gercek: 0.540029869446153
</code></pre>
</div>

<p>Görüldüğü gibi kullanım oldukca basit; x,y,z değerlerini iki boyutlu
matris olarak verdik (tek boyutlu vektör de işliyor), RBF objesi
üzerinden ek değerler için aradeğerleme yaptık.</p>

<h3>CloughTocher2DInterpolator</h3>

<p>Hızlı işleyen bir kod, CloughTocher2DInterpolator.</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">CloughTocher2DInterpolator</span>

<span class="n">interp</span> <span class="o">=</span> <span class="n">CloughTocher2DInterpolator</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">flatten</span><span class="p">())),</span> <span class="n">zz</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">interp</span><span class="p">([</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">]))</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>[0.54049742]
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span>
<span class="n">xx2</span><span class="p">,</span><span class="n">yy2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">)</span>
<span class="n">zclough</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xx2</span><span class="p">,</span><span class="n">yy2</span><span class="p">)</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">zz</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;aradegerleme-interpolation_03.png&#39;</span><span class="p">)</span>
</code></pre>
</div>

<p><a href="aradegerleme-interpolation_03.png">Sonuç</a></p>

<p>Farkettiysek üstteki ızgara her ekseni 50 parçaya böldü, <code>interp</code>
objesi 30 parçalık izgara üzerinden yaratılmıştı; böylece elde olmayan
bir sürü değeri sormuş olduk ama nihai grafik hala orijinale
benziyor. Ayrıca Clough/Tocher yaklaşımı çok hızlı işler.</p>

<h3>NearestNDInterpolator</h3>

<p>En yakın değerleri kullanarak aradeğerleme yapan bir araçtır. Bazı
durumlarda üstteki daha çetrefil yaklaşımlardan daha iyi sonuç
verebilir.</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">NearestNDInterpolator</span>

<span class="n">interp</span> <span class="o">=</span> <span class="n">NearestNDInterpolator</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">flatten</span><span class="p">())),</span> <span class="n">zz</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">interp</span><span class="p">([</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">]))</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>[0.63261986]
</code></pre>
</div>

<h3>Izgara İçinde En Yakın Değer Aradeğerlemesi</h3>

<p>Aradeğerleme çoğunlukla bir ızgara bazlı yapılır, elde ayrıksal bir
ızgaradaki noktalara tekabül eden veri vardır, bu veriyi temel alarak
diğer noktaları kestirmek gerekir. Bir teknik şöyle: eğer ızgara
içinde düştüğümüz hücreyi bulabilirsek, o hücrenin dört köşesinin
x,y,z değerleri ile aradeğerleme yapılabilir. Burada iki lineerli
(bilinear) aradeğerleme tekniği var, her kenara olan uzaklığı ölçüp
bunlarla bir ağırlık değeri yaratıyor ve o ağırlıklara göre 4 bilinen
z değerini kullanıp yeni z değerini üretiyor. [5] bağlantısından
adapte edilen bir kod alttadır, <code>x</code>,<code>y</code> içinde <code>linspace</code> sonucu dizi
<code>zz</code> içinde ise gerçek fonksiyon sonucu <code>meshgrid</code> değerleri olduğunu
varsayıyor.</p>

<div class="codehilite">
<pre><span></span><code><span class="k">def</span> <span class="nf">bilinear_interpolator</span><span class="p">(</span><span class="n">x_new</span><span class="p">,</span><span class="n">y_new</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_new</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_new</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">wx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_new</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">wy</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_new</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">Pn</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">wx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">wy</span><span class="p">)</span><span class="o">*</span><span class="n">zz</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">wx</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">wy</span><span class="p">)</span><span class="o">*</span><span class="n">zz</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">wx</span><span class="p">)</span><span class="o">*</span><span class="n">wy</span><span class="o">*</span><span class="n">zz</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">wx</span><span class="o">*</span><span class="n">wy</span><span class="o">*</span><span class="n">zz</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Pn</span>
</code></pre>
</div>

<p>Buna benzer bir yaklaşımla biz de kendi tekniğimizi yaratabiliriz,
mesela içine düştüğümüz hücrenin dört kenarına olan bir basit uzaklık
hesabı yaparız, uzaklığı benzerliğe çeviririz (yakın olan daha önemli
olsun diye) ve bu ağırlıklarla dört köşe z değerinin ağırlıklı
ortalamasını alırız.</p>

<p><img src="aradegerleme-interpolation_06.png" alt="" /></p>

<p>Resme göre anlatırsak A'nin x,y değerleri 0.2,0.8 sol üst köşeye daha
yakındır, o zaman A için bir z değeri ortalaması hesaplamak
gerekiyorsa sol üst köşenin z değeri (7 olarak gösteriliyor) diğer üç
köşedeki z değerlerinden (0,3,5) ortalamada daha fazla etkili
olmalıdır. Bir algoritma bu yakınlıkları dört köşe için ayrı ayrı
hesaplayabilir, ve bir ağırlıklama tekniği oluşturur.</p>

<p>Örnek veriyi yaratalım,</p>

<div class="codehilite">
<pre><span></span><code><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span> <span class="n">x1</span> <span class="o">=</span> <span class="mf">36.5</span><span class="p">;</span> <span class="n">y1</span> <span class="o">=</span> <span class="mf">32.5</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">;</span> <span class="n">x2</span> <span class="o">=</span> <span class="mf">36.1</span><span class="p">;</span> <span class="n">y2</span> <span class="o">=</span> <span class="mf">32.8</span>
    <span class="n">g1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="mi">4</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">s1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">g2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">s2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>    
    <span class="k">return</span> <span class="n">g1</span> <span class="o">+</span> <span class="n">g2</span> 
<span class="n">D</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">36</span><span class="p">,</span><span class="mi">37</span><span class="p">,</span><span class="n">D</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="n">D</span><span class="p">)</span>
<span class="n">xx</span><span class="p">,</span><span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="n">zz</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="p">)</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">zz</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;aradegerleme-interpolation_04.png&#39;</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="aradegerleme-interpolation_04.png" alt="" /></p>

<p>Verili x,y noktasının hangi hücre içinde olduğunu bulalım önce, burada
<code>np.searchsorted</code> cağrısı yapıldı, bu çağrı sıralı bir dizi içinde
aranan öğenin hangi aralığa düştüğünü hesaplıyor. Tüm <code>meshgrid</code>
çağrısından gelen ızgara içinde aramak yerine daha az noktası olan
düz dizi <code>x</code>,<code>y</code> içinde aramak daha iyi.</p>

<div class="codehilite">
<pre><span></span><code><span class="k">def</span> <span class="nf">find_corners</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">yi</span><span class="p">):</span>
    <span class="n">idx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">idx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">idx2</span><span class="p">,</span><span class="n">idx1</span><span class="p">),(</span><span class="n">idx2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">idx1</span><span class="p">),(</span><span class="n">idx2</span><span class="p">,</span><span class="n">idx1</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="n">idx2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">idx1</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">cs</span>
</code></pre>
</div>

<p>Örnek bir noktanın içinde olduğu hücrenin indis değerleri,</p>

<div class="codehilite">
<pre><span></span><code><span class="n">cs</span> <span class="o">=</span> <span class="n">find_corners</span><span class="p">(</span><span class="mf">36.5</span><span class="p">,</span><span class="mf">32.4</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">cs</span><span class="p">)</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>[(8, 10), (7, 10), (8, 9), (7, 9)]
</code></pre>
</div>

<p>Noktanın içine düştüğü hücre kenarları bulununca onlara olan uzaklık
hesaplanır, uzaklık bir yakınlık / benzerlik hesabına çevrilir, ve bu
hesap her köşenin z değeri üzerinden bir ağırlıklı ortalama için kullanılır.</p>

<div class="codehilite">
<pre><span></span><code><span class="k">def</span> <span class="nf">cdist</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">):</span>    
    <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">distances</span>

<span class="k">def</span> <span class="nf">cell_interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)[:,:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">ds</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)[:,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">iz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">ds</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">iz</span>

<span class="k">def</span> <span class="nf">grid_interp</span><span class="p">(</span><span class="n">intx</span><span class="p">,</span><span class="n">inty</span><span class="p">):</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">find_corners</span><span class="p">(</span><span class="n">intx</span><span class="p">,</span><span class="n">inty</span><span class="p">)</span>

    <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cs</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">i0</span><span class="p">,</span><span class="n">j0</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">i1</span><span class="p">,</span><span class="n">j1</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">i2</span><span class="p">,</span><span class="n">j2</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">i3</span><span class="p">,</span><span class="n">j3</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cs</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">introw</span> <span class="o">=</span> <span class="p">[(</span><span class="n">xx</span><span class="p">[</span><span class="n">i0</span><span class="p">,</span><span class="n">j0</span><span class="p">],</span><span class="n">yy</span><span class="p">[</span><span class="n">i0</span><span class="p">,</span><span class="n">j0</span><span class="p">],</span><span class="n">zz</span><span class="p">[</span><span class="n">i0</span><span class="p">,</span><span class="n">j0</span><span class="p">]),</span>
              <span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span><span class="n">j1</span><span class="p">],</span><span class="n">yy</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span><span class="n">j1</span><span class="p">],</span><span class="n">zz</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span><span class="n">j1</span><span class="p">]),</span>
              <span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="n">i2</span><span class="p">,</span><span class="n">j2</span><span class="p">],</span><span class="n">yy</span><span class="p">[</span><span class="n">i2</span><span class="p">,</span><span class="n">j2</span><span class="p">],</span><span class="n">zz</span><span class="p">[</span><span class="n">i2</span><span class="p">,</span><span class="n">j2</span><span class="p">]),</span>
              <span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="n">i3</span><span class="p">,</span><span class="n">j3</span><span class="p">],</span><span class="n">yy</span><span class="p">[</span><span class="n">i3</span><span class="p">,</span><span class="n">j3</span><span class="p">],</span><span class="n">zz</span><span class="p">[</span><span class="n">i3</span><span class="p">,</span><span class="n">j3</span><span class="p">])]</span>
    <span class="k">return</span> <span class="n">cell_interp</span><span class="p">(</span><span class="n">intx</span><span class="p">,</span><span class="n">inty</span><span class="p">,</span><span class="n">introw</span><span class="p">)</span>
</code></pre>
</div>

<p>Test amaçlı olarak yeni, daha yoğun bir izgara yaratalım,
<code>np.vectorize</code> ile aradeğerleme fonksiyonumuzu tüm matris üzerinde
uygulanabilir hale çevirebiliriz, ve hesabı yapıp gerçek değerler ile
tahmin arasında bir hata karesi ortalaması (mean square error) hesabı
yaparız,</p>

<div class="codehilite">
<pre><span></span><code><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">36.0001</span><span class="p">,</span><span class="mf">36.9999</span><span class="p">,</span><span class="n">D</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">32.0001</span><span class="p">,</span><span class="mf">32.9999</span><span class="p">,</span><span class="n">D</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
<span class="n">xx2</span><span class="p">,</span><span class="n">yy2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">)</span>
<span class="n">zz2</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">xx2</span><span class="p">,</span><span class="n">yy2</span><span class="p">)</span>

<span class="n">grid_interp_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">grid_interp</span><span class="p">,</span><span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span>
<span class="n">zz2_grid</span> <span class="o">=</span> <span class="n">grid_interp_vec</span><span class="p">(</span><span class="n">xx2</span><span class="p">,</span><span class="n">yy2</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">zz2</span><span class="o">-</span><span class="n">zz2_grid</span><span class="p">)))</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>0.0006008344674974951
</code></pre>
</div>

<p>Oldukça yakın. Ayrıca çağrı hızlı işledi. Grafikleyelim,</p>

<div class="codehilite">
<pre><span></span><code><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">xx2</span><span class="p">,</span> <span class="n">yy2</span><span class="p">,</span> <span class="n">zz2_grid</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;aradegerleme-interpolation_05.png&#39;</span><span class="p">)</span>
</code></pre>
</div>

<p><a href="aradegerleme-interpolation_05.png">Sonuç</a></p>

<h3>QuadTree</h3>

<p>Üzerinden aradeğerleme yapılacak değerler düzgün izgara şeklinde ise
üstteki teknik iyidir. Fakat bazen dağınık bir halde, içinde
boşluklar, eksik verisi olan bir öbek elde olabilir, bu durumda hangi
hücre içine düşüldüğü, dört köşe bulunması, vb. manevralar etkili
olmaz.</p>

<p>Eksik değerlerle iş yapabilmek için mevcut veriyi düz liste olarak
kabul edip (izgara olup olmadığına bakmadan) x,y kordinatları
üzerinden en yakın noktaları hızlı bir şekilde bize döndüren bir veri
yapısı kullanmamız gerekir. Bu tür yapılardan bazılarının detaylarını,
KDTree, BallTree gibi, [6]'da gördük. Bu yazıda QuadTree denen bir teknik
kullanacağız, paket <code>quads</code> içinde.</p>

<div class="codehilite">
<pre><span></span><code><span class="k">class</span> <span class="nc">QuadTreeInterpolator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">quads</span><span class="o">.</span><span class="n">QuadTree</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cell_interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)[:,:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">ds</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">ds</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">iz</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="p">,</span><span class="n">zz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">insert</span><span class="p">((</span><span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="p">),</span><span class="n">data</span><span class="o">=</span><span class="n">zz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">count</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">res</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>               

<span class="n">q</span> <span class="o">=</span> <span class="n">QuadTreeInterpolator</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">zz</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>    
<span class="n">qinterp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">interpolate</span><span class="p">,</span><span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span>
<span class="n">zz2_quad</span> <span class="o">=</span> <span class="n">qinterp</span><span class="p">(</span><span class="n">xx2</span><span class="p">,</span><span class="n">yy2</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">zz2</span><span class="o">-</span><span class="n">zz2_quad</span><span class="p">)))</span>
</code></pre>
</div>

<div class="codehilite">
<pre><span></span><code>0.0005101521958506852
</code></pre>
</div>

<p>Bu teknik te iyi sonuç verdi.</p>

<p>Kaynaklar</p>

<p>[1] <a href="https://burakbayramli.github.io/dersblog/compscieng/compscieng_app20cfit1/egri_uydurma_aradegerleme__interpolation___1.html">Eğri Uydurma, Aradeğerleme (Interpolation) - 1</a></p>

<p>[2] <a href="https://burakbayramli.github.io/dersblog/compscieng/compscieng_app20cfit2/egri_uydurma_aradegerleme__interpolation___2.html">Eğri Uydurma, Aradeğerleme (Interpolation) - 2</a></p>

<p>[3] <a href="https://burakbayramli.github.io/dersblog/compscieng/compscieng_app20cfit3/egri_uydurma_aradegerleme__interpolation___3.html">Eğri Uydurma, Aradeğerleme (Interpolation) - 3</a></p>

<p>[4] <a href="https://burakbayramli.github.io/dersblog/compscieng/compscieng_app20cfit4/aradegerleme__interpolation___4__dairesel_baz_fonksiyonlari__radial_basis_functions_rbf_.html">Aradeğerleme (Interpolation) - 4 - Dairesel Baz Fonksiyonları (Radial Basis Functions -RBF-)</a></p>

<p>[5] https://www.bottomscience.com/bilinear-interpolation-method-python/</p>

<p>[6] <a href="https://burakbayramli.github.io/dersblog/algs/algs_070_knn/en_yakin_kkomsu__knearest_neighbor__geometrik_yakinlik_hesabi.html">En Yakın k-Komşu (k-Nearest Neighbor), Geometrik Yakınlık Hesabı</a></p>

          <br/><a href="../index.html">Yukarı</a>
        </section>          
      </div>
    </body>
</html>
